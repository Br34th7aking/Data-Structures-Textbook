{"id": "117397", "block": {"feedback_correct": "", "name": "text", "feedback_wrong": "", "text": "<p>The second heap algorithm we will discuss is the removal operation, \"pop.\" Just like the insertion algorithm, it is actually quite simple when we use the constraints of a heap to derive it.</p><p>First, recall that the root element is by definition the highest-priority element in the heap. Thus, since we always remove the highest-priority element of a heap, the first step is to simply remove the root. However, since we need a valid tree structure, we need some other node to become the new root. In order to maintain the\u00a0<i>Shape Property</i> of the heap, we can simply place the \"last\" element of the heap (i.e., the rightmost element of the bottom row of the heap) as the new root.</p><p>By making the \"last\" element of the heap the new root, we most likely have violated the\u00a0<i>Heap Property</i>: the new root might have lower priority than its children, which would make the heap invalid. Thus, the next (and last) step of the \"pop\" algorithm should be intuitive as well: we must fix the (potentially) disrupted\u00a0<i>Heap Property</i> of our tree. To do so, we must\u00a0<b>trickle down</b> the newly-placed root: if the root has lower priority than its children, swap it with its highest-priority child; now, if it still has lower priority than its children in this new position, swap with its highest-priority child again; repeat until it has reached its correct place (either it has higher priority than all of its children, or it is a leaf of the tree).</p><p>Formally, the pseudocode of heap removal is as follows:</p><p></p><pre><code class=\"cpp\"><b>pop():</b>\n<b>    </b>replace the root with the rightmost element of the bottom level of the tree (call it \"curr\")\n    while curr is not a leaf and curr has lower priority than any of its children:\n        swap curr and its highest-priority child</code></pre><p></p><p>Below is a visualization of the heap \"pop\" algorithm, where we pop from the existing max-heap:</p><p><img src=\"https://ucarecdn.com/432d6cd9-8bf7-4121-997e-e8195943e139/\" alt=\"\" title=\"Image: https://ucarecdn.com/432d6cd9-8bf7-4121-997e-e8195943e139/\"></p><p><b></b><span class=\"wysiwyg-color-red\">\n\n<span class=\"wysiwyg-color-black\">Because of the </span><b></b><i><span class=\"wysiwyg-color-black\">Shape Property</span></i><span class=\"wysiwyg-color-black\"> of a heap, we are guaranteed to have a perfectly balanced binary tree, which means that we are guaranteed to have </span><b></b><span class=\"wysiwyg-color-black\">O(log </span><i><span class=\"wysiwyg-color-black\">n</span></i><span class=\"wysiwyg-color-black\">)</span><b></b><span class=\"wysiwyg-color-black\"> levels in our tree. If we have </span><i><span class=\"wysiwyg-color-black\">L</span></i><span class=\"wysiwyg-color-black\"> levels in our tree, in the worst case, we do </span><i><span class=\"wysiwyg-color-black\">L</span></i><span class=\"wysiwyg-color-black\">-1 comparisons for the trickle down process. As a result, if </span><i><span class=\"wysiwyg-color-black\">L</span></i><span class=\"wysiwyg-color-black\"> = O(log </span><i><span class=\"wysiwyg-color-black\">n</span></i><span class=\"wysiwyg-color-black\">) and we do O(</span><i><span class=\"wysiwyg-color-black\">L</span></i><span class=\"wysiwyg-color-black\">) comparisons for the insertion algorithm, the overall <b>pop</b> algorithm is </span><b><span class=\"wysiwyg-color-black\">O(log </span><i><span class=\"wysiwyg-color-black\">n</span></i><span class=\"wysiwyg-color-black\">)</span></b><span class=\"wysiwyg-color-black\">.\n</span>\n<br></span></p><p><b><span class=\"wysiwyg-color-red\">STOP and Think:</span></b> When trickling down, why do we have to swap with the largest child specifically?<br></p>", "subtitle_files": [], "source": null, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2017-01-05T20:09:01.128108"}