{"block": {"name": "code", "text": "<p><b><span class=\"wysiwyg-color-green\">CODE CHALLENGE:</span></b> <b>\ufeffRecursively Visiting the Nodes of a Tree</b></p><p>We have defined the following C++ class for you:</p><p></p><pre><code class=\"cpp\">class Node {\n    public:\n        string label;\n        vector&lt;Node*&gt; children;\n};</code></pre><p></p><p>The equivalent Python class is the following:</p><p></p><pre><code class=\"python\">class Node:\n    label = None\n    children = list()</code></pre><p></p><p>Write a function <span class=\"wysiwyg-font-tt\">recursivePrint(Node* node)</span> that recursively prints the labels of all nodes in the subtree rooted at <span class=\"wysiwyg-font-tt\">node</span> (in any order). For example, if we had a tree with some root node <span class=\"wysiwyg-font-tt\">root</span>, then calling <span class=\"wysiwyg-font-tt\">recursivePrint(root)</span> would print the labels of all nodes in the tree (in some arbitrary order). Print a single label per line.</p><p>The tree represented by the Sample Input has been reproduced below for clarity:</p><p><span class=\"image-wrapper\"><img src=\"https://ucarecdn.com/57f106a0-e304-4541-b6f5-68f799256dd0/\"></span></p>", "video": null, "animation": null, "options": {"limits": {"c++11": {"memory": 256, "time": 5}, "python3": {"memory": 256, "time": 15}}, "execution_memory_limit": 256, "code_templates": {"c++11": "void recursivePrint(Node* node) {\n    /* YOUR CODE HERE */\n}", "python3": "def recursivePrint(node):\n    # YOUR CODE HERE"}, "execution_time_limit": 5, "samples": [["Cherry -> Apple\nApple -> Nectarine\nApple -> Lemon\nNectarine -> Mango\nLemon -> Imbe", "Apple\nMango\nCherry\nNectarine\nImbe\nLemon"]]}, "subtitle_files": [], "source": {"execution_memory_limit": 256, "samples_count": 1, "templates_data": "::python3\n::header\nclass Node:\n    def __init__(self, label):\n        self.label = label\n        self.children = list()\n        self.parent = None\n::code\ndef recursivePrint(node):\n    # YOUR CODE HERE\n::footer\nfrom sys import stdin\nlines = stdin.read().strip().splitlines()\nlabel_to_node = {}\nfor line in lines:\n    u,v = line.split(' -> ')\n    if u not in label_to_node:\n        label_to_node[u] = Node(u)\n    u = label_to_node[u]\n    if v not in label_to_node:\n        label_to_node[v] = Node(v)\n    v = label_to_node[v]\n    u.children.append(v)\n    v.parent = u\nroot = None\nfor node in label_to_node.values():\n    if node.parent is None:\n        root = node; break\nrecursivePrint(root)\n\n::c++11\n::header\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <unordered_map>\n#include <string>\nusing namespace std;\n\nclass Node {\n    public:\n        string label;\n        vector<Node*> children;\n        Node(string l);\n};\nNode::Node(string  l) {\n    label = l;\n}\n\n::code\nvoid recursivePrint(Node* node) {\n    /* YOUR CODE HERE */\n}\n\n::footer\nint main() {\n    unordered_map<string,Node*> nodes;\n    Node* root = NULL;\n    string line;\n    string parent;\n    string dummy;\n    string child;\n    while(getline(cin,line)) {\n        stringstream ss(line);\n        ss >> parent;\n        ss >> dummy;\n        ss >> child;\n        if(nodes.count(parent) == 0) {\n            nodes[parent] = new Node(parent);\n        }\n        if(nodes.count(child) == 0) {\n            nodes[child] = new Node(child);\n        }\n        nodes[parent]->children.push_back(nodes[child]);\n        if(root == NULL) {\n            root = nodes[parent];\n        }\n    }\n    recursivePrint(root);\n    return 0;\n}", "manual_memory_limits": [], "manual_time_limits": [], "is_memory_limit_scaled": true, "code": "#This is sample code challenge\nimport random\n\ndef generate():\n    tests = [\n             \"Cherry -> Apple\\nApple -> Nectarine\\nApple -> Lemon\\nNectarine -> Mango\\nLemon -> Imbe\",\n             \"1 -> 2\\n1 -> 3\\n1 -> 4\\n2 -> 5\\n3 -> 6\\n3 -> 7\\n7 -> 8\"\n             ]\n    return tests\n\n\ndef solve(dataset):\n    labels = set()\n    for line in dataset.splitlines():\n        u,v = line.split(' -> ')\n        labels.add(u)\n        labels.add(v)\n    return '\\n'.join([label for label in labels])\n\n\ndef check(reply, clue):\n    return sorted(reply.splitlines()) == sorted(clue.splitlines())", "test_archive": [], "is_time_limit_scaled": true, "execution_time_limit": 5}, "subtitles": {}, "tests_archive": "/api/step-sources/110126/tests", "feedback_correct": "", "feedback_wrong": ""}, "id": "110126", "time": "2017-11-07T22:19:29.416016"}