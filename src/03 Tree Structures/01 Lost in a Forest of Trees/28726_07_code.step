{"id": "110126", "block": {"feedback_correct": "", "name": "code", "feedback_wrong": "", "text": "<p><b><span class=\"wysiwyg-color-green\">CODE CHALLENGE:</span></b>\u00a0<b>\ufeffRecursively Visiting the Nodes of a Tree</b></p><p>We have defined the following C++ class for you:</p><p></p><pre><code class=\"cpp\">class Node {\n    public:\n        string label;\n        vector&lt;Node*&gt; children;\n};</code></pre><br><p></p><p>Write a function <span class=\"wysiwyg-font-tt\">recursivePrint(Node* node)</span> that recursively prints the labels of all nodes in the subtree rooted at <span class=\"wysiwyg-font-tt\">node</span> (in any order). For example, if we had a tree with some root node <span class=\"wysiwyg-font-tt\">root</span>, then calling <span class=\"wysiwyg-font-tt\">recursivePrint(root)</span> would print the labels of all nodes in the tree (in some arbitrary order). Print a single label per line.</p><p>The tree represented by the Sample Input has been reproduced below for clarity:</p><p><span class=\"image-wrapper\"><img src=\"https://ucarecdn.com/57f106a0-e304-4541-b6f5-68f799256dd0/\"></span></p>", "subtitle_files": [], "source": {"execution_time_limit": 5, "code": "#This is sample code challenge\nimport random\n\ndef generate():\n    tests = [\n             \"Cherry -> Apple\\nApple -> Nectarine\\nApple -> Lemon\\nNectarine -> Mango\\nLemon -> Imbe\",\n             \"1 -> 2\\n1 -> 3\\n1 -> 4\\n2 -> 5\\n3 -> 6\\n3 -> 7\\n7 -> 8\"\n             ]\n    return tests\n\n\ndef solve(dataset):\n    labels = set()\n    for line in dataset.splitlines():\n        u,v = line.split(' -> ')\n        labels.add(u)\n        labels.add(v)\n    return '\\n'.join([label for label in labels])\n\n\ndef check(reply, clue):\n    return sorted(reply.splitlines()) == sorted(clue.splitlines())", "samples_count": 1, "execution_memory_limit": 256, "manual_memory_limits": [], "templates_data": "::c++11\n::header\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <unordered_map>\n#include <string>\nusing namespace std;\n\nclass Node {\n    public:\n        string label;\n        vector<Node*> children;\n        Node(string l);\n};\nNode::Node(string  l) {\n    label = l;\n}\n\n::code\nvoid recursivePrint(Node* node) {\n    /* YOUR CODE HERE */\n}\n\n::footer\nint main() {\n    unordered_map<string,Node*> nodes;\n    Node* root = NULL;\n    string line;\n    string parent;\n    string dummy;\n    string child;\n    while(getline(cin,line)) {\n        stringstream ss(line);\n        ss >> parent;\n        ss >> dummy;\n        ss >> child;\n        if(nodes.count(parent) == 0) {\n            nodes[parent] = new Node(parent);\n        }\n        if(nodes.count(child) == 0) {\n            nodes[child] = new Node(child);\n        }\n        nodes[parent]->children.push_back(nodes[child]);\n        if(root == NULL) {\n            root = nodes[parent];\n        }\n    }\n    recursivePrint(root);\n    return 0;\n}", "is_memory_limit_scaled": true, "is_time_limit_scaled": true, "manual_time_limits": [], "test_archive": []}, "animation": null, "video": null, "tests_archive": "/api/step-sources/110126/tests", "options": {"execution_time_limit": 5, "samples": [["Cherry -> Apple\nApple -> Nectarine\nApple -> Lemon\nNectarine -> Mango\nLemon -> Imbe", "Lemon\nCherry\nApple\nImbe\nMango\nNectarine"]], "limits": {"c++11": {"memory": 256, "time": 5}}, "execution_memory_limit": 256, "code_templates": {"c++11": "void recursivePrint(Node* node) {\n    /* YOUR CODE HERE */\n}"}}, "subtitles": {}}, "time": "2017-01-05T20:08:46.072315"}