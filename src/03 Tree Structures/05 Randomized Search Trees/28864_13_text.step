{"block": {"name": "text", "text": "<p>Throughout this lesson, we were able to design a new data structure, the\u00a0<b><span class=\"wysiwyg-color-blue\">Randomized Search Tree</span></b>, that is able to exploit the functionality of a\u00a0<b><span class=\"wysiwyg-color-purple\">Treap</span></b> with random number generation in order to achieve the theoretical\u00a0<b>O(log\u00a0<i>n</i>) average-case time complexity</b> <i>\ufeffin practice </i>for the\u00a0<b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b> operations.</p><p>However, hopefully you noticed (either on your own, or via the trick questions we placed throughout this section) that, although we've obtained an average-case\u00a0time complexity of\n\nO(log <i>n</i>) by clever trickery, we still face our existing worst-case time complexity O(<i>n</i>). Is there any way we can be even\u00a0<i>more</i> clever and bump the worst-case time complexity down to O(log\u00a0<i>n</i>) as well? In the next section, we will discuss the first of two tree structures that actually achieves this feat: the\u00a0<b><span class=\"wysiwyg-color-purple\">AVL Tree</span></b>.</p>", "video": null, "animation": null, "options": {}, "subtitle_files": [], "source": null, "subtitles": {}, "tests_archive": null, "feedback_correct": "", "feedback_wrong": ""}, "id": "120164", "time": "2018-03-04T14:38:12.982994"}