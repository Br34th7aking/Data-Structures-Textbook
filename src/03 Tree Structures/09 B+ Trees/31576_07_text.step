{"time": "2016-09-20T20:55:40.384762", "block": {"name": "text", "subtitles": {}, "source": null, "subtitle_files": [], "feedback_wrong": "", "video": null, "animation": null, "feedback_correct": "", "tests_archive": null, "text": "<p>Below is pseudocode more formally describing the   <b><span class=\"wysiwyg-color-purple\">B+ Tree</span></b> insertion algorithm. Note that the real code to implement insert is usually <i>very</i>\u00a0long because of the shuffling of keys and pointer manipulations that need to take place.</p><p></p><p></p><p></p><pre><code class=\"cpp\"><b>insert(&lt;key,dataRecord&gt;): // return true upon success</b>\n\n    // check for duplicate insertion (not allowed)\n    if dataRecord is already in tree:\n        return false\n    \n    node = the leaf node into which dataRecord must be inserted\n    insert &lt;key,dataRecord&gt; into node (maintain sorted order) and allocate space for children\n  \n    // while the node is too large, grow the tree\n    if node.size &gt; <b>L</b>:\n        left,right = result of splitting node in half (if odd number, make right node take extra dataRecord)\n        parent = parent of node\n        <b>duplicate</b> smallest key from right and insert into parent (maintain sorted order)\n        make left and right new children of parent\n        node = parent\n\n        while node.size &gt; <b>M-1</b>:\n            left,right = result of splitting node in half (if odd number, make right node take extra key)\n            parent = parent of node\n            <b>remove</b> smallest key from right and insert into parent (maintain sorted order)\n            make left and right new children of parent\n            node = parent \n\n    return true</code></pre><p></p><p><b></b></p><p></p><p><b><b><span class=\"wysiwyg-color-red\">Note</span></b><span class=\"wysiwyg-color-red\">: </span></b><span class=\"wysiwyg-color-black\">We pass in a (<i>key</i>, <i>data record</i>) pair into the insert method in order to provide our <b> </b></span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-purple\">B+ Tree</span></b></span> <i><span class=\"wysiwyg-color-black\">both</span></i><span class=\"wysiwyg-color-black\"> a <i>means of sorting</i> the data record (the key) <i>and</i> the <i>data record itself</i>. </span><b></b></p><b></b><p></p><p><b><span class=\"wysiwyg-color-red\">Note: </span></b><span class=\"wysiwyg-color-red\"><span class=\"wysiwyg-color-black\">Duplicates of a data record are not allowed. <i>However</i>, different data records <i>can</i> share the same key. If different data records happen to share the same key, we can create a Linked List at the location of the previous key and append the new data record to that Linked List. Do not worry if this doesn't make much sense to you; we will explore this concept in more depth when we discuss Separate Chaining in the Hashing chapter. Consequently, for our current purposes, we will assume that all keys inserted into a <b><span class=\"wysiwyg-color-purple\">B+ Tree</span></b> are unique. </span></span><br></p><p>What is the worst-case time complexity for a    <b><span class=\"wysiwyg-color-purple\">B+ Tree</span></b> insert operation?</p><p>Hopefully it is intuitive to you that the    <b><span class=\"wysiwyg-color-purple\">B+ Tree</span></b> insertion algorithm has the same worst-case time complexity as a  <b><span class=\"wysiwyg-color-green\">B-Tree</span></b> insert operation because, in both cases, we need to potentially traverse the entire height of the tree and reshuffle data records/keys at each level to maintain the sorted property. However, because a     <b><span class=\"wysiwyg-color-purple\">B+ Tree</span></b> is expressed in terms of the variables <i>M </i>and <i>L </i> (<i>not</i> <i>b</i>), the worst-case time complexity for a     <b><span class=\"wysiwyg-color-purple\">B+ Tree</span></b><span class=\"wysiwyg-color-purple\"><span class=\"wysiwyg-color-black\">\u00a0insertion becomes $ O(M\\log_{M}{n}+L) $.\u00a0Why? I<span class=\"wysiwyg-color-black\">n the worst case, we need to traverse over each of the\u00a0<i>M</i>\u00a0keys in an internal node</span><span class=\"wysiwyg-color-black\">, each of the\u00a0<i>L</i>\u00a0data records in a leaf node,\u00a0</span><span class=\"wysiwyg-color-black\">and</span> each of the $O(log_{M}n)$\u00a0levels of the tree.</span></span></p><p><span class=\"wysiwyg-color-purple\"><span class=\"wysiwyg-color-black\">The worst-case time complexity <i>with regards to memory accesses</i> is also $ O(M\\log_{M}{n}+L) $.</span></span></p><div><div><p></p></div></div>", "options": {}}, "id": "124452"}