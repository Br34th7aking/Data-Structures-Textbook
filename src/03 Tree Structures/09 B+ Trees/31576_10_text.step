{"id": "124455", "block": {"feedback_correct": "", "name": "text", "feedback_wrong": "", "text": "<p>It should also hopefully be intuitive that finding a key in a<span class=\"wysiwyg-color-purple\">\u00a0</span><b><span class=\"wysiwyg-color-purple\">B+ Tree</span></b> is practically identical to a <b><span class=\"wysiwyg-color-green\">B-Tree</span></b>'s find algorithm! Below is pseudocode describing the find algorithm, and we would call this recursive function by passing in the root of the <b><span class=\"wysiwyg-color-purple\">B+ Tree</span></b>:</p><p></p><pre><code class=\"cpp\"><b>find(&lt;key,dataRecord&gt;, node): // return true upon success\n</b>\n    if node is empty:\n        return false\n\n    if node is leaf and dataRecord is in node: // find via binary search\n        return true           \n\n    // if key is smaller than smallest element in node, go to left child\n    if key is smaller than node[0]:\n\n        if node[0] has leftChild:\n            return(&lt;key,dataRecord&gt;, node[0].leftChild)\n\n        //else there is no way the dataRecord can be in the tree\n        else:  \n            return false\n\n    nextNode = largest element of node that is smaller than or equal to the key // find via binary search\n\n    if nextNode has rightChild:\n        return(&lt;key,dataRecord&gt;, node[0].rightChild)\n\n    //else there is no way the dataRecord can be in the tree\n    else:\n        return false</code></pre><p></p><p><b><span class=\"wysiwyg-color-red\">STOP and Think: </span></b>Why do we pass in <i>both</i> the key <i>and</i> the data record as a pair? In other words, why couldn't we just search for the data record by itself?<br></p><p>What is the worst-case time complexity of the find operation of a <b><span class=\"wysiwyg-color-purple\">B+ Tree</span></b>? Considering that the algorithm above is practically identical to the <b><span class=\"wysiwyg-color-green\">B-Tree</span></b> find algorithm, it should hopefully be intuitive that the time complexity will be very similar. In the worst case, we have to traverse the entire height of the balanced tree, which is\u00a0$O(\\log_{M}{n}) $. Within each internal <i>key</i> node, we can do a binary search to find the element, which is\u00a0$ O(\\log_{2}{M}) $. Within each <i>leaf</i> node, we can do a binary search to find the element, which is\u00a0$ O(\\log_{2}{L}) $. Thus, the worst-case time complexity to find an element simplifies to\u00a0$ O(\\log_{2}{n} + \\log_{2}{L}) $. <br></p><p>However, what is the worst-case time complexity of the find operation<i> with respect to memory access</i>? At each level of the tree <i>except</i> the leaves, we need to read in the entire node of size O(<i>M</i>). At the level of the leaves, we need to read in the entire node of size O(<i>L</i>). Consequently, the worst-case time to find an element <i>with respect to memory access</i>\ufeff\u00a0is $ O( M\\log_{M}{n} + L) $.<i></i></p><p></p>", "subtitle_files": [], "source": null, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2017-02-14T23:16:41.544464"}