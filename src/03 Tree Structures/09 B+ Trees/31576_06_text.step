{"block": {"name": "text", "text": "<p>Since we have already practiced using a very similar <b><span class=\"wysiwyg-color-green\">B-Tree</span></b> insert operation  with a good number of fairly simple trees in the previous lesson, let's skip ahead and try a slightly more complicated <b><span class=\"wysiwyg-color-purple\">B+ Tree</span></b> structure, in which <i>M</i> = 3 and <i>L</i> = 3:</p><p><span class=\"image-wrapper\"><img height=\"163\" alt=\"\" width=\"532\" src=\"https://ucarecdn.com/9489d511-8a1e-48cc-9f3a-699d35feee0b/\"></span></p><p>What happens when we attempt to insert the data record 57?</p><p><span class=\"image-wrapper\"><img height=\"182\" alt=\"\" width=\"575\" src=\"https://ucarecdn.com/20970bb2-212c-4c8f-a462-c7be3dbec5bf/\"></span></p><p>Note how no adjustments need to be made (because no <i>data record</i> nodes nor\u00a0<i>key</i> nodes face an overflow) and data record 57 can be safely inserted. Does the same thing happen if we attempt to insert data record 1 into the root's left subtree?</p><p><span class=\"image-wrapper\"><img height=\"315\" alt=\"\" width=\"570\" src=\"https://ucarecdn.com/73d171d2-f7fd-406f-a192-ccf2fd1e3434/\"></span><span class=\"image-wrapper\"><img height=\"167\" alt=\"\" width=\"570\" src=\"https://ucarecdn.com/5dafc87e-3261-42a1-88df-c42b60aee527/\"></span></p><p>Because the inserting leaf node faced an overflow of data records, we had to resort to growing a new key node. What happens when we attempt to insert data record 24 into the root's right subtree?</p><p><span class=\"image-wrapper\"><img height=\"203\" alt=\"\" width=\"588\" src=\"https://ucarecdn.com/46232fe8-5f2c-4d03-ae0e-fdd49baae0e8/\"></span><span class=\"image-wrapper\"><img height=\"180\" alt=\"\" width=\"594\" src=\"https://ucarecdn.com/04093904-3c3b-4200-80ca-cf9f3e17a2bc/\"></span><span class=\"image-wrapper\"><img height=\"176\" alt=\"\" width=\"598\" src=\"https://ucarecdn.com/62c1620c-b597-427e-8262-13a12cd50a1d/\"></span><span class=\"image-wrapper\"><img height=\"177\" alt=\"\" width=\"596\" src=\"https://ucarecdn.com/fe7b4c02-f22f-4259-9333-3a5950355658/\"></span><span class=\"image-wrapper\"><img height=\"186\" alt=\"\" width=\"602\" src=\"https://ucarecdn.com/2719fd43-289a-41ea-a149-cad686b61e7c/\"></span><span class=\"image-wrapper\"><img height=\"198\" alt=\"\" width=\"610\" src=\"https://ucarecdn.com/01bff600-0af8-4e6e-8686-ca48a757ee28/\"></span></p><p><b><span class=\"wysiwyg-color-red\">Note:</span> </b>When growing upward directly from the leaves, we grow a <i>key\u00a0</i>(i.e., we do not move the actual data record up a level)! For example, \nwhen \"cutting\" data record 24, a duplicate 24 appeared in the tree (i.e., the key). However, when growing upward from an internal node (i.e., a key), \nwe do actually cut the key itself and move it up a level (i.e., a duplicate does not appear). For example, when \"cutting\" key 42, we actually \nmoved the key itself up to the root.</p><p>Thus, we end up with this monstrosity below. Pay attention to how property 7\u2014\"Smallest data record between search keys<i> x</i> and<i> y </i>equals <i>x</i>\"\u2014still holds after all the insertions we have made:</p><div><span class=\"image-wrapper\"><img height=\"189\" alt=\"\" width=\"550\" title=\"Image: https://ucarecdn.com/36b40a33-ae8a-4635-9bab-0b8f15aea454/\" src=\"https://ucarecdn.com/36b40a33-ae8a-4635-9bab-0b8f15aea454/\"></span><p></p></div>", "video": null, "animation": null, "options": {}, "subtitle_files": [], "source": null, "subtitles": {}, "tests_archive": null, "feedback_correct": "", "feedback_wrong": ""}, "id": "124402", "time": "2017-11-07T22:21:22.486115"}