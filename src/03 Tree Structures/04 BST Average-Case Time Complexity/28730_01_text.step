{"time": "2016-09-20T20:54:26.326041", "block": {"name": "text", "subtitles": {}, "source": null, "subtitle_files": [], "feedback_wrong": "", "video": null, "animation": null, "feedback_correct": "", "tests_archive": null, "text": "<p>\n\nAs we mentioned previously, the worst-case time complexity of a <b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b> is quite poor (linear time), but when the <b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b> is well-balanced, the time complexity becomes quite good (logarithmic time). On average, what do we expect to see?<br></p><p>Notice that we can define a <b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b> by the insertion order of its elements. If we were to look at all possible <b><span class=\"wysiwyg-color-green\">BSTs</span></b> with <i>n</i> elements, or equivalently, look at all possible insertion orders, it turns out that the average-case time complexity of a successful \"find\" operation in a binary search tree with <i>n</i> elements\u00a0is actually <b>O(log <i>n</i>)</b>. So how can we prove it? To do so (with a formal mathematical proof), we will make two assumptions:</p><p></p><ol><li><b>All\u00a0</b><i><b>n</b></i><b> elements are equally likely to be searched for</b></li><li><b>All\u00a0</b><i><b>n</b></i><b>! possible insertion orders are equally likely</b></li></ol><p></p>", "options": {}}, "id": "110136"}