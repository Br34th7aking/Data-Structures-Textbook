{"id": "122901", "block": {"feedback_correct": "", "name": "text", "feedback_wrong": "", "text": "<p>In the next two cases of the delete operation, we now face the problem of violating<b> </b>the <i>\"a non-leaf node with <i>k</i> children contains <i>k</i>\u22121 keys\"\u00a0</i>property (i.e., we face an \"underflow\") and thus have to restructure the tree to avoid the violation. In other words, we can't just get rid of the \"slot\" as we did in the previous cases because that would lead to an internal node without enough children. In both of the following cases, we restructure the tree by taking a key from the parent node. However, the difference between the following two cases is determined by whether we also <i><b>take</b></i> a key from the immediate sibling or <i><b>merge</b></i> with a key from the immediate sibling.</p><p><b>Case 3: Delete leaf-key \u2014 underflow, and \"rich\nsibling\"</b></p><p><img height=\"260\" width=\"460\" alt=\"\" src=\"https://ucarecdn.com/0889ab24-0c09-417c-bb5b-747c5a1a20ba/\"></p><p><img height=\"214\" width=\"469\" alt=\"\" src=\"https://ucarecdn.com/e28d04dd-a33b-40fa-8387-a887af07a854/\"></p><p>Note that, in the case above, the sibling was \"rich\" enough to provide a key to the parent in order for the parent to be able to give a key to the empty node.</p><p><b><span class=\"wysiwyg-color-red\">STOP and Think:</span></b> Why is it not okay to just move the sibling's largest key to the empty node (i.e., what becomes violated)?</p><p>But what happens if the empty node doesn't have an immediate sibling that can provide a key without causing more underflow?</p><p><b>Case 4: Delete leaf-key \u2014 underflow, and \"poor\nsibling\"</b></p><p><img height=\"220\" width=\"458\" alt=\"\" src=\"https://ucarecdn.com/8686292f-18de-4135-96bb-41b49d6d8b8d/\"></p><p><img height=\"203\" width=\"449\" alt=\"\" src=\"https://ucarecdn.com/fbae87f7-72fc-498a-a1f2-dc2dd0a59844/\"></p><p>What is the worst-case time complexity of the delete operation for a <b><span class=\"wysiwyg-color-green\">B-Tree</span></b>? It turns out that it is the same as the insert operation, O($ b*log_{b} n $ <span class=\"wysiwyg-color-black\">). Why? In the worst case, we need to traverse over all the keys in a node ( O(<i>b</i>) ) </span>in all levels of the tree ( O($ log_{b} n $), similarly to insert.</p><p><b><span class=\"wysiwyg-color-red\">Note:</span></b> Some programmers choose to voluntarily violate the \"underflow\" conditions described above in order to simplify the deletion process. However, by doing so, we risk having a taller tree than necessary, thereby making it less efficient. Also note that the real code to implement the delete operation is <i>extremely</i> long (much longer than the code to implement the insert operation) because of the excessive shuffling of keys and pointer manipulation that needs to take place.</p>", "subtitle_files": [], "source": null, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2017-01-05T20:10:17.626031"}