{"block": {"name": "text", "text": "<p>How can we take advantage of the information we just learned about spatial locality of memory to not just have a tree structure be fast <i>theoretically,</i> but also be fast <i>in practice</i>? The answer is to minimize the amount of node traversals we have to do to \nfind data (i.e., make the trees as short as possible) <b>and</b> store as much data as possible close together (i.e., have each node store multiple keys). Why? By minimizing the amount of node traversals, we minimize the risk of having to access a section of memory \nthat takes longer to access<b>. </b>By having a node store multiple keys, we are able to trick the CPU into loading more than one key at once into a fast section of memory (the L1 cache), thereby making it faster to find another key within the same node because it will already be in the L1 cache (as opposed to somewhere else in Main Memory).</p><p>The data structure that does the above is called a <b><span class=\"wysiwyg-color-green\">B-Tree</span></b>. A <b><span class=\"wysiwyg-color-green\">B-Tree</span></b> is a self-balancing tree data structure that generally allows for a node to have more than two children (to keep the tree wide and therefore from growing in height) and keeps multiple inserted keys in one node. We usually define a <b><span class=\"wysiwyg-color-green\">B-Tree</span></b> to have \"order <i>b</i>,\" where <i>b</i> is the minimum number of children any node is allowed to have and 2<i>b</i> is the maximum number of children any node is allowed to have. Below is an example of a  <b><span class=\"wysiwyg-color-green\">B-Tree</span></b> with <i>b</i> = 2:</p><p><span class=\"image-wrapper\"><img height=\"185\" title=\"Image: https://ucarecdn.com/16dad929-3cf5-43f7-abd8-23d3fed13dcc/\" width=\"449\" alt=\"\" src=\"https://ucarecdn.com/16dad929-3cf5-43f7-abd8-23d3fed13dcc/\"></span></p><p>In the <b><span class=\"wysiwyg-color-green\">B-Tree</span></b> above, each integer is considered a separate key (i.e., each integer would have had its own node in a BST). Also, just like in other trees, every key in the left subtree is smaller than the current key and every key in the right subtree is greater (e.g. starting at key 7, keys 2, 3, and 6 are all smaller and key 13 is greater). Also note that, since the maximum number of children is 2*2 = 4, a node can therefore only store up to 3 keys (because pointers to children are stored <i>in between</i> keys and on the edges). More generally, we say that a node can store up to 2<i>b</i>\u20131 keys.</p><p>Formally, we define a <b><span class=\"wysiwyg-color-green\">B-Tree</span></b> of order <i>b</i> to be a tree that satisfies these properties: <br></p><ol>\n<li>Every node has at most 2<i>b</i> children.</li>\n<li>Every internal node (except root) has at least <i>b</i> children.</li>\n<li>The root has at least two children if it is not a leaf node.</li>\n<li>An internal node with <i>k</i> children contains <i>k</i>\u20131 keys.</li><li><b>All leaves appear in the same level. </b><span>(We will later see how this is enforced during the insert operation)</span><br></li></ol>", "video": null, "animation": null, "options": {}, "subtitle_files": [], "source": null, "subtitles": {}, "tests_archive": null, "feedback_correct": "", "feedback_wrong": ""}, "id": "122787", "time": "2017-09-11T11:47:24.280228"}