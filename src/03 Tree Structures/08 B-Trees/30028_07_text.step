{"block": {"name": "text", "text": "<p>Below is pseudocode more formally describing the\u00a0<b><span class=\"wysiwyg-color-green\">B-Tree</span></b> insertion algorithm. Note that the real code to implement insert is usually <i>very</i>\u00a0long because of the shuffling of keys and pointer manipulations that need to take place.</p><p></p><pre><code class=\"cpp\"><b>insert(key): // return true upon success</b>\n\n    // check for duplicate insertion (not allowed)\n    if key is already in tree:\n        return false\n    \n    node = the leaf node into which key must be inserted\n    insert key into node (maintain sorted order) and allocate space for children\n  \n    // while the extra key doesn't fit in the node, grow the tree\n    while node.size &gt; 2*b:\n        left,right = result of splitting node in half\n        parent = parent of node\n        remove largest key from left and insert into parent (maintain sorted order)\n        make left and right new children of parent\n        node = parent \n\n    return true</code></pre><p></p><p>What is the worst-case time complexity for a <b><span class=\"wysiwyg-color-green\">B-Tree</span></b> insert operation? <br></p><p>Well, in each insertion, we traverse the entire height of the tree to insert the key in one of the leaves, which is $ O(log_{b} n )$. Worst-case scenario, during insertion, we need to re-sort the keys within each node to make sure the ordering property is kept; this is a $ O(b)$ operation. We also need to keep in mind that in the worst case, the inserting node overflows and we therefore need to traverse all the way back up the tree to fix the overflowing nodes and re-assign pointers; this is a $ O(log_{b} n\u00a0)\u00a0$ operation. Consequently, the worst-case time complexity for  a <b><span class=\"wysiwyg-color-green\">B-Tree</span></b> insert operation simplifies to $ O(b\\ log_{b} n) $. <br></p><p>Also, since we have been analyzing the performance of a\u00a0 <b><span class=\"wysiwyg-color-green\">B-Tree</span></b> with respect to memory, we will also choose to analyze\u00a0the worst-case time complexity with respect to memory (i.e., how much memory does the CPU need to access in order to insert a key). In the worst case, for each node, we need to read all the keys the node contains. Because the maximum number of keys we can store in a node is<i> </i>2<i>b</i>\u20131, the number of keys the CPU needs to read in a node becomes $ O(b) $. As mentioned before, the tree has a depth of\u00a0$O(\\log_{b}{n})$, making the <i>overall</i> worst-case time complexity become\u00a0$ O(b \\log_{b}{n})\u00a0 $.</p>", "video": null, "animation": null, "options": {}, "subtitle_files": [], "source": null, "subtitles": {}, "tests_archive": null, "feedback_correct": "", "feedback_wrong": ""}, "id": "122876", "time": "2017-11-07T22:21:08.552346"}