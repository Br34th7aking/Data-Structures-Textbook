{"block": {"name": "text", "text": "<p>How do we delete a key from a <b><span class=\"wysiwyg-color-green\">B-Tree</span></b>? If we're lazy and don't care about memory management, then we can do a \"lazy deletion\" in which we just mark the key as \"deleted\" and just make sure that we check whether a key is marked as deleted or not in the find operation. However, the whole motivation behind <b><span class=\"wysiwyg-color-green\">B-Trees</span></b> is to gain fast access to elements, partly by minimizing node traversals. Thus, if we start piling up \"deleted keys,\" our nodes will fill up much more quickly and we will have to create unnecessary new levels of nodes. By repeatedly doing so, our find and insert operations will take longer (because the height of our tree will be larger), meaning we will essentially lose the efficiency we just spent so much time trying to obtain via clever design. Consequently, most programmers choose to invest their time into implementing a more <i>proper</i> delete method.</p><p>How do we implement a <i>proper</i> delete method?</p><p>The delete operation has 4 different cases we need to consider:</p><ol><li>Delete leaf-key \u2014 no underflow</li><li>Delete non-leaf key \u2014 no underflow</li><li>Delete leaf-key \u2014\u00a0underflow, and \"rich sibling\" <br></li><li>Delete leaf-key \u2014\u00a0underflow, and \"poor sibling\"</li></ol> <b><span class=\"wysiwyg-color-red\">Note: </span></b>'Underflow' is defined as the violation of the <i>\"a non-leaf node with <i>k</i> children contains <i>k</i>\u22121 keys\"</i> property.<br><br><p>Let's start with the easiest example, <b>Case 1: Delete a key at a leaf \u2013 no underflow</b>. Within this first case, no properties are violated if we just remove the key:<br><img height=\"275\" width=\"465\" alt=\"\" src=\"https://ucarecdn.com/e6adb0c8-1f8b-4986-8416-acc52f752fad/\"><br><b>Case 2: Delete non-leaf key \u2013 no underflow.\u00a0</b>Within this second case, we face the problem of re-assigning empty key \"slots\" because there are pointers to leaves that need to be kept (this is different than in case 1 where we just deleted the key \"slot\").<br><br><img height=\"281\" width=\"478\" alt=\"\" src=\"https://ucarecdn.com/3aea775a-4745-4727-9988-e1eb2cbc8880/\"><br><img height=\"156\" width=\"493\" alt=\"\" src=\"https://ucarecdn.com/696e6665-d300-4b44-a633-a98aada42993/\"><br>When filling the empty key, we have two different options for choosing which key we want to use as a replacement:<br></p><ol><li>The largest key from the left subtree</li><li>The smallest key from the right subtree</li></ol><p><b><span class=\"wysiwyg-color-red\">Note: </span></b><span class=\"wysiwyg-color-red\"><span class=\"wysiwyg-color-black\">If the node from which we took a key now also has an empty \"slot\" that needs to be filled (i.e., it wasn't a leaf), just repeat the same steps above recursively until we hit a leaf node!</span></span></p>", "video": null, "animation": null, "options": {}, "subtitle_files": [], "source": null, "subtitles": {}, "tests_archive": null, "feedback_correct": "", "feedback_wrong": ""}, "id": "122897", "time": "2017-09-11T11:47:29.295163"}