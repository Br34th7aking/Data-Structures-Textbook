{"block": {"name": "text", "text": "<p>We have formally proven that, given an\u00a0<b><span class=\"wysiwyg-color-purple\">AVL Tree</span></b>, the worst-case time complexity for finding, inserting, or removing an element is O(log\u00a0<i>n</i>) because the height of the tree is at worst O(log\u00a0<i>n</i>). Now, let's discuss the algorithms for these three operations that are able to\u00a0<i>maintain</i> the\u00a0<b><span class=\"wysiwyg-color-purple\">AVL Tree</span></b> properties without worsening the time complexity.</p><p>Finding an element in an\u00a0<b><span class=\"wysiwyg-color-purple\">AVL Tree</span></b> is trivial: it is simply the\u00a0<b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b> \"find\" algorithm, which was discussed in detail in the\u00a0<b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b> section of this text.</p><p>Before discussing the insertion and removal algorithms of an\u00a0<b><span class=\"wysiwyg-color-purple\">AVL Tree</span></b>, we want to first refresh your memory with regard to a fundamental operation known as the\u00a0<b>AVL Rotation</b>. AVL rotations were introduced previously in the\u00a0<b><span class=\"wysiwyg-color-blue\">Randomized Search Tree</span></b> section of this text, but since they are somewhat non-trivial and are so important to\u00a0<b><span class=\"wysiwyg-color-purple\">AVL Trees</span></b> (hence the name \"AVL\" rotation), we thought it would be best to review them.</p><p>Recall that\u00a0<b>AVL Rotations</b> can be done in two directions: <b>right</b> or <b>left</b>. Below is a diagram generalizing both right and left AVL Rotations. In the diagram, the triangles represent arbitrary subtrees of any shape: they can be empty, small, large, etc. The circles are the \"important\" nodes upon which we are performing the rotation.</p><p><span class=\"image-wrapper\"><img src=\"https://ucarecdn.com/b914f856-4d54-4cc1-91f6-4a603a18802f/\" title=\"Image: https://ucarecdn.com/b914f856-4d54-4cc1-91f6-4a603a18802f/\" alt=\"\"></span></p><p><br></p><p>Note that the <i>y</i> subtree\u00a0<i>was</i> the right child of node\u00a0<i>a</i>\ufeff but now becomes the <i>left</i> child of node <i>b</i>!\u00a0<span>Formally, we can describe </span><b>AVL Rotations</b><span> with the following pseudocode:</span></p><p></p><pre><code class=\"no-highlight\"><b>AVLRight(<i>b</i>): // Perform a right AVL rotation on node <i>b</i></b>\n    <i>a</i> = left child of <i>b</i>\n    <i>y</i> = right child of <i>a</i> (or NULL if <i>a</i> does not have a right child)\n    <i>p</i> = parent of <i>b</i> (or NULL if <i>b</i> does not have a parent)\n    if <i>p</i> is not NULL and <i>b</i> is the right child of <i>p</i>:\n        make <i>a</i> the right child of <i>p</i>\n    otherwise, if <i>p</i> is not NULL and <i>b</i> is the left child of <i>p</i>:\n        make <i>a</i> the left child of <i>p</i>\n    make <i>y</i> the left child of <i>b</i>\n    make <i>b</i> the right child of <i>a</i>\n\n<b>AVLLeft(<i>a</i>): // Perform a left AVL rotation on node <i>a</i></b>\n    <i>b</i> = right child of <i>a</i>\n    <i>y</i> = left child of <i>b</i> (or NULL if <i>b</i> does not have a left child)\n    <i>p</i> = parent of <i>a</i> (or NULL if <i>a</i> does not have a parent)\n    if <i>p</i> is not NULL and <i>a</i> is the right child of <i>p</i>:\n        make <i>b</i> the right child of <i>p</i>\n    otherwise, if <i>p</i> is not NULL and <i>a</i> is the left child of <i>p</i>:\n        make <i>b</i> the left child of <i>p</i>\n    make <i>y</i> the right child of <i>a</i>\n    make <i>a</i> the left child of <i>b</i></code></pre>", "video": null, "animation": null, "options": {}, "subtitle_files": [], "source": null, "subtitles": {}, "tests_archive": null, "feedback_correct": "", "feedback_wrong": ""}, "id": "120394", "time": "2018-03-04T14:38:18.149496"}