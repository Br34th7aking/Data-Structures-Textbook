{"block": {"name": "code", "text": "<p><b><span class=\"wysiwyg-color-green\">CODE CHALLENGE:</span></b> <b>Printing the Elements of a Binary Search Tree in Sorted Order</b></p><p>We have defined the following C++ class for you:</p><p></p><pre><code class=\"cpp\">class Node {\n    public:\n        string label;\n        Node* leftChild = NULL;\n        Node* rightChild = NULL;\n};</code></pre><p></p><p>The equivalent Python class is the following:</p><p></p><pre><code class=\"python\">class Node:\n    label = None\n    leftChild = None\n    rightChild = None</code></pre><p></p><p>Write a function <span class=\"wysiwyg-font-tt\">sortedPrint(Node* node)</span> that recursively prints the labels of all nodes in the subtree rooted at <span class=\"wysiwyg-font-tt\">node</span> in ascending sorted order. For example, if we had a tree with some root node <span class=\"wysiwyg-font-tt\">root</span>, then calling <span class=\"wysiwyg-font-tt\">sortedPrint(root)</span> would print the labels of all nodes in the tree in ascending sorted order. Print a single label per line. You can assume that the <b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b> structure is valid (i.e., all nodes are larger than all of their descendants in their left subtree and smaller than all of their descendants in their right subtree).</p><p><b><span class=\"wysiwyg-color-red\">HINT:</span></b> Judging by the structure of a <b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b>, does one of the rooted binary tree traversal algorithms (<b><span class=\"wysiwyg-color-green\">pre-order</span></b>, <b><span class=\"wysiwyg-color-blue\">in-order</span></b>, and <b><span class=\"wysiwyg-color-purple\">post-order</span></b>) seem useful in this context?</p><p><b><span class=\"wysiwyg-color-red\">HINT:</span></b> What happens if one of the two child pointers is <span class=\"wysiwyg-font-tt\">NULL</span>?</p><p>The tree represented by the Sample Input has been reproduced below for clarity:</p><p><img title=\"Image: https://ucarecdn.com/8a4b907c-fc2f-4a20-a079-7fe305156a7f/\" src=\"https://ucarecdn.com/8a4b907c-fc2f-4a20-a079-7fe305156a7f/\" alt=\"\"></p>", "video": null, "animation": null, "options": {"limits": {"c++11": {"memory": 256, "time": 5}, "python3": {"memory": 256, "time": 15}}, "execution_memory_limit": 256, "code_templates": {"c++11": "void sortedPrint(Node* node) {\n    /* YOUR CODE HERE */\n}", "python3": "def sortedPrint(node):\n    # YOUR CODE HERE"}, "execution_time_limit": 5, "samples": [["Cherry -> Apple\nCherry -> Lemon\nLemon -> Imbe\nLemon -> Nectarine\nNectarine -> Mango", "Apple\nCherry\nImbe\nLemon\nMango\nNectarine"]]}, "subtitle_files": [], "source": {"execution_memory_limit": 256, "samples_count": 1, "templates_data": "::python3\n::header\nclass Node:\n    def __init__(self, label):\n        self.label = label\n        self.left = None\n        self.right = None\n        self.parent = None\n::code\ndef sortedPrint(node):\n    # YOUR CODE HERE\n::footer\nfrom sys import stdin\nlines = stdin.read().strip().splitlines()\nlabel_to_node = {}\nfor line in lines:\n    u,v = line.split(' -> ')\n    if u not in label_to_node:\n        label_to_node[u] = Node(u)\n    u = label_to_node[u]\n    if v not in label_to_node:\n        label_to_node[v] = Node(v)\n    v = label_to_node[v]\n    if u.left is None:\n        u.left = v\n    else:\n        u.right = v\n    v.parent = u\nroot = None\nfor node in label_to_node.values():\n    if node.parent is None:\n        root = node; break\nsortedPrint(root)\n\n::c++11\n::header\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <string>\nusing namespace std;\n\nclass Node {\n    public:\n        string label;\n        Node* leftChild = NULL;\n        Node* rightChild = NULL;\n        Node(string l);\n};\nNode::Node(string  l) {\n    label = l;\n}\n\n::code\nvoid sortedPrint(Node* node) {\n    /* YOUR CODE HERE */\n}\n\n::footer\nint main() {\n    unordered_map<string,Node*> nodes;\n    unordered_set<string> hasParent;\n    Node* root = NULL;\n    string line;\n    string parent;\n    string dummy;\n    string child;\n    while(getline(cin,line)) {\n        stringstream ss(line);\n        ss >> parent;\n        ss >> dummy;\n        ss >> child;\n        if(nodes.count(parent) == 0) {\n            nodes[parent] = new Node(parent);\n        }\n        if(nodes.count(child) == 0) {\n            nodes[child] = new Node(child);\n        }\n        if(child < parent) {\n            nodes[parent]->leftChild = nodes[child];\n        }\n        else {\n            nodes[parent]->rightChild = nodes[child];\n        }\n        hasParent.insert(child);\n    }\n    for(auto element : nodes) {\n        if(hasParent.count(element.first) == 0) {\n            root = nodes[element.first];\n            break;\n        }\n    }\n    sortedPrint(root);\n    return 0;\n}", "manual_memory_limits": [], "manual_time_limits": [], "is_memory_limit_scaled": true, "code": "#This is sample code challenge\nimport random\n\ndef generate():\n    tests = [\n             \"Cherry -> Apple\\nCherry -> Lemon\\nLemon -> Imbe\\nLemon -> Nectarine\\nNectarine -> Mango\",\n             \"7 -> 6\\n6 -> 5\\n5 -> 4\\n4 -> 3\\n7 -> 9\\n9 -> 8\"\n             ]\n    return tests\n\n\ndef solve(dataset):\n    labels = set()\n    for line in dataset.splitlines():\n        u,v = line.split(' -> ')\n        labels.add(u)\n        labels.add(v)\n    return '\\n'.join(sorted([label for label in labels]))\n\n\ndef check(reply, clue):\n    return reply.splitlines() == clue.splitlines()", "test_archive": [], "is_time_limit_scaled": true, "execution_time_limit": 5}, "subtitles": {}, "tests_archive": "/api/step-sources/110135/tests", "feedback_correct": "", "feedback_wrong": ""}, "id": "110135", "time": "2017-11-07T22:19:56.463908"}