{"block": {"name": "text", "text": "<h1>Binary Search Trees</h1><p><b>Summary Description</b></p><ul><li>A Binary Search Tree is a binary tree\u00a0in which any given node is larger than all nodes in its left subtree and smaller than all nodes in its right subtree</li><li>A Randomized Search Tree is a Binary Search Tree + Heap (a \"Treap\") in which each node has a\u00a0<i>key</i> and a\u00a0<i>priority</i>, and the tree maintains the <i>Binary Search Tree Property</i> with respect to\u00a0<i>keys</i> and the <i>Heap Property</i> with respect to\u00a0<i>priorities</i></li><li>An AVL Tree is a self-balancing Binary Search Tree\u00a0in which, for all nodes in the tree, the <i>heights</i> of the two child subtrees of the node differ by at most one</li><li>A Red-Black Tree is a self-balancing Binary Search Tree in which all nodes must be \"colored\" either red or black, the root of the tree must be black, red nodes can only have black children, and every path from any node\u00a0<i>u</i> to a null reference\u00a0must contain the same number of black nodes</li><li>AVL Trees are stricter than Red-Black Trees in terms of balance, so AVL Trees are typically faster for find operations</li><li>Red-Black Trees only do one pass down the tree for inserting elements, whereas AVL trees need one pass down the tree and one pass back up, so Red-Black Trees are typically faster for insert operations</li></ul><p></p><p></p><p><br></p><h2>Time/Space Complexities of a Regular Binary Search Tree</h2><p><b>Worst-Case Time Complexity (Regular Binary Search Tree)</b></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(<i>n</i>)</b> \u2014 If we insert the elements in ascending/descending order, we get a Linked List</li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(<i>n</i>)</b>\u00a0\u2014 If we insert the elements in ascending/descending order, we get a Linked List<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(<i>n</i>)</b>\u00a0\u2014 If we insert the elements in ascending/descending order, we get a Linked List<br></li></ul><p><b>Average-Case Time Complexity (Regular Binary Search Tree)</b></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(log\u00a0<i>n</i>)</b>\u00a0\u2014 The formal proof is too complex for a summary slide<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(log\u00a0<i>n</i>)</b>\u00a0\u2014 Effectively the same algorithm as find, with the actual insertion being a O(1) pointer rearrangement<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(log\u00a0<i>n</i>)</b>\u00a0\u2014 The formal proof is too complex for a summary slide<br></li></ul><p><b>Best-Case Time Complexity (Regular Binary Search Tree)</b><br></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(1)</b>\u00a0\u2014 If the query is the root<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(1)</b>\u00a0\u2014 If the root only has one child and the node we are inserting becomes the root's other child<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(1)</b>\u00a0\u2014 If we are removing the root and the root only has one child</li></ul><p><b>Space Complexity (Regular Binary Search Tree)</b><br></p><p></p><ul><li><b>O(<i>n</i>)</b>\u00a0\u2014 Each node contains either 3 pointers (parent, left child, and right child) and the data, so O(1) space for each node, and we have exactly <i>n</i> nodes</li></ul><p><br></p><h2>Time/Space Complexities of a Randomized Search Tree<br></h2><p></p><p><b>Worst-Case Time Complexity (Randomized Search Tree)</b></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(<i>n</i>)</b> \u2014 If the elements are in ascending/descending order in terms of\u00a0<i>both</i> keys\u00a0<i>and</i> priorities, we get a Linked List</li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(<i>n</i>)</b>\u00a0\u2014 If the elements are in ascending/descending order in terms of <i>both</i> keys <i>and</i> priorities, we get a Linked List<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(<i>n</i>)</b>\u00a0\u2014 If the elements are in ascending/descending order in terms of <i>both</i> keys <i>and</i> priorities, we get a Linked List<br></li></ul><p><b>Average-Case Time Complexity (Randomized Search Tree)</b></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(log <i>n</i>)</b>\u00a0\u2014 The formal proof is too complex for a summary slide<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(log\u00a0<i>n</i>)</b>\u00a0\u2014 The formal proof is too complex for a summary slide<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(log\u00a0<i>n</i>)</b>\u00a0\u2014 The formal proof is too complex for a summary slide<br></li></ul><p><b>Best-Case Time Complexity (Randomized Search Tree)</b><br></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(1)</b>\u00a0\u2014 If the query is the root<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(1)</b>\u00a0\u2014 If the root only has one child and the node we are inserting becomes the root's other child<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(1)</b>\u00a0\u2014 If we are removing the root and the root only has one child</li></ul><p></p><p><b>Space Complexity (Randomized Search Tree)</b><br></p><p></p><ul><li><b>O(<i>n</i>)</b>\u00a0\u2014 Each node contains either 3 pointers (parent, left child, and right child), the key, and the priority, so O(1) space for each node, and we have exactly <i>n</i> nodes</li></ul><p></p><p><br></p><h2>Time/Space Complexities of an AVL Tree<br></h2><p></p><p><b>Worst-Case Time Complexity (AVL Tree)</b></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(log\u00a0<i>n</i>)</b> \u2014 AVL Trees must be balanced by definition</li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(log\u00a0<i>n</i>)</b>\u00a0\u2014 AVL Trees must be balanced\u00a0by definition, and the rebalancing is O(log\u00a0<i>n</i>)<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(log\u00a0<i>n</i>)</b>\u00a0\u2014 AVL Trees must be balanced by definition, and the rebalancing is O(log\u00a0<i>n</i>)<br></li></ul><p><b>Average-Case Time Complexity (AVL Tree)</b></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(log <i>n</i>)</b>\u00a0\u2014 The formal proof is too complex for a summary slide<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(log <i>n</i>)</b>\u00a0\u2014 The formal proof is too complex for a summary slide<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(log <i>n</i>)</b>\u00a0\u2014 The formal proof is too complex for a summary slide<br></li></ul><p><b>Best-Case Time Complexity (AVL Tree)</b><br></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(1)</b>\u00a0\u2014 If the query is the root<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(log <i>n</i>)</b>\u00a0\u2014 AVL Trees must be balanced, so we have to go down the entire O(log\u00a0<i>n</i>) height of the tree<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(log <i>n</i>)</b>\u00a0\u2014 The formal proof is too complex for a summary slide</li></ul><p></p><p><b>Space Complexity (AVL Tree)</b><br></p><p></p><ul><li><b>O(<i>n</i>)</b>\u00a0\u2014 Each node contains either 3 pointers (parent, left child, and right child) and the data, so O(1) space for each node, and we have exactly <i>n</i> nodes</li></ul><p></p><p><br></p><h2>Time/Space Complexities of a Red-Black Tree<br></h2><p></p><p><b>Worst-Case Time Complexity (Red-Black Tree)</b></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(log <i>n</i>)</b> \u2014 Red-Black Trees must be balanced (formal proof is too complex for a summary slide)</li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(log <i>n</i>)</b>\u00a0\u2014 Red-Black Trees must be balanced (formal proof is too complex for a summary slide), so we have to go down the entire O(log <i>n</i>) height of the tree,\u00a0and the rebalancing occurs with O(1) cost during the insertion<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(log <i>n</i>)</b>\u00a0\u2014 Red-Black Trees must be balanced (formal proof is too complex for a summary slide), and the rebalancing occurs with O(1) cost during the removal<br></li></ul><p><b>Average-Case Time Complexity (Red-Black Tree)</b></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(log <i>n</i>)</b>\u00a0\u2014 The formal proof is too complex for a summary slide<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(log <i>n</i>)</b>\u00a0\u2014 The formal proof is too complex for a summary slide<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(log <i>n</i>)</b>\u00a0\u2014 The formal proof is too complex for a summary slide<br></li></ul><p><b>Best-Case Time Complexity (Red-Black Tree)</b><br></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(1)</b>\u00a0\u2014 If the query is the root<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(log <i>n</i>)</b>\u00a0\u2014 Red-Black Trees must be balanced (formal proof is too complex for a summary slide), so we have to go down the entire O(log <i>n</i>) height of the tree, and the rebalancing occurs with O(1) cost during the insertion<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(log <i>\ufeffn</i>)</b>\u00a0\u2014 The formal proof is too complex for a summary slide</li></ul><p></p><p><b>Space Complexity (Red-Black Tree)</b><br></p><p></p><ul><li><b>O(<i>n</i>)</b>\u00a0\u2014 Each node contains either 3 pointers (parent, left child, and right child) and the data, so O(1) space for each node, and we have exactly <i>n</i> nodes</li></ul><p></p><p></p><p></p>", "video": null, "animation": null, "options": {}, "subtitle_files": [], "source": null, "subtitles": {}, "tests_archive": null, "feedback_correct": "", "feedback_wrong": ""}, "id": "124152", "time": "2017-09-11T11:51:35.576352"}