{"time": "2016-09-20T21:00:45.665161", "block": {"name": "text", "subtitles": {}, "source": null, "subtitle_files": [], "feedback_wrong": "", "video": null, "animation": null, "feedback_correct": "", "tests_archive": null, "text": "<h1>Ternary Search Tree</h1><p><b>Summary Description</b></p><ul><li>A Ternary Search Tree is a trie in which each node has at most 3 children: a\u00a0<i>middle</i>,\u00a0<i>left</i>, and\u00a0<i>right</i> child</li><li>For every node <i>u</i>, the <i>left child</i> of <i>u</i> must have a value <i>less than u</i>, and the <i>right child</i> of <i>u</i> must have a value greater than <i>u</i><br></li><li>The <i>middle child</i> of <i>u</i> represents the next character in the current word<br></li><li>For a given \"word node,\" define the path from the root to the \"word node\" as <i>path</i>, and define <i>S</i> as the set of all nodes in <i>path</i> that have a middle child also in <i>path</i>.\u00a0The word represented by the \"word node\" is defined as the concatenation of the labels of each node in <i>S</i>, along with the label of the \"word node\" itself<br></li></ul><p></p><p><br></p><h2>Time/Space Complexities of a Ternary Search Tree</h2><p><b>Worst-Case Time Complexity</b></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(<i>n</i>)</b> \u2014 If we insert the elements in ascending/descending order, we effectively get a Linked List</li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(<i>n</i>)</b>\u00a0\u2014 If we insert the elements in ascending/descending order, we effectively get a Linked List<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(<i>n</i>)</b>\u00a0\u2014 If we insert the elements in ascending/descending order, we effectively get a Linked List<br></li></ul><p><b>Average-Case Time Complexity</b></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(log <i>n</i>)</b>\u00a0\u2014 The formal proof is too complex for a summary slide</li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(log\u00a0<i>n</i>)</b>\u00a0\u2014 The formal proof is too complex for a summary slide<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(log\u00a0<i>n</i>)</b>\u00a0\u2014\u00a0The formal proof is too complex for a summary slide<br></li></ul><p><b>Best-Case Time Complexity</b><br></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(<i>k</i>)</b>\u00a0\u2014 If our query, whose length is\u00a0<i>k</i>, was the first word that was inserted into the tree<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(<i>k</i>)</b>\u00a0\u2014 If our new word, whose length is k, is a prefix of the first word that was inserted into the tree<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(<i>k</i>)</b>\u00a0\u2014 If our query, whose length is k, was the first word that was inserted into the tree</li></ul><p><b>Space Complexity</b><br></p><p></p><ul><li><b>O(<i>\ufeffn</i>)</b>\u00a0\u2014\u00a0The formal proof is too complex for a summary slide</li></ul><p></p>", "options": {}}, "id": "124158"}