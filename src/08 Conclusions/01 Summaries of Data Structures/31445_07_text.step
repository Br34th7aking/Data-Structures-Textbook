{"block": {"name": "text", "text": "<h1>Hash Table and Hash Map</h1><p><b>Summary Description</b></p><ul><li>A Hash Table is an array that, given a key\u00a0<i>key</i>, computes a hash value from\u00a0<i>key</i> (using a hash function) and then uses the hash value to compute an index at which to store\u00a0<i>key</i></li><li>A Hash Map is the exact same thing as a Hash Table, except instead of storing just\u00a0<i>keys</i>, we store (<i>key</i>,\u00a0<i>value</i>) pairs</li><li>The capacity of a Hash Table should be prime (to help reduce collisions)</li><li>When discussing the time complexities of Hash Tables/Maps, we typically ignore the time complexity of the hash function</li><li>The load factor of a Hash Table,\u00a0$\\alpha =  \\frac{N}{M} $\u00a0(<i>N</i> = size of Hash Table and\u00a0<i>M</i> = capacity of Hash Table) should remain below ~0.75 to keep the Hash Table fast (a smaller load factor means better performance, but it also means more wasted space)</li><li>For a hash function <i>h</i> to be valid, given two equal keys\u00a0<i>k</i> and\u00a0<i>l</i>,\u00a0<i>h</i>(<i>k</i>) must equal\u00a0<i>h</i>(<i>l</i>)</li><li>For a hash function\u00a0<i>h</i> to be good, given two unequal keys\u00a0<i>k</i> and\u00a0<i>l</i>,\u00a0<i>h</i>(<i>k</i>) should ideally (but not necessarily) not equal\u00a0<i>h</i>(<i>l</i>)</li><li>A good hash function for a collection that stores\u00a0<i>k</i> items (e.g. a string storing\u00a0<i>k</i> characters, or a list storing\u00a0<i>k</i> objects, etc.) should perform some non-commutative arithmetic that utilizes each of the\u00a0<i>k</i> elements</li><li>In Linear Probing (a form of Open Addressing), collisions are resolved by simply shifting over to the next available slot</li><li>In Double Hashing (a form of Open Addressing), collisions are resolved in a way similar to Linear Probing, except instead of only shifting over one slot at a time, the Hash Table has a second hash function that it uses to determine the \"skip\" for the probe</li><li>In Random Hashing (a form of Open Addressing), for a given key <i>key</i>,\u00a0a pseudorandom number generator is created seeded with\u00a0<i>key</i>, and the possible indices are given by the sequence of numbers returned by the pseudorandom number generator</li><li>In Separate Chaining (a form of Closed Addressing), each slot of the Hash Table is actually a data structure itself (typically a Linked List), and when a key hashes to a given index in the Hash Table, simply insert it into the data structure at that index</li><li>In Cuckoo Hashing (a form of Open Addressing), the Hash Table has to hash functions, and in the case of a collision, the new key pushes the old key out of its slot, and the old key uses the other hash function to find a new slot</li></ul><p></p><p><br></p><h2>Time/Space Complexities of a Hash Table/Map with Linear Probing</h2><p><b>Worst-Case Time Complexity (Linear Probing)</b></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(<i>n</i>)</b> \u2014 If all the keys mapped to the same index, we would need to probe over all\u00a0<i>n</i> elements</li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(<i>n</i>)</b>\u00a0\u2014 If all the keys mapped to the same index, we would need to probe over all <i>n</i> elements<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(<i>n</i>)</b>\u00a0\u2014 If all the keys mapped to the same index, we would need to probe over all <i>n</i> elements<br></li></ul><p><b>Average-Case Time Complexity (Linear Probing)</b></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(1)</b>\u00a0\u2014\u00a0The formal proof is too complex for a summary slide<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(1)</b>\u00a0\u2014\u00a0The formal proof is too complex for a summary slide<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(1)</b>\u00a0\u2014\u00a0The formal proof is too complex for a summary slide<br></li></ul><p><b>Best-Case Time Complexity (Linear Probing)</b><br></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(1)</b>\u00a0\u2014 No collisions<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(1)</b>\u00a0\u2014 No collisions<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(1)</b>\u00a0\u2014 No collisions</li></ul><p><b>Space Complexity (Linear Probing)</b><br></p><p></p><ul><li><b>O(<i>n</i>)</b>\u00a0\u2014 Hash Tables typically have a capacity that is at most some constant multiplied by\u00a0<i>n</i> (the constant is predetermined)</li></ul><p><br></p><h2>Time/Space Complexities of a Hash Table/Map with Double Hashing<br></h2><p></p><p><b>Worst-Case Time Complexity (Double Hashing)</b></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(<i>n</i>)</b> \u2014 If we are extremely unlucky, we may have to probe over all\u00a0<i>n</i> elements</li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(<i>n</i>)</b>\u00a0\u2014 If we are extremely unlucky, we may have to probe over all <i>n</i> elements<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(<i>n</i>)</b>\u00a0\u2014 If we are extremely unlucky, we may have to probe over all <i>n</i> elements<br></li></ul><p><b>Average-Case Time Complexity (Double Hashing)</b></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(1)</b>\u00a0\u2014 The formal proof is too complex for a summary slide<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(1)</b>\u00a0\u2014 The formal proof is too complex for a summary slide<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(1)</b>\u00a0\u2014 The formal proof is too complex for a summary slide<br></li></ul><p><b>Best-Case Time Complexity (Double Hashing)</b><br></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(1)</b>\u00a0\u2014 No collisions<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(1)</b>\u00a0\u2014 No collisions<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(1)</b>\u00a0\u2014 No collisions</li></ul><p></p><p><b>Space Complexity (Double Hashing)</b><br></p><p></p><ul><li><b>O(<i>n</i>)</b>\u00a0\u2014 Hash Tables typically have a capacity that is at most some constant multiplied by <i>n</i> (the constant is predetermined)</li></ul><p></p><p><br></p><h2>Time/Space Complexities of a Hash Table/Map with Random Hashing</h2><p><b>Worst-Case Time Complexity (Random Hashing)</b></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(<i>n</i>)</b> \u2014 If each number generated by our generator mapped to an occupied slot, we would need to generate\u00a0<i>n</i> numbers</li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(<i>n</i>)</b>\u00a0\u2014 If each number generated by our generator mapped to an occupied slot, we would need to generate <i>n</i> numbers<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(<i>n</i>)</b>\u00a0\u2014 If each number generated by our generator mapped to an occupied slot, we would need to generate <i>n</i> numbers<br></li></ul><p><b>Average-Case Time Complexity (Random Hashing)</b></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(1)</b>\u00a0\u2014 The formal proof is too complex for a summary slide (ignoring the time complexity of the pseudorandom number generator)<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(1)</b>\u00a0\u2014 The formal proof is too complex for a summary slide (ignoring the time complexity of the pseudorandom number generator)<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(1)</b>\u00a0\u2014 The formal proof is too complex for a summary slide (ignoring the time complexity of the pseudorandom number generator)<br></li></ul><p><b>Best-Case Time Complexity (Random Hashing)</b><br></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(1)</b>\u00a0\u2014 No collisions (ignoring the time complexity of the pseudorandom number generator)<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(1)</b>\u00a0\u2014 No collisions (ignoring the time complexity of the pseudorandom number generator)<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(1)</b>\u00a0\u2014 No collisions (ignoring the time complexity of the pseudorandom number generator)</li></ul><p><b>Space Complexity (Random Hashing)</b><br></p><p></p><ul><li><b>O(<i>n</i>)</b>\u00a0\u2014 Hash Tables typically have a capacity that is at most some constant multiplied by <i>n</i> (the constant is predetermined)</li></ul><p><br></p><h2>Time/Space Complexities of a Hash Table/Map with Separate Chaining<br></h2><p></p><p><b>Worst-Case Time Complexity (Separate Chaining)</b></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(<i>n</i>)</b> \u2014 If all the keys mapped to the same index (assuming Linked List)</li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(<i>n</i>)</b>\u00a0\u2014 If all the keys mapped to the same index (assuming Linked List)\u00a0and we check for duplicates. <br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(<i>n</i>)</b>\u00a0\u2014 If all the keys mapped to the same index (assuming Linked List)<br></li></ul><p><b>Average-Case Time Complexity (Separate Chaining)</b></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(1)</b>\u00a0\u2014 The formal proof is too complex for a summary slide<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(1)</b>\u00a0\u2014 The formal proof is too complex for a summary slide<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(1)</b>\u00a0\u2014 The formal proof is too complex for a summary slide<br></li></ul><p><b>Best-Case Time Complexity (Separate Chaining)</b><br></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(1)</b>\u00a0\u2014 No collisions<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(1)</b>\u00a0\u2014 No collisions<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(1)</b>\u00a0\u2014 No collisions</li></ul><p></p><p><b>Space Complexity (Separate Chaining)</b><br></p><p></p><ul><li><b>O(<i>n</i>)</b>\u00a0\u2014 Hash Tables typically have a capacity that is at most some constant multiplied by <i>n</i> (the constant is predetermined), and each of our\u00a0<i>n</i> nodes occupies O(1) space</li></ul><p><br></p><h2>Time/Space Complexities of a Hash Table/Map with Cuckoo Hashing<br></h2><p></p><p><b>Worst-Case Time Complexity (Cuckoo Hashing)</b></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(1)</b> \u2014 Keys can only map to two slots</li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(<i>n</i>)</b>\u00a0\u2014 If we run into a cycle and bound it by\u00a0<i>n</i>\ufeff (otherwise we could face an infinite loop), we rebuild the table in-place<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(1)</b>\u00a0\u2014 Keys can only map to two slots<br></li></ul><p><b>Average-Case Time Complexity (Cuckoo Hashing)</b></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(1)</b>\u00a0\u2014 Keys can only map to two slots<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(1)</b>\u00a0\u2014 The formal proof is too complex for a summary slide<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(1)</b>\u00a0\u2014 Keys can only map to two slots<br></li></ul><p><b>Best-Case Time Complexity (Cuckoo Hashing)</b><br></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(1)</b>\u00a0\u2014 Keys can only map to two slots<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(1)</b>\u00a0\u2014 No collisions<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(1)</b>\u00a0\u2014 Keys can only map to two slots</li></ul><p></p><p><b>Space Complexity (Cuckoo Hashing)</b><br></p><p></p><ul><li><b>O(<i>n</i>)</b>\u00a0\u2014 Hash Tables typically have a capacity that is at most some constant multiplied by <i>n</i> (the constant is predetermined)</li></ul><p></p><p></p>", "video": null, "animation": null, "options": {}, "subtitle_files": [], "source": null, "subtitles": {}, "tests_archive": null, "feedback_correct": "", "feedback_wrong": ""}, "id": "124154", "time": "2017-09-11T11:51:36.993716"}