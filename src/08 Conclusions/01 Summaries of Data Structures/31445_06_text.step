{"block": {"name": "text", "text": "<h1>B-Tree and B+ Tree</h1><p><b>Summary Description</b></p><ul><li>A\u00a0B-Tree is a self-balancing tree in which internal nodes must have at least\u00a0<i>b</i> and at most 2<i>b</i> children (for some predefined\u00a0<i>b</i>), all leaves must be on the same level of the tree, the elements within a given node must be in ascending order, and child pointers appear\u00a0<i>between</i> elements and on the edges of the node</li><li>For two adjacent elements\u00a0<i>i</i> and\u00a0<i>j</i>\u00a0in a B-Tree (where\u00a0<i>i</i> &lt;\u00a0<i>j</i>, so\u00a0<i>i</i> is to the left of\u00a0<i>j</i>), all elements down the subtree to the left of\u00a0<i>i</i> must be smaller than\u00a0<i>i</i>, all elements down the subtree between <i>i</i> and\u00a0<i>j</i>\u00a0must be greater than\u00a0<i>i</i> and less than\u00a0<i>j</i>, and all elements down the subtree to the right of\u00a0<i>j</i> must be greater than\u00a0<i>j</i></li><li>A B+ Tree can be viewed as a variant of the B-tree in which each internal node contains only keys and the leaves contain the actual data records<br></li><li>In a B+ Tree,\u00a0<i>M</i> denotes the maximum number of children any nodes can have, and\u00a0<i>L</i> denotes the maximum number of data records</li><li>In a B+ Tree, every node has at most\u00a0<i>M</i> children, every internal node except the root has at least\u00a0\u2308M/2\u2309 children, the root has at least 2 children (if it's not a leaf), an internal node with <i>k</i> children must contain\u00a0<i>k</i>\u20131 elements,\u00a0all leaves must be on the same level of the tree, internal nodes only contain \"search keys\" (no data records), and the smallest data record between search keys\u00a0<i>i</i> and\u00a0<i>j</i>\u00a0(where <i>i</i> &lt;\u00a0<i>j</i>)\u00a0must equal\u00a0<i>i</i></li></ul><p></p><p></p><p><br></p><h2>Time/Space Complexities of a B-Tree</h2><p><b>Worst-Case Time Complexity (B-Tree)</b></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(log\u00a0<i>n</i>)</b> \u2014 B-Trees must be balanced by definition</li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(b*log\u00a0<i>n</i>)</b>\u00a0\u2014  B-Trees must be balanced by definition, and the re-balancing is O(b*log <i>n</i>) because worst case scenario, we need to shuffle around O(<i>b)</i> keys in a node at each level to keep the sorted order property<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(b*log\u00a0<i>n</i>)</b>\u00a0\u2014  B-Trees must be balanced by definition, and the re-balancing is O(b*log <i>n</i>) because worst case scenario, we need to shuffle around O(<i>b)</i> keys in a node at each level to keep the sorted order property<br></li></ul><p><b>Average-Case Time Complexity (B-Tree)</b></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(log\u00a0<i>n</i>)</b>\u00a0\u2014 The formal proof is too complex for a summary slide<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(log\u00a0<i>n</i>)</b>\u00a0\u2014 The formal proof is too complex for a summary slide<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(log\u00a0<i>n</i>)</b>\u00a0\u2014 The formal proof is too complex for a summary slide<br></li></ul><p><b>Best-Case Time Complexity (B-Tree)</b><br></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(1)</b>\u00a0\u2014If the query is the middle element of the root (so Binary Search finds it first)<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(log n)</b>\u00a0\u2014 All insertions happen at the leaves. In the best case, no re-sorting or re-balancing is needed<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(log n)</b>\u00a0\u2014 Removing from any location will require the re-adjustment of child pointers <i>or</i> traversing the entire height of the tree. In the best case, no re-sorting or re-balancing is needed<br></li></ul><p><b>Space Complexity (B-Tree)</b><br></p><p></p><ul><li><b>O(<i>n</i>)</b>\u00a0\u2014 Every node must be at least\u00a0$ \\frac{1}{3} \\le \\frac{b-1}{2b-1} \\lt  \\frac{1}{2} $\u00a0full, so in the worst case, every node is\u00a0$ \\frac{1}{3} $\u00a0full, meaning we allocated O(3<i>n</i>) space, which is O(<i>n</i>)<br></li></ul><p><br></p><h2>Time/Space Complexities of a B+ Tree<br></h2><p></p><p><b>Worst-Case Time Complexity (B+ Tree)</b></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(log\u00a0<i>n + </i>log<i> L</i>)</b> \u2014 B+ Trees must be balanced by definition</li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(<i>M*</i>log\u00a0<i>n</i> + <i>L</i>)</b>\u00a0\u2014 B+ Trees must be balanced by definition and the re-balancing is O(M*log <i>n + L</i>) because worst case scenario, we need to shuffle around <i>O(M)</i> keys in an internal node, O(<i>L)</i> data records in a leaf node, for O(log<i> n</i>) levels of the tree in order to keep the sorted order property<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> <b> O(<i>M*</i>log <i>n</i> + <i>L</i>)</b>\u00a0</b>\u00a0\u2014 B+ Trees must be balanced by definition and the re-balancing is O(M*log <i>n + L</i>) because worst case scenario, we need to shuffle around <i>O(M)</i> keys in an internal node, O(<i>L)</i> data records in a leaf node, for O(log<i> n</i>) levels of the tree in order to keep the sorted order property<br></li></ul><p><b>Average-Case Time Complexity (B+ Tree)</b></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(log <i>n</i>)</b>\u00a0\u2014The formal proof is too complex for a summary slide<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(log\u00a0<i>n</i>)</b>\u00a0\u2014 The formal proof is too complex for a summary slide<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(log\u00a0<i>n</i>)</b>\u00a0\u2014The formal proof is too complex for a summary slide<br></li></ul><p><b>Best-Case Time Complexity (B+ Tree)</b><br></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(log n)</b>\u00a0\u2014 All data records are stored at the leaves<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(log n)</b>\u00a0\u2014 All insertions happen at the leaves. In the best case, no re-sorting or re-balancing is needed<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(log n)</b>\u00a0\u2014 Removing from any location will require the re-adjustment of child pointers <i>or</i> traversing the entire height of the tree.  In the best case, no re-sorting or re-balancing is needed<br></li></ul><p></p><p><b>Space Complexity (B+ Tree)</b><br></p><p></p><ul><li><b>O(<i>n</i>)</b>\u00a0\u2014 Every node must be at least\u00a0$ \\frac{\\frac{M}{2}L}{ML} = \\frac{1}{2} (\\frac{ML}{ML}) = \\frac{1}{2}$\u00a0full, so in the worst case, every node is\u00a0$ \\frac{1}{2} $\u00a0full, meaning we allocated O(2<i>n</i>) space, which is O(<i>n</i>)<br></li></ul><p></p><p></p><p></p>", "video": null, "animation": null, "options": {}, "subtitle_files": [], "source": null, "subtitles": {}, "tests_archive": null, "feedback_correct": "", "feedback_wrong": ""}, "id": "124153", "time": "2017-11-07T22:26:44.413412"}