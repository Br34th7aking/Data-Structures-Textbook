{"block": {"name": "text", "text": "<h1>Multiway Trie</h1><p><b>Summary Description</b></p><ul><li>A Multiway Trie is a tree structure in which, for some alphabet\u00a0\u03a3, edges are labeled by a single character in \u03a3 and\u00a0nodes can have at most |\u03a3| children</li><li>For a given \"word node\" in a Multiway Trie, the key associated with the \"word node\" is defined by the concatenation of edge labels on the path from the root of the tree to the \"word node\"</li><li>We use\u00a0<i>k</i> to denote the length of the longest key in the Multiway Trie and\u00a0<i>n</i> to denote the number of elements it contains</li></ul><p></p><p><br></p><h2>Time/Space Complexities of a Multiway Trie<br></h2><p><b>Worst-Case Time Complexity</b></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(<i>k</i>)</b> \u2014 Perform a O(1) traversal for each of the key's\u00a0<i>k</i> letters</li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(<i>k</i>)</b>\u00a0\u2014 Perform a O(1) traversal for each of the key's <i>k</i> letters along with O(1) node/edge creations<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(<i>k</i>)</b>\u00a0\u2014 Perform the find algorithm, and then remove the \"word node\" label from the resulting node<br></li></ul><p><b>Average-Case Time Complexity</b></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(<i>k</i>)</b>\u00a0\u2014 If all keys are length\u00a0<i>k</i>, then we do\u00a0$ \\frac{k + k + ... + k}{n} = \\frac{nk}{k} = k $\u00a0on average, translating to O(<i>k</i>). If only one key is length\u00a0<i>k</i>, even if all other keys are length 1, then we do\u00a0$ \\frac{1+1+...+1+k}{n} = \\frac{n-1+k}{n} = 1 $\u00a0for <i>n</i> &gt;&gt;\u00a0<i>k</i>, translating to O(1). If the lengths of keys are distributed uniformly between 1 and\u00a0<i>k</i>, then the expected length of a key is\u00a0$ \\frac{k}{2} $, translating to O(<i>k</i>)</li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(<i>k</i>)</b>\u00a0\u2014 Same proof as average-case find<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(<i>k</i>)</b>\u00a0\u2014\u00a0Same proof as average-case find<br></li></ul><p><b>Best-Case Time Complexity</b><br></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(<i>k</i>)</b>\u00a0\u2014 If all keys are length\u00a0<i>k</i> (otherwise, it will simply be the length of the query string)<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(<i>k</i>)</b>\u00a0\u2014 If all keys are length <i>k</i> (otherwise, it will simply be the length of the query string)<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(<i>k</i>)</b>\u00a0\u2014 If all keys are length <i>k</i> (otherwise, it will simply be the length of the query string)</li></ul><p><b>Space Complexity</b><br></p><p></p><ul><li><b>Worst-Case: O$ \\left(|\\Sigma|^{k+1}\\right) $<span></span><span></span><span></span></b>\u00a0\u2014 If we were to have every possible string of length\u00a0<i>k</i>, the first level of our tree would have 1 node, the next level would have |\u03a3| nodes, then |\u03a3|\u00b2, etc., meaning our total space usage would be\u00a0$ |\\Sigma| \\left(1 + |\\Sigma| + |\\Sigma|^2 + ... + |\\Sigma|^k\\right) = |\\Sigma| \\left(\\sum_{i=0}^k{|\\Sigma|^i}\\right) = |\\Sigma|\\left(\\frac{|\\Sigma|^{k+1}-1}{|\\Sigma|-1}\\right) \\approx |\\Sigma|^{k+1}$\u00a0</li></ul><p></p>", "video": null, "animation": null, "options": {}, "subtitle_files": [], "source": null, "subtitles": {}, "tests_archive": null, "feedback_correct": "", "feedback_wrong": ""}, "id": "124157", "time": "2017-09-11T11:51:37.716419"}