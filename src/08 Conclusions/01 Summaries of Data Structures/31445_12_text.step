{"id": "124492", "block": {"feedback_correct": "", "name": "text", "feedback_wrong": "", "text": "<h1>Graph Traversal Algorithms</h1><p><b>Summary Description</b></p><ul><li>In all graph traversal algorithms we discussed, we choose a specific vertex at which to begin our traversal</li><li>In Breadth First Search, we explore the starting vertex, then its neighbors, then their neighbors, etc. In other words, we explore the graph in layers spreading out from the starting vertex</li><li>Breadth First Search can be easily implemented using a Queue to keep track of vertices to explore</li><li>In Depth First Search, we explore the current path as far as possible before going back to explore other paths</li><li>Depth First Search can be easily implemented using a Stack to keep track of vertices to explore</li><li>In Dijkstra's Algorithm, we explore the shortest possible path at any given moment</li><li>Dijkstra's Algorithm can be easily implemented using a Priority Queue, ordered by shortest distance from starting vertex, to keep track of vertices to explore</li><li>For our purposes in this text, we disallow \"multigraphs\" (i.e., we are disallowing \"parallel edges\": multiple edges with the same start and end node), meaning our graphs have at most |<i>V</i>|\u00b2 edges<br></li></ul><p></p><p></p><p><br></p><h2>Time/Space Complexities of Breadth First Search</h2><p><b>Time Complexity (Breadth First Search)</b></p><ul><li>Exploring the entire graph using Breadth First Search would take time <b>O(|</b><i><b>V</b></i><b>|+|</b><i><b>E</b></i><b>|)</b> because we have to potentially visit all |<i>V</i>| vertices and traverse all |<i>E</i>| edges, where each visit/traversal is O(1)</li></ul><p><b>Space Complexity (Breadth First Search)</b><br></p><p></p><ul><li><b>O(|<i>V</i>|+|<i>E</i>|)</b>\u00a0\u2014 We might theoretically have to keep track of every possible vertex and edge in the graph during our exploration<br></li><li>If we wanted to keep track of the entire current path of every vertex in our Queue, the space complexity would blow up</li></ul><p><br></p><h2>Time/Space Complexities of Depth First Search<br></h2><p></p><p><b>Time Complexity (Depth First Search)</b></p><ul><li>Exploring the entire graph using Depth First Search would take time <b>O(|</b><i><b>V</b></i><b>|+|</b><i><b>E</b></i><b>|)</b> because we have to potentially visit all |<i>V</i>| vertices and traverse all |<i>E</i>| edges, where each visit/traversal is O(1)</li></ul><p></p><p><b>Space Complexity (Depth First Search)</b><br></p><p></p><ul><li><b>O(|<i>V</i>|+|<i>E</i>|)</b>\u00a0\u2014 We might theoretically have to keep track of every possible vertex and edge in the graph during our exploration<br></li><li>Because we are only exploring a single path at a time, even if we wanted to keep track of the entire current path, the space required to do so would only be O(|<i>E</i>|) because a single path can have at most |<i>E</i>| edges</li></ul><p></p><p><br></p><h2>Time/Space Complexities of Dijkstra's Algorithm<br></h2><p></p><p><b>Time Complexity (Dijkstra's Algorithm)</b></p><ul><li>We must initialize each of our |<i>V</i>| vertices, and in the worst case, we will insert (and remove) one element into a Priority Queue for each of our |<i>E</i>| edges, resulting in an overall worst-case time complexity of <b>O(|</b><i><b>V</b></i><b>| + |</b><i><b>E</b></i><b>| log |</b><i><b>E</b></i><b>|)</b> overall if our Priority Queue is implemented intelligently (e.g. using a Heap)</li></ul><p></p><p><b>Space Complexity (Dijkstra's Algorithm)</b><br></p><p></p><ul><li><b>O(|<i>V</i>|+|<i>E</i>|)</b>\u00a0\u2014 We might theoretically have to keep track of every possible vertex and edge in the graph during our exploration</li></ul><p></p><p></p><p></p><p></p>", "subtitle_files": [], "source": null, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2017-01-05T20:14:57.488628"}