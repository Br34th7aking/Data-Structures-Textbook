{"id": "124156", "block": {"feedback_correct": "", "name": "text", "feedback_wrong": "", "text": "<h1>Disjoint Set</h1><p><b>Summary Description</b></p><ul><li>The Disjoint Set ADT is defined by the \"union\" and \"find\" operations: \"union\" merges two sets, and \"find\" returns which set a given element is in</li><li>We can implement the Disjoint Set ADT very efficiently using Up-Trees</li><li>Under Union-by-Size (also known as \"Union-by-Rank\"), when you are choosing which sentinel node to make the parent of the other sentinel node, you choose the sentinel node whose set contains the most elements to be the parent</li><li>Under Union-by-Height, when you are choosing which sentinel node to make the parent of the other sentinel node, you choose the sentinel node whose height is smaller to be the parent</li><li>Under Path Compression, any time you are performing the \"find\" operation to find a given element's sentinel node, you keep track of every node you pass along the way, and once you find the sentinel node, directly connect all nodes you traversed directly to the sentinel node</li><li>Even though Union-by-Height is slightly better than Union-by-Size,\u00a0Path Compression gives us the biggest bang for your buck as far as speed-up goes, and because tree heights change frequently under Path Compression (thus making Union-by-Height difficult to perform), we typically choose to perform Union-by-Size</li><li>In short, most Disjoint Sets are implemented as Up-Trees that perform Path Compression and Union-by-Size</li></ul><p></p><p><br></p><h2>Time/Space Complexities of an Up-Tree</h2><p><b>Worst-Case Time Complexity</b></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(log\u00a0<i>n</i>)</b> \u2014 Under Union-by-Size (the formal proof is too complex for a summary slide)</li><li><b><span class=\"wysiwyg-color-purple\">Union:</span> O(log\u00a0<i>n</i>)</b>\u00a0\u2014 Under Union-by-Size (the formal proof is too complex for a summary slide)</li></ul><p><b>Amortized Time Complexity</b></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span>\u00a0almost O(1)</b>\u00a0\u2014 Technically the inverse\u00a0Ackermann function, which is a small constant for all practical values of\u00a0<i>n</i>\ufeff (the formal proof is too complex for a summary slide)</li><li><b><span class=\"wysiwyg-color-purple\">Union:</span>\u00a0almost O(1)</b>\u00a0\u2014 Technically the inverse Ackermann function, which is a small constant for all practical values of <i>n</i> (the formal proof is too complex for a summary slide)</li></ul><p><b>Best-Case Time Complexity</b><br></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(1)</b>\u00a0\u2014 If our query is a sentinel node<br></li><li><b><span class=\"wysiwyg-color-purple\">Union:</span> O(1)</b>\u00a0\u2014 If our queries are both sentinel nodes</li></ul><p><b>Space Complexity</b><br></p><p></p><ul><li><b>O(<i>n</i>)</b>\u00a0\u2014\u00a0Each element occupies exactly one node, and each node occupies O(1) space</li></ul><p></p>", "subtitle_files": [], "source": null, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2017-06-08T22:40:05.832016"}