{"block": {"name": "text", "text": "<h1>Linked List</h1><p><b>Summary Description</b></p><ul><li>Linked Lists are composed of nodes connected to one another via pointers</li><li>We typically only keep global access to two pointers: a\u00a0<i>head</i> pointer (which points to the first node) and a\u00a0<i>tail</i> pointer (which points to the last node)</li><li>In a Singly-Linked List, each node maintains one pointer: a\u00a0<i>forward</i> pointer that points to the next node in the list</li><li>In a Doubly-Linked List, each node maintains two pointers: a\u00a0<i>forward</i> pointer that points to the next node in the list, and a\u00a0<i>previous</i> pointer that points to the previous node in the list</li><li>Unlike an Array List, we do\u00a0<i>not</i> have direct access to any nodes other than\u00a0<i>head</i> and\u00a0<i>tail</i>, meaning we need to iterate node-by-node one-by-one to access inner nodes</li><li>Once we know where in the Linked List we want to insert or remove, the actual insertion/removal is O(1) because we just change pointers around</li><li>As a result, in each of the cases (worst, average, and best), the time complexity of insert and remove are the same as the time complexity of find, because you call find and then perform a O(1) operation to perform the insertion/removal</li></ul><p></p><p><br></p><h2>Time/Space Complexities of a Linked List</h2><p><b>Worst-Case Time Complexity</b></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(<i>n</i>)</b> \u2014 In both Singly- and Doubly-Linked Lists, if our query is the middle element, we need to iterate over\u00a0$ \\frac{n}{2} $\u00a0nodes</li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(<i>n</i>)</b>\u00a0\u2014 Perform find, which is O(<i>n</i>) in the worst case, and then perform O(1) pointer changes<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(<i>n</i>)</b>\u00a0\u2014 Perform find, which is O(<i>n</i>) in the worst case, and then perform O(1) pointer changes<br></li></ul><p><b>Average-Case Time Complexity</b></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(<i>n</i>)</b>\u00a0\u2014 The average number of checks in a Singly-Linked List is\u00a0$\\frac{1+2+...+n}{n} =  \\frac{\\sum_{i=1}^{n}{i}}{n} = \\frac{n(n+1)}{2n} = \\frac{n+1}{2} $, and in a Doubly-Linked List, if we know the index we want to access, it is\u00a0$ 2 \\frac{\\frac{n}{2}+1}{2} =  \\frac{n}{2} + 1$\u00a0</li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(<i>n</i>)</b>\u00a0\u2014\u00a0Perform find, which is O(<i>n</i>) in the average case, and then perform O(1) pointer changes<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(<i>n</i>)</b>\u00a0\u2014\u00a0Perform find, which is O(<i>n</i>) in the average case, and then perform O(1) pointer changes<br></li></ul><p><b>Best-Case Time Complexity</b><br></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(1)</b>\u00a0\u2014 If our query is the first element we check (or if we specify\u00a0<i>head</i> or\u00a0<i>tail</i> as our query)<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(1)</b>\u00a0\u2014 Perform find, which is O(1) in the best case, and then perform O(1) pointer changes<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(1)</b>\u00a0\u2014 Perform find, which is O(1) in the best case, and then perform O(1) pointer changes</li></ul><p><b>Space Complexity</b><br></p><p></p><ul><li><b>O(<i>n</i>)</b>\u00a0\u2014 Each node contains either 1 or 2 pointers (for Singly- or Doubly-Linked, respectively) and the data, so O(1) space for each node, and we have exactly\u00a0<i>n</i> nodes</li></ul><p></p>", "video": null, "animation": null, "options": {}, "subtitle_files": [], "source": null, "subtitles": {}, "tests_archive": null, "feedback_correct": "", "feedback_wrong": ""}, "id": "124149", "time": "2017-09-11T11:51:33.439856"}