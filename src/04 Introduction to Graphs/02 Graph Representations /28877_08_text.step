{"time": "2016-09-20T20:56:07.735208", "block": {"name": "text", "subtitles": {}, "source": null, "subtitle_files": [], "feedback_wrong": "", "video": null, "animation": null, "feedback_correct": "", "tests_archive": null, "text": "<p>So how would we go about making an adjacency list for a <i>weighted</i> graph? This might be a bit less intuitive than it was for the adjacency matrix since we no longer have a space where we could just write in the weight of each edge. As a result,  one of the ways to represent a weighted graph would be to <i>make</i> space to store the weights of each edge. For example, we could store each entry of our adjacency list as a pair (<b><i>v</i></b>,\u00a0<b><i>c</i></b>), where <b><i>v</i> </b>would be the destination vertex (just as before) and <b><i>c</i></b> would now be the cost of the edge. <br></p><p>Take a look at the example below:</p><p><img height=\"284\" alt=\"\" width=\"777\" src=\"https://ucarecdn.com/5196b599-b5f6-4f0e-b528-161d5c30b253/\"></p><p>Now that we have learned about different ways to store different types of graphs, it is time to discover how we can go about using these representations to not just <i>store</i> a graph, but to also be able to <i>efficiently traverse</i> it.</p>", "options": {}}, "id": "117885"}