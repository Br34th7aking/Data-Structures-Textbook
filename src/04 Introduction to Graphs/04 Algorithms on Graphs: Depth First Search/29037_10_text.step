{"block": {"name": "text", "text": "<p>From the last step we see that the worst case time complexities of both a queue and a stack are the same. As a result, we can intuitively come to the correct conclusion that both DFS and BFS have a worst case time complexity of O(<b>|V|</b> +<b>|E|</b>).</p><p>Notice however that though their time complexity is the same, their memory management is totally different! In other words, to traverse the graph, BFS had to store all of a vertex's neighbors in each step in a queue, to later be able to traverse those neighbors. On the other hand, if you take a look at the recursive implementation of DFS, DFS only needed to store the previous neighbor to explore the next one. As a result, for certain graph structures, DFS can be more memory efficient. <br></p><p>For example, take a look at this graph below, which also happens to be a Binary Search Tree:</p><span class=\"image-wrapper\"><img src=\"https://ucarecdn.com/8917c0bf-b2f4-4ac9-ac30-33046e60425b/\" title=\"Image: https://ucarecdn.com/8917c0bf-b2f4-4ac9-ac30-33046e60425b/\" alt=\"\"></span><p>For <b>DFS</b>, there will be a certain time in the algorithm where it will need to store in memory a single strand of vertices going <i>down</i> the tree (i.e. vertices 8-3-1 will be stored in memory all at once).</p><p>For <b>BFS</b>, there will be a certain time in the algorithm where it will need to store in\u00a0 memory a single strand of vertices going <i>across</i> the tree (i.e. vertices 1-6-7-10 will be stored in memory all at once).</p><p>Even within this simple example, we already see that <b>BFS</b> is beginning to need more space to perform. Now imagine if the tree grows larger? The width of the tree will begin to grow exponentially larger than the height of the tree and as a result, <b>BFS</b> will start to require an exponentially more amount of memory! As a result, in practice, <b>BFS</b> can begin to slow down in performance because of all the extra memory accesses it will need to perform.</p><p>Now that we have seen two very solid algorithms that are used to traverse graphs, we will begin to take a look at their potential algorithmic drawbacks in the next lesson. <br></p>", "video": null, "animation": null, "options": {}, "subtitle_files": [], "source": null, "subtitles": {}, "tests_archive": null, "feedback_correct": "", "feedback_wrong": ""}, "id": "116292", "time": "2017-09-11T11:48:19.839779"}