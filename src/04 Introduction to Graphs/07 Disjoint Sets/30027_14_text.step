{"block": {"name": "text", "text": "<p>We have now introduced the\u00a0<b>Disjoint Set</b> ADT, which allows us to create sets of elements and to very efficiently perform union and find operations on these sets. <br></p><p>You may have noticed (hopefully triggered by the <b><span class=\"wysiwyg-color-red\">STOP and Think</span></b> question) that\u00a0<b><span class=\"wysiwyg-color-purple\">Union-by-Height</span></b> always produces an Up-Tree that is always either just as good, or many times even better, than the tree produced by\u00a0<b><span class=\"wysiwyg-color-blue\">Union-by-Size</span></b>. However, it turns out that, in practice, people typically choose to use\u00a0<b><span class=\"wysiwyg-color-blue\">Union-by-Size</span></b> when they implement their Up-Trees. The reason why they choose\u00a0<b><span class=\"wysiwyg-color-blue\">Union-by-Size</span></b> over\u00a0<b><span class=\"wysiwyg-color-purple\">Union-by-Height</span></b> is that there is a <i>huge</i> savings when it comes to <b><span class=\"wysiwyg-color-red\">path compression</span></b>; one side effect of\u00a0<b><span class=\"wysiwyg-color-red\">path compression</span></b> is that the height of the tree and the subtrees within it change very frequently. As a result, maintaining accurate information about the <i>heights</i> of sets (which is required for <b><span class=\"wysiwyg-color-purple\">Union-by-Height</span></b>)\u00a0becomes quite difficult because of\u00a0<b><span class=\"wysiwyg-color-red\">path compression</span></b>, whereas maintaining accurate information about the <i>sizes</i> of sets (which is required for <b><span class=\"wysiwyg-color-blue\">Union-by-Size</span></b>)\u00a0is extremely easy (constant-time, actually). As a result, though <b><span class=\"wysiwyg-color-blue\">Union-by-Size</span></b> may get <i>slightly</i> worse results than \n<b><span class=\"wysiwyg-color-purple\">Union-by-Height</span></b>, the difference is so small in comparison to the \nsavings from<b> <span class=\"wysiwyg-color-red\">path compression</span></b> that it is considered negligible.<br></p><p>Going back to the example that we had initially introduced in the lesson, by using a\u00a0<b>Disjoint Set</b> implemented using an\u00a0<b>Up-Tree</b>, Sarah can very efficiently solve her problem! In her case, elements of the\u00a0<b>Disjoint Set</b> would be the people she notices, and as she sees individuals\u00a0<i>u</i> and\u00a0<i>v</i> \"connect\", she can simply perform union(<i>u</i>,\u00a0<i>v</i>). When she wants to check if some suspect\u00a0<i>w</i> is connected in some way to Chuck, she can perform find(\"Chuck\") and find(<i>w</i>) and compare the sets they return for equality.</p>", "video": null, "animation": null, "options": {}, "subtitle_files": [], "source": null, "subtitles": {}, "tests_archive": null, "feedback_correct": "", "feedback_wrong": ""}, "id": "118020", "time": "2017-09-11T11:48:53.837603"}