{"id": "116963", "block": {"feedback_correct": "", "name": "text", "feedback_wrong": "", "text": "<p>Implementation-wise, here is the pseudocode for <b><span class=\"wysiwyg-color-blue\">Kruskal's Algorithm</span></b> on a weighted undirected graph <i>G </i>= (<i><b>V</b></i>,<i><b>E</b></i>):<br><ol><li>Create a forest of vertices</li><li>Create a priority queue containing all the edges, ordered by edge weight</li><li>While fewer than |<b><i>V</i></b>| - 1 edges have been added back to the forest:<ol><li>Deque the smallest-weight edge (<i>v,w</i>, cost), from the priority queue</li><li>If: <i>v</i> and <i>w </i>already belong to the same tree in the forest, go to 3.1 (adding this edge would create a cycle)</li><li>Else: Join those vertices with that edge and continue<br></li></ol></li></ol><p>Below is a visualization of how<b> <span class=\"wysiwyg-color-blue\">Kruskal's Algorithm </span></b>takes advantage of the priority queue to choose which vertices and edges to use to build the <b><span class=\"wysiwyg-color-red\">Minimum Spanning Tree</span></b>. Use the arrows in the bottom left to step through the slides.</p><p>\r\n<iframe src=\"https://docs.google.com/presentation/d/1GKVE1mHOQE5MsmaHWTxDiBJUyulSU5eUwnYgEN8EV7A/embed?start=false&amp;loop=false&amp;delayms=60000\" width=100% height=\"550\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\"></iframe></p><p>It turns out that if <b><span class=\"wysiwyg-color-blue\">Kruskal's Algorithm</span></b> is implemented efficiently, it has a worst-case Big-O time complexity that is the same as <b><span class=\"wysiwyg-color-blue\">Prim's Algorithm</span></b>: <b>O(|<i>V</i>| + |<i>E</i>|*log(|<i>E</i>|)). </b></p>", "subtitle_files": [], "source": null, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2017-02-14T23:18:06.740524"}