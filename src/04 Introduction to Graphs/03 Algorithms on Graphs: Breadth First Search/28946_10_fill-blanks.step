{"block": {"name": "fill-blanks", "text": "<p><b><span class=\"wysiwyg-color-purple\">EXERCISE BREAK:</span>\u00a0</b>We now know that <b><span class=\"wysiwyg-color-green\">Breadth First Search</span></b> can perform well to find the shortest path between vertex <i>u </i>to <i>v</i>. But <i>how</i> well can it perform? Let's look at another pseudocode of <b><span class=\"wysiwyg-color-green\">BFS</span></b> to derive its worst-case Big-O time complexity. <br></p><p>Choose the tightest time complexity (in Big-O notation) for the corresponding line of the pseudocode below. Note that |<i>V</i>|<i></i> corresponds to the\u00a0<i>total number of vertices</i> in the graph and |<i>E</i>|<i></i> corresponds to the <i>total number of edges</i> in the graph. Also, note that\u00a0<i>s</i> is the starting node of the <b><span class=\"wysiwyg-color-green\">BFS</span></b>.<br></p><p></p><p></p>", "video": null, "animation": null, "options": {}, "subtitle_files": [], "source": {"components": [{"text": "<code>BFS(s):\n    <br>&emsp;&emsp;&emsp;&emsp; initially, give all vertices in the graph a distance of INFINITY</code>", "options": [], "type": "text"}, {"text": "", "options": [{"text": "O(1)", "is_correct": false}, {"text": "O(|V|)", "is_correct": true}, {"text": "O(|E|)", "is_correct": false}, {"text": "O(|V| + |E|)", "is_correct": false}], "type": "select"}, {"text": "<code><br>   &emsp;&emsp;&emsp;&emsp; start at s; give s distance = 0</code>", "options": [], "type": "text"}, {"text": "", "options": [{"text": "O(1)", "is_correct": true}, {"text": "O(|V|)", "is_correct": false}, {"text": "O(|E|)", "is_correct": false}, {"text": "O(|V| + |E|)", "is_correct": false}], "type": "select"}, {"text": "<code><br>  &emsp;&emsp;&emsp;&emsp;  enqueue s into a queue</code>", "options": [], "type": "text"}, {"text": "", "options": [{"text": "O(1)", "is_correct": true}, {"text": "O(|V|)", "is_correct": false}, {"text": "O(|E|)", "is_correct": false}, {"text": "O(|V| + |E|)", "is_correct": false}], "type": "select"}, {"text": "<code><br>    &emsp;&emsp;&emsp;&emsp;    while the queue is not empty:</code>", "options": [], "type": "text"}, {"text": "", "options": [{"text": "O(1)", "is_correct": false}, {"text": "O(|V|)", "is_correct": false}, {"text": "O(|E|)", "is_correct": true}, {"text": "O(|V| + |E|)", "is_correct": false}], "type": "select"}, {"text": "<code><br>     &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;   dequeue the vertex v from the head of the queue</code>\n         ", "options": [], "type": "text"}, {"text": "", "options": [{"text": "O(1)", "is_correct": true}, {"text": "O(|V|)", "is_correct": false}, {"text": "O(|E|)", "is_correct": false}, {"text": "O(|V| + |E|)", "is_correct": false}], "type": "select"}, {"text": "<code><br>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;      for each of v's adjacent nodes that have not yet been visited:</code>", "options": [], "type": "text"}, {"text": "", "options": [{"text": "O(1)", "is_correct": false}, {"text": "O(|V|)", "is_correct": false}, {"text": "O(|E|)", "is_correct": true}, {"text": "O(|V| + |E|)", "is_correct": false}], "type": "select"}, {"text": "<code><br>    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;        mark its distance as as 1 + distance to v</code>", "options": [], "type": "text"}, {"text": "", "options": [{"text": "O(1)", "is_correct": true}, {"text": "O(|V|)", "is_correct": false}, {"text": "O(|E|)", "is_correct": false}, {"text": "O(|V| + |E|)", "is_correct": false}], "type": "select"}, {"text": "<code><br>     &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;       enqueue it in the queue</code>", "options": [], "type": "text"}, {"text": "", "options": [{"text": "O(1)", "is_correct": true}, {"text": "O(|V|)", "is_correct": false}, {"text": "O(|E|)", "is_correct": false}, {"text": "O(|V| + |E|)", "is_correct": false}], "type": "select"}], "is_case_sensitive": true}, "subtitles": {}, "tests_archive": null, "feedback_correct": "", "feedback_wrong": ""}, "id": "111839", "time": "2017-09-11T11:48:09.503921"}