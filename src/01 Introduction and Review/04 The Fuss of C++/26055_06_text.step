{"block": {"name": "text", "text": "<p>This next step is a big one, so get ready. We are going to discuss three important, and related, concepts\u2014<b>references</b>, <b>pointers</b>, and <b>memory management</b>\u2014and how each concept is used (or not used) in Java and C++.\u00a0 <br></p><p><b>Objects vs. primitives in Java:</b> In Java, the rules for what is stored in a variable are simple: all object variables store <i>object references</i> while primitive type variables store values directly. In Java, assignment is done by value, so when you assign a primitive variable's value to another variable, the actual value is copied; when it is an object variable, the reference is copied and you get two references to the same object.</p>\n\n<p><b>Objects and primitives in C++: </b>In C++ on the other hand, there is no such distinction between object and primitive variables. By default\u00a0 <i>all </i>variables, both primitives and objects, actually hold <i>values</i>, NOT object references. C++, like Java, does assignment by value. \u00a0 However, this means that when one object variable is assigned to another, a copy of the entire object is made (like calling <span class=\"wysiwyg-font-tt\">clone</span> in Java).</p><p>Let's look at an example below:</p><pre><code class=\"cpp\">Student flo(\"Florence\"); // Creates Student object with name \"Florence\" and stores as variable 'flo'\n                         // Note that we do NOT use the keyword 'new' to create the object.  \nStudent flo2 = flo;      // flo2 stores a copy of the Student, with the same name</code></pre><p></p>\n\n<p><img src=\"https://ucarecdn.com/89e35b9b-f766-4e35-a33d-44c12c95fb0e/\" alt=\"\" width=\"660\" height=\"174\"></p>\n\n<p>As illustrated above, by default, C++ stores variable values directly, no matter their type, and assignments are done by copying the data. This includes passing parameters to a function.</p><p>But what if you want to have two ways to access the same data and avoid this copying-the-data behavior? C++ provides two different concepts that give you related but subtly different ways to do this: <b>references </b> and <b>pointers</b></p><p><b>References in C++: </b>C++ references are NOT the same as Java references. Although they\n are related, how they are used and their syntax is pretty different, \nso it is best if you simply think of them as different concepts. </p><p>References in C++ are simply aliases for existing variables. When you define a reference variable in C++, the variable \nis treated exactly as another \nname as the variable you set it to. Thus, when you modify the reference variable, you modify the original \nvariable as well without needing to do anything special.</p>\n\n<p>The syntax for creating a reference variable in C++ is to place an &amp; after the type name in the variable declaration. If <span class=\"wysiwyg-font-tt\">T</span> is some type, then <span class=\"wysiwyg-font-tt\">T&amp;</span> is the syntax to declare a reference to a <span class=\"wysiwyg-font-tt\">T</span> variable. Reference declarations must be combined with assignments except in the case of function parameters (discussed further on the next page).</p><p>Let's look at an example below:</p><pre><code class=\"cpp\">Student lloyd(\"Lloyd\"); // creates Student object with name \"Lloyd\" and stores as variable 'lloyd'\nStudent &amp; ref = lloyd;  // creates reference to 'lloyd' called 'ref'\nStudent harry(\"Harry\"); // creates Student object with name \"Harry\" and stores as variable 'harry'\n</code></pre><p></p>\n\n<p>The picture below shows what the objects and variables look like so far:</p><img src=\"https://ucarecdn.com/2aae199b-631e-4380-b322-4b5193e2ed38/\" alt=\"\" width=\"613\" height=\"155\"><p></p><p>Now we can execute the following lines:</p>\n<pre><code class=\"cpp\">ref = harry;             // 'ref' is now a copy of 'harry', so 'lloyd' is ALSO now a copy of 'harry'\ncout &lt;&lt; lloyd.getName(); // this would print \"Harry\"</code></pre><p></p>\n\n<p><img src=\"https://ucarecdn.com/95b9a826-21cc-4a3b-a459-f24355bb839a/\" alt=\"\" width=\"629\" height=\"159\"></p>\n\n<p>Note that the whole <span class=\"wysiwyg-font-tt\">Student</span> object was copied, and it replaced the <span class=\"wysiwyg-font-tt\">Student</span> object that was formerly stored in <span class=\"wysiwyg-font-tt\">ref</span>/<span class=\"wysiwyg-font-tt\">lloyd</span>.<br></p><p>There are two main uses for C++ references: parameter passing and aliasing long variable names. In many cases, it's extremely useful not to make copies of objects when they are passed to functions, either because you want the function to be able to modify the data in the object, or because you want to avoid wasting time and space with the copy. <br></p>\n\n<p><b><span class=\"wysiwyg-color-red\">Note:</span></b> This is an overly simple explanation of references. In particular, C++11 has a notion of lvalue references (which are what we showed above) and rvalue references. Don't worry about these subtleties if you don't want to. Throughout this book we'll use only \"classic\" (lvalue) references like what we described above. Though, if you want to learn more, there are certainly plenty of websites that would be happy to explain this in more detail!</p>\n\n\n<p><b>Pointers in C++: </b>Pointers in C++ are actually quite similar to references in Java. They are variables that store the <i>memory address</i> of some data, as opposed to storing the data directly. That is, their <i>value</i> is a memory address. </p><p>\n\n</p><p>If <span class=\"wysiwyg-font-tt\">T</span> is some type, then <span class=\"wysiwyg-font-tt\">T*</span> is the syntax to declare a pointer to a <span class=\"wysiwyg-font-tt\">T</span> variable. A pointer variable can be initialized either with <span class=\"wysiwyg-font-tt\">NULL</span>, with the value of another pointer variable, with the memory address of another variable, or with a call to <span class=\"wysiwyg-font-tt\">new</span> (which will be discussed shortly). The memory address of a variable can be attained by placing the <span class=\"wysiwyg-font-tt\">&amp;</span> symbol before the variable name. To access the object to which a pointer points to, you must \"dereference\" the pointer by placing the <span class=\"wysiwyg-font-tt\">*</span> symbol before the variable name. To access an instance variable of the object to which a pointer points, you can either dereference the pointer and access the instance variable using the <span class=\"wysiwyg-font-tt\">.</span> symbol as normal, or you can use the <span class=\"wysiwyg-font-tt\">-&gt;</span> operator on the pointer directly (which is the more conventional way).</p><pre><code class=\"cpp\">Student lloyd(\"Lloyd\");                // initialize Student object\nStudent* harry = new Student(\"Harry\"); // initialize Student pointer\nStudent* ptr1 = &amp;lloyd;                // initialize ptr1 to store the address of 'lloyd'\nStudent* ptr2 = harry;                 // initialize Student pointer pointing to same object as 'harry'\ncout &lt;&lt; (*ptr1).name;                  // prints \"Lloyd\"\ncout &lt;&lt; ptr2-&gt;getName();               // prints \"Harry\"</code></pre><p></p><p>The memory diagram for the code above is shown below. Note that arrows are used to denote memory addresses in the diagram:</p><p><img src=\"https://ucarecdn.com/9968c470-3056-4d6d-bd33-f921db046806/\" alt=\"\" width=\"447\" height=\"259\"></p><p>As we can see, each box represents a memory location with some data stored in it.\u00a0 Some of the locations have labels, but the <span class=\"wysiwyg-font-tt\">Student</span> object named Harry does not have a label directly.\u00a0 It can only be accessed via the pointer stored in either\u00a0 <span class=\"wysiwyg-font-tt\">harry</span> or\n\n <span class=\"wysiwyg-font-tt\">ptr2.</span> The data stored in each box depends on the type of the variable.\u00a0 <span class=\"wysiwyg-font-tt\">lloyd</span> stores a <span class=\"wysiwyg-font-tt\">Student</span> object, while <span class=\"wysiwyg-font-tt\">harry</span>,\u00a0\n<span class=\"wysiwyg-font-tt\">ptr1</span>, and \n<span class=\"wysiwyg-font-tt\">ptr2</span> all store memory addresses.\u00a0 <br></p><p>Beware of the nomenclature used with pointers. The nomenclature goes as follows: we can either say that a pointer <i>points to</i> an object, or we can say that a pointer <i>stores the address</i> of an object. For example, in the code above, look at the line where we initialize <span class=\"wysiwyg-font-tt\">ptr2</span>. After doing the assignment <span class=\"wysiwyg-font-tt\">ptr2 = harry</span>, we can either say \"<span class=\"wysiwyg-font-tt\">ptr2</span> <i>points to</i> the <span class=\"wysiwyg-font-tt\">Student</span> object named Harry\", or we can say \"<span class=\"wysiwyg-font-tt\">ptr2</span> <i>stores the address</i> of the <span class=\"wysiwyg-font-tt\">Student</span> object named Harry\". However, it would be inaccurate to say that \"<span class=\"wysiwyg-font-tt\">ptr2</span> <i>points to the address of</i> the <span class=\"wysiwyg-font-tt\">Student</span> object named Harry\". The reason why we're bringing attention to this seemingly meaningless formality is because, in C++, you can actually have a pointer that points to another pointer! For example, the following lines of code are perfectly valid, and the notion of a \"pointer to a pointer\" can actually be useful in many contexts:</p><pre><code class=\"cpp\">Student lloyd(\"Lloyd\");   // initialize Student object\nStudent* dumb = &amp;lloyd;   // initialize Student pointer to store address of 'lloyd'\nStudent** dumber = &amp;dumb; // initialize Student pointer pointer to store address of 'dumb'</code></pre><p></p>\n<p><b><span class=\"wysiwyg-color-red\">STOP and Think:</span></b> Can you draw the memory diagram for the above code?</p><p>We have shown several examples of using pointers to point to objects, but you can also use pointers to point to primitive data, and to modify that data!\u00a0 For example, consider the following code:</p><p></p><pre><code>int a = 5;   // a is an int-type variable\nint* b = &amp;a; // b is a pointer to an int that stores the address of a\n</code></pre><p></p>The diagram for the code above looks like this:<p></p><p><img src=\"https://ucarecdn.com/479fb7bf-29f4-438f-a555-c35f2b22c9f0/\" alt=\"\" width=\"191\" height=\"98\"></p><p>Now you can use <span class=\"wysiwyg-font-tt\">b</span> to access, and <i>change</i>,\u00a0 <span class=\"wysiwyg-font-tt\">a</span>.</p><p></p><pre><code>*b = 42;   // This will change the value that's stored in a's box!\ncout &lt;&lt; a; // This will print 42</code></pre><p></p>\n\n<p><b>Memory Management: </b>In Java, there is very little that you, the programmer, must do to manage how memory is created or destroyed.\u00a0 You allocate new memory for objects using the  <span class=\"wysiwyg-font-tt\">new</span> keyword, and that memory is allocated on the heap and automatically reclaimed when the object is no longer reachable (you might have heard this being refereed to as Java having a \"garbage collector\"). Unfortunately, in C++, it's not so simple.</p><p>In a nutshell, memory can be allocated in two ways: <i>automatically</i> and <i>dynamically</i> (it's technically a little more complicated than this, but for our purposes, this will do).</p><p>The default memory allocation is <b>automatic</b>, and it occurs whenever data is created unless you specify otherwise.</p><p>For example, the code below uses <b>automatic</b> memory allocation:</p><pre><code>int a = 5;              // Creates space for an int at compile time, on the stack\nStudent harry(\"Harry\"); // Creates space for a Student object at compile time, on the stack</code></pre><p></p><p><b>Automatic</b> memory allocation is nice because, just like its name implies, the memory will also be <i>reclaimed</i> automatically when the variables go out of scope. Note that automatically allocated variables are <i>usually</i> created on the stack and thus, you don't have to worry too much about them.</p><p>On the other hand, <b>dynamic</b> memory allocation is done at run time and this memory will persist until <i>you</i> explicitly delete it. For example:</p><pre><code>int* a = new int(5);                   // Create a new int on the heap\nStudent* harry = new Student(\"Harry\"); // Create a new Student object on the heap.</code></pre><p></p><p>The keyword \n <span class=\"wysiwyg-font-tt\">new</span> tells C++ to allocate the memory on the heap and not to delete that memory allocation until the programmer explicitly requests it, <i>even if all of the variables that point to that memory location go out of scope!</i></p><p>So, you, the programmer, must explicitly ask for all of your dynamically allocated memory to be deleted using the keyword <span class=\"wysiwyg-font-tt\">delete</span>. If you do not, you will have what's called a <i>memory leak</i>. For example:</p><pre><code>int* a = new int(5);                   // Create a new int on the heap\nStudent* harry = new Student(\"Harry\"); // Create a new Student object on the heap.\n// Some more code\ndelete a;                              // We're done with a so delete it\ndelete harry;                          // We're done with harry, so delete it\n// Some more code\n</code></pre><p></p><p>By default, <span class=\"wysiwyg-font-tt\">delete</span> will free all the memory directly associated with the data stored in the variable. However, if the object points to other dynamically created data, the default behavior will <i>not</i> delete this nested data and you will again have a memory leak, as in the example below:</p>\n<pre><code class=\"cpp\">class Student { // C++\n    public:\n        Student(string n);\n        void setName(string n);\n        string getName() const;\n\n    private:\n        string* name;          \u00a0  // name is now a pointer\n};\n\n\nStudent::Student(string n) { \n    name = new string(n);         // name is allocated dynamically (just for illustration, not a good idea)\n}\n\n\nint doNothing(string aName)\n{\n    Student* s = new Student(\"Sammy\"); // Dynamically allocate Sammy\n    // Some code here\n    delete s;                          // Delete memory allocated to sammy\n                                       // Because Student does not have a destructor defined,\n                                       // this will NOT delete the Student's name field!\n}\n</code></pre><p></p>Fortunately, when you call <span class=\"wysiwyg-font-tt\">delete</span> on an object, C++ will invoke the object's destructor. If it is a class you defined, you must supply a destructor for the object if the object itself has any dynamically created data. So we can fix the code above by adding a destructor to the <span class=\"wysiwyg-font-tt\">Student</span> class:<p></p>\n\n<pre><code class=\"cpp\">class Student { // C++\n    public:\n        Student(string n);  \n        ~Student();               // Declare the destructor\n        void setName(string n);\n        string getName() const;\n\n    private:\n        string* name;             // name is now a pointer\n};\n\n\nStudent::Student(string n) { \n    name = new string(n);         // name is allocated dynamically (just for illustration, not a good idea)\n}\n\nStudent::~Student() {\n   delete name;\n}\n\n\nint doNothing(string aName)\n{\n   Student* s = new Student(\"Sammy\"); // Dynamically allocate s\n   // Some code here\n   delete s;                          // Delete memory allocated to s\n                                      // This will call the destructor for Student\n}\n</code></pre><p></p><p>One final note about the code above is that there was NO NEED to create either the <span class=\"wysiwyg-font-tt\">Student</span> object or the name within the <span class=\"wysiwyg-font-tt\">Student</span> object dynamically. We just did this for illustration. Dynamic allocation is useful when you need your objects to have life beyond the scope in which they are initially declared such as in linked data structures like Linked Lists and Trees.</p><p>Memory management in C++ can be challenging, but by keeping these two rules in mind and you'll be fine:</p><p></p><ul><li>If you can use automatic memory allocation, you probably want to</li><li>If you cannot, make sure you have a call to \n\n<span class=\"wysiwyg-font-tt\">delete</span> \n\nfor every call to \n <span class=\"wysiwyg-font-tt\">new</span>.</li></ul><p></p>", "video": null, "animation": null, "options": {}, "subtitle_files": [], "source": null, "subtitles": {}, "tests_archive": null, "feedback_correct": "", "feedback_wrong": ""}, "id": "95893", "time": "2018-03-04T14:35:09.461862"}