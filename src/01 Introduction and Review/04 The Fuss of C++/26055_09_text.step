{"id": "95894", "block": {"feedback_correct": "", "name": "text", "feedback_wrong": "", "text": "<p>Next, the differences between <b>functions</b> in Java and C++.</p><p><b>Global Functions:</b> In Java, every function must either be an instance method or a static function of a class. C++ supports both of these cases, but it also supports functions that are not part of any class, called \"global functions\". Typically, every functional C++ program starts with the global function <span class=\"wysiwyg-font-tt\">main</span>:</p><p></p><pre><code class=\"cpp\">int main() {\r\n    // CODE\r\n}</code></pre><p></p><p>Notice that this <span class=\"wysiwyg-font-tt\">main</span> method has a return value (<span class=\"wysiwyg-font-tt\">int</span>), whereas the <span class=\"wysiwyg-font-tt\">main</span> methods of Java are <span class=\"wysiwyg-font-tt\">void</span>. By convention, a C++ <span class=\"wysiwyg-font-tt\">main</span> method returns 0 if it completed successfully, or some non-zero integer otherwise.</p><p><b>Passing Parameters:</b> C++ has two parameter-passing mechanisms:\u00a0<i>call by value</i> (as in Java) and\u00a0<i>call by reference</i>. When an object is passed by value, since C++ objects are not references to objects, the function receives a copy of the actual argument. As a result, the function cannot modify the original, and a lot of time and space might be wasted making a copy of the object. If we want to be able to modify the original object, we must pass the object by reference, which we can do by adding an <span class=\"wysiwyg-font-tt\">&amp;</span> after the parameter type as follows:</p><p></p><pre><code>// Successfully swaps the values of the argument variables\r\nvoid swap(int &amp; a, int &amp; b) {\r\n    int temp = a;\r\n    a = b;\r\n    b = temp;\r\n}</code></pre><br><p></p><p>Note that, even if we do not intend to modify the original data, there are still times where we would want to pass by reference, and in these cases it's best to pass by constant reference. For example, in the world of Bioinformatics, programs often represent genomes as string objects and perform various algorithms on these strings. The human genome is roughly 3.3 billion letters long, so a string object containing the entire human genome would be roughly 3.3 GB large. Even if we have no intention of modifying this object in whatever method we will pass it in, we want to pass by reference so that we do not accidentally create a copy of this absurdly large object.\u00a0 If we truly do not intend to modify it, we pass it by constant reference, so we don't end up modifying it accidentally.<br></p><p></p><pre><code class=\"cpp\">double gcContent(const string &amp; genome) {\r\n    // CODE that does not modify genome\r\n}</code></pre><p></p><p>Finally, prior to C++11, passing by const reference was the only way to pass rvalues (values that aren't named variables, like the result of a sum, the return value of a function, or a literal value) to functions without passing them by value, because rvalues by their very transient nature are not allowed to be modified.\u00a0 Even though C++11 introduced the concept of rvalue reference (mainly) for passing rvalues to functions by reference, you will still see functions that use constant reference to allow passing of rvalues by reference.<br></p><p>In short, in C++, you always use call by reference when a function needs to modify a parameter, and you still might want to use call by reference in other situations as well.</p>", "subtitle_files": [], "source": null, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2017-06-08T22:30:32.809519"}