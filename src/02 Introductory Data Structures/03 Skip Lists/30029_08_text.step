{"block": {"name": "text", "text": "<p>The task of optimizing the distribution of heights in a <b><span class=\"wysiwyg-color-red\">Skip List</span></b> falls under the <b>insert</b> operation. We do so by first performing the regular \"find\" algorithm to find where we will insert our new element. Then, we determine our new node's height. By definition, the new node must have a height of at least 0 (i.e., the 0-th layer). So how many layers higher should we build the new node? To answer this question, we will play a simple coin-flip game (we will explain in the next step what this game formally represents): starting at our base height of 0, we flip a coin, where the coin's probability of heads is <i>p</i>. If we flip heads, we increase our height by 1. If we flip tails, we stop playing the game and keep our current height.</p><p>Say, for example, we wish to insert 5 into the following <b><span class=\"wysiwyg-color-red\">Skip List</span></b>:</p><p><span class=\"image-wrapper\"><img src=\"https://ucarecdn.com/aaf667b6-8a9b-4d45-9e21-e9a72d56c97d/\" alt=\"\"></span></p><p>First, we perform the regular \"find\" algorithm to find the insertion site for 5. In the figure below, <b><span class=\"wysiwyg-color-red\">red</span></b> arrows denote pointers that we <i>could</i> have traversed, but would have taken us to a node too big (so we instead chose to go down 1 level), and <b><span class=\"wysiwyg-color-green\">green</span></b> arrows denote pointers we actually took. As you hopefully inferred, the <b><span class=\"wysiwyg-color-red\">red</span></b> arrows are the only ones that we might have to fix upon insertion.</p><p><span class=\"image-wrapper\"><img src=\"https://ucarecdn.com/eece60fd-8987-460f-8356-eec07f4a4ea3/\" alt=\"\"></span></p><p>Now that we have found our insertion site, we must determine the height of our new node. We know that the coin must have a height of at least 0, so we start our height at 0. Then, we flip a coin where the probability of heads is <i>p</i>. Let's say we flipped heads (with probability <i>p</i>): we now increase our height from 0 to 1. Then, we flip the coin again. This time, let's say we flipped tails (with probability 1\u2013<i>p</i>): we stop playing the game and keep our height of 1. We perform the insertion with this new node by simply updating two pointers: one on layer 0 and one on layer 1.</p><p><span class=\"image-wrapper\"><img src=\"https://ucarecdn.com/1daf3cc0-e821-4435-b18f-1d3f8f10d976/\" alt=\"\"></span></p><p>Below is formal pseudocode to describe the \"insert\" algorithm. In the pseudocode, <span class=\"wysiwyg-font-tt\">head</span> is <i>head</i> and <span class=\"wysiwyg-font-tt\">head.height</span> is highest layer in <i>head</i> (which is the highest layer in the <b><span class=\"wysiwyg-color-red\">Skip List</span></b>, by definition). Also, for a given node <span class=\"wysiwyg-font-tt\">current</span>, <span class=\"wysiwyg-font-tt\">current.next</span> is a list of forward-pointers, where <span class=\"wysiwyg-font-tt\">current.next[i]</span> is the forward-pointer at layer <i>i</i>. Lastly, note that the probability of coin-flip success, <i>p</i>, must be a variable defined in the <b><span class=\"wysiwyg-color-red\">Skip List</span></b> itself (we refer to it as <span class=\"wysiwyg-font-tt\"><i>p</i></span> below).</p><p></p><pre><code class=\"cpp\"><b>insert(element): // inserts element if it doesn't exist in the list\n</b>    current = head\n    layer = head.height\n    toFix = empty list of nodes of length head.height + 1 (one slot for each layer)\n    while layer &gt;= 0:                   // can't go lower than layer 0\n        if current.next[layer] is NULL or current.next[layer].key &gt; element:\n            toFix[layer] = current      // we might have to fix a pointer here\n            layer = layer - 1           // drop one layer if we can't go further\n        else:\n            current = current.next[layer]\n        if current.key == element:          // if we found element, return (no duplicates)\n            return\n\n    // if we reached here, we can perform the insertion\n    newNode = new node containing element, starting with height = 0\n    while newNode.height &lt; head.height: // can't go higher than head node's height\n        result = result of coin-flip with probability <i>p</i> of heads\n        if result is heads:\n            newNode.height = newNode.height + 1\n        else: // we have flipped a tails so we should keep the current height\n            break\n    for i from 0 to newNode.height:     // fix pointers\n        newNode.next[i] = toFix[i].next[i]\n        toFix[i].next[i] = newNode</code></pre>", "video": null, "animation": null, "options": {}, "subtitle_files": [], "source": null, "subtitles": {}, "tests_archive": null, "feedback_correct": "", "feedback_wrong": ""}, "id": "121924", "time": "2017-11-07T22:18:09.541620"}