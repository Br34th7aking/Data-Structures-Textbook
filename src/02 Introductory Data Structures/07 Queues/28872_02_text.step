{"block": {"name": "text", "text": "<p>As you should have hopefully inferred, we can use a <b>Deque</b> to implement a <b>Queue</b>: if we implement a <b>Queue</b> using a <b>Deque</b> as our backing structure (where the <b>Deque</b> would have its own backing structure of either a <b><span class=\"wysiwyg-color-blue\">Doubly-Linked List</span></b> or a <b><span class=\"wysiwyg-color-purple\">Circular Array</span></b>, because as you should recall, a <b>Deque</b> is also an <b><span class=\"wysiwyg-color-green\">ADT</span></b>), we can simply reuse the functions of a <b>Deque</b> to implement our <b>Queue</b>. For example, say we had the following <b>Queue</b> class in C++:</p><p></p><pre><code class=\"cpp\">class Queue {\n    private:\n        Deque deque;\n    public:\n        bool enqueue(Data element);\n        Data peek();\n        void dequeue();\n        int size();\n};</code></pre><p></p><p>We could extremely trivially implement the <b>Queue</b> functions as follows:</p><p></p><pre><code class=\"cpp\">bool Queue::enqueue(Data element) {\n    return deque.addBack(element);\n}</code></pre><p></p><p></p><pre><code class=\"cpp\">Data Queue::peek() {\n    return deque.peekFront();\n}</code></pre><p></p><p></p><pre><code class=\"cpp\">void Queue::dequeue() {\n    deque.removeFront();\n}</code></pre><p></p><p></p><pre><code class=\"cpp\">int Queue::size() {\n    return deque.size();\n}</code></pre><p></p><p>The equivalent implementation in Python would be the following:</p><p></p><pre><code class=\"python\">class Queue:\n    deque = Deque()\n    def enqueue(self, element):\n        return deque.addBack(element)\n    def peek(self):\n        return deque.peekFront()\n    def dequeue(self):\n        deque.removeFront()\n    def __len__(self):\n        return len(deque)</code></pre><p></p><p>Of course, as we mentioned, the <b>Deque</b> itself would have some backing data structure as well, but if we use our <b>Deque</b> implementation to back our <b>Queue</b>, the <b>Queue</b> becomes extremely easy to implement.</p><p><b><span class=\"wysiwyg-color-red\">Watch Out!</span></b> Notice that, in our implementation of a <b>Queue</b>, the <span class=\"wysiwyg-font-tt\">dequeue()</span> function has a <span class=\"wysiwyg-font-tt\">void</span> return type, meaning it <i>removes</i> the element on the front of the <b>Queue</b>, but it does not <i>return</i> its value to us. This is purely an implementation-level detail, and in some languages (e.g. Java), the <span class=\"wysiwyg-font-tt\">dequeue()</span> function removes <i>and</i> returns the top element, but in other languages (e.g. C++), the <span class=\"wysiwyg-font-tt\">dequeue()</span> function <i>only removes</i> the front element without returning it, just like in our implementation.<br></p><p><b><span class=\"wysiwyg-color-red\">STOP and Think:</span></b> In our implementation of a <b>Queue</b>, we chose to use the <span class=\"wysiwyg-font-tt\">addBack()</span>, <span class=\"wysiwyg-font-tt\">peekFront()</span>, and <span class=\"wysiwyg-font-tt\">removeFront()</span> functions of the backing <b>Deque</b>. Could we have chosen <span class=\"wysiwyg-font-tt\">addFront()</span>, <span class=\"wysiwyg-font-tt\">peekBack()</span>, and <span class=\"wysiwyg-font-tt\">removeBack()</span> instead? Why or why not?<br></p>", "video": null, "animation": null, "options": {}, "subtitle_files": [], "source": null, "subtitles": {}, "tests_archive": null, "feedback_correct": "", "feedback_wrong": ""}, "id": "115176", "time": "2018-03-04T14:36:55.674282"}