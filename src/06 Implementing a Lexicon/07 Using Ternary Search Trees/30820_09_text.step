{"block": {"name": "text", "text": "<p>The <b>insert</b> algorithm also isn't too bad once you understand the find algorithm. To insert a word <i>key</i> into a <b><span class=\"wysiwyg-color-blue\">Ternary Search Tree</span></b>, perform the find algorithm:</p><p></p><ul><li>If you're able to legally traverse through the tree for every letter of <i>key</i> (which implies <i>key</i> is a prefix of another word in the tree), simply label the node at which you end up as a \"word node\"</li><li>If you are performing the tree traversal and run into a case where you want to traverse left or right, but no such child exists, create a new left/right child labeled by the current letter of <i>key</i>, and then create middle children labeled by each of the remaining letters of <i>key</i></li><li>If you run into a case where you want to traverse down to a middle child, but no such child exists, simply create middle children labeled by each of the remaining letters of <i>key</i><br></li></ul><p>Note that, for the same reasons insertion order affected the shape of a <b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b>, the order in which we insert keys into a <b><span class=\"wysiwyg-color-blue\">Ternary Search Tree</span></b> affects the shape of the tree. For example, just like in a <b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b>, the root node is determined by the first element inserted into a <b><span class=\"wysiwyg-color-blue\">Ternary Search Tree</span></b>.<br></p><p>Below is formal pseudocode for the insert algorithm of the <b><span class=\"wysiwyg-color-blue\">Ternary Search Tree</span></b>:</p><p></p><pre><code class=\"cpp\"><b>insert(key): // insert key into this TST\n</b>    node = root node of the TST\n    letter = first letter of key\n\n    loop infinitely:\n        // left child\n        if letter &lt; node.label:\n            if node has a left child:\n                node = node.leftChild\n\n            else:\n                node.leftChild = new node labeled by letter\n                node = node.leftChild\n\n                iterate letter over the remaining letters of key:\n                    node.middleChild = new node labeled by letter\n                    node = node.middleChild\n\n                label node as a word-node     // inserted key into the TST\n\n        // right child\n        else if letter &gt; node.label:\n            if node has a right child:\n                node = node.rightChild\n\n            else:\n                node.rightChild = new node labeled by letter\n                node = node.rightChild\n\n                iterate letter over the remaining letters of key:\n                    node.middleChild = new node labeled by letter\n                    node = node.middleChild\n\n                label node as a word-node     // inserted key into the TST\n\n        // middle child\n        else:\n            if letter is the last letter of key:\n                label node as a word-node     // inserted key into the TST\n\n            else:\n                if node has a middle child:\n                    node = node.middleChild\n                    letter = next letter of key\n                else:\n                    iterate letter over the remaining letters of key:\n                        node.middleChild = new node labeled by letter\n                        node = node.middleChild\n\n                    label node as a word-node // insert key into the TST</code></pre><p></p>", "video": null, "animation": null, "options": {}, "subtitle_files": [], "source": null, "subtitles": {}, "tests_archive": null, "feedback_correct": "", "feedback_wrong": ""}, "id": "122680", "time": "2017-11-07T22:25:51.982323"}