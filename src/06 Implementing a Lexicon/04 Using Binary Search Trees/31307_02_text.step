{"block": {"name": "text", "text": "<p>In general, if we want to choose a <b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b>\u00a0from the ones we discussed in this text, it should be clear that the only viable contenders are the\u00a0<b><span class=\"wysiwyg-color-purple\">AVL Tree</span></b> and the\u00a0<b><span class=\"wysiwyg-color-red\">Red-Black Tree</span></b> because they are guaranteed to have a\u00a0<b>O(log\u00a0<i>n</i>) worst-case</b> time complexity for all three operations (whereas the <b><span class=\"wysiwyg-color-green\">Regular Binary Search Tree</span></b> and\u00a0<b><span class=\"wysiwyg-color-blue\">Randomized Search Tree</span></b> are O(<i>n</i>) in the worst case). Note that we would prefer to use an <b><span class=\"wysiwyg-color-purple\">AVL Tree</span></b> since they have a stricter balancing requirement,<i>\u00a0</i>\ufeffwhich translates into faster \"find\" operations <i>in practice</i>. <br></p><p>Now that we have refreshed our memory regarding the time complexity of self-balancing <b><span class=\"wysiwyg-color-green\">Binary Search Trees</span></b>, we can begin to discuss how to actually use them to implement the three lexicon functions we previously described.</p>", "video": null, "animation": null, "options": {}, "subtitle_files": [], "source": null, "subtitles": {}, "tests_archive": null, "feedback_correct": "", "feedback_wrong": ""}, "id": "121423", "time": "2017-11-07T22:25:01.824862"}