{"block": {"name": "text", "text": "<p>In the previous section, we discussed our first attempt at handling collisions using a technique called <b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b>, where, if a key maps to a slot in our <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> that is already occupied by a different key, we simply slide over and try again; if that slot is also full, we slide over again; etc. On <b>average</b>, assuming we've designed our <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> intelligently, we experience <b>O(1)</b> find, insert, and remove operations with\u00a0<b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b>. However, in the <b>worst case</b>, we could theoretically have to iterate over all\u00a0<i>N</i> elements to find a key of interest, making our three operations <b>O(<i>N</i>)</b>.</p><p>Also, we saw that keys tend to form \"clumps\" that make probing excessively slow, and these clumps are probabilistically favored to grow. We introduced <b><span class=\"wysiwyg-color-purple\">Double Hashing</span></b> and <b><span class=\"wysiwyg-color-green\">Random Hashing</span></b>, which helped solve our issue of clump formation and helped speed things up a bit.</p><p>Recall that, if we try to insert a key and <i>don't</i> encounter a collision, the probability of subsequent collisions must increase, regardless of how we choose to handle collisions (because we have now filled a previously-unfilled slot of our <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>). If we try to insert a key and we <i>do</i> encounter a collision, with <b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b>, we take a performance hit on two accounts: we have to linearly scan until we find an open slot for insertion (so we take a hit now), and because we've now filled a previously-unfilled slot of our <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>, we have yet again increased the probability of subsequent collisions (so we will take a hit in a future insertion).</p><p>Upon a collision, the current insertion will take a performance hit, no matter which collision resolution strategy we choose. In other words, the performance hit we take now is inevitable. However, in this section, we will discuss another collision resolution strategy <b><span class=\"wysiwyg-color-red\">Separate Chaining</span></b>, in which collisions <i>do not</i> increase the probability of future collisions, so we avoid taking the additional performance hit in the future.</p>", "video": null, "animation": null, "options": {}, "subtitle_files": [], "source": null, "subtitles": {}, "tests_archive": null, "feedback_correct": "", "feedback_wrong": ""}, "id": "121064", "time": "2017-09-11T11:49:34.680992"}