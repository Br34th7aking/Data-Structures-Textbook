{"time": "2016-09-20T20:58:12.678918", "block": {"name": "text", "subtitles": {}, "source": null, "subtitle_files": [], "feedback_wrong": "", "video": null, "animation": null, "feedback_correct": "", "tests_archive": null, "text": "<p>How do we go about implementing this collision resolution strategy? Below is pseudocode to implement <b><span class=\"wysiwyg-color-red\">Separate Chaining</span></b> when inserting a key <span class=\"wysiwyg-font-tt\">k</span> into a <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> of capacity\u00a0<span class=\"wysiwyg-font-tt\">M</span> with a backing array called <span class=\"wysiwyg-font-tt\">arr</span>, using a <b><span class=\"wysiwyg-color-green\">hash function</span></b> <span class=\"wysiwyg-font-tt\">H(k)</span>:</p><p></p><pre><code class=\"cpp\"><b>insert_SeperateChaining(k): // Insert k using Separate Chaining for collision resolution\n</b>\n    index = H(k) \n\n    // check for duplicate insertions (not allowed) and perform insertion\n    if Linked List in arr[index] does not contain k:\n        insert k into Linked List at arr[index]\n<pre><code class=\"cpp\">   // resize backing array\n   if n/m &gt; loadFactorThreshold:\n       arr2 = new array with a size ~2 times the size of arr that is prime  // new backing array\n       insert all elements from arr into arr2 using normal insert algorithm // rehash all elements\n       arr = arr2                                                           // replace arr with arr2</code></pre>\n</code></pre><p></p><p>Notice that the core of the <b><span class=\"wysiwyg-color-red\">Separate Chaining</span></b> algorithm is defined by this line:</p><pre><code class=\"cpp\">insert k into Linked List at arr[index]</code></pre><p></p><p>As you might have noticed, we have been pretty vague as to which implementation of a Linked List (Singly-Linked, Doubly-Linked, etc.) to use because it is really up to the person implementing the <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> to decide exactly which Linked List implementation to choose based on his or her needs. Just like we have been discussing throughout this entire text, we can get vastly different time complexities based on which backing implementation we use and <i>how </i>we chose to use it.</p><p>A common implementation choice is to use a Singly-Linked List with just a head pointer. By choosing that implementation, we consequently add new elements to the <i>front</i> of our Linked List (i.e., reassign the head pointer and the next pointer of the new element) as opposed to the back of the Linked List (i.e., traverse the entire Linked List and then reassign the next pointer of the last element). Note that, if we do not check for duplicate insertions, inserting at the<i> front</i>\ufeff of a singly-linked list produces a worst case <i>constant</i> time complexity and inserting\u00a0at the<i> back</i> of a singly-linked list turns into a worst case <i>linear</i> time complexity.</p><p>By obeying the algorithm above, we are ensuring that our key is inserted strictly within the <i>single</i> index (or more formally, \"address\") to which it originally hashed. Consequently, we call this a <b>closed addressing</b> collision resolution strategy (i.e. the key <i>must</i> be located in the original address). Moreover, since we are now allowing multiple keys to be at a single index, we like to say that <b><span class=\"wysiwyg-color-red\">Separate Chaining</span></b> is an <b>open hashing</b> collision resolution strategy (i.e., the keys do not necessarily need to be physically inside the Hash Table itself).</p><p><b><span class=\"wysiwyg-color-red\">Note:</span></b> You will most likely encounter people using the terms <b>open hashing</b> and <b>closed addressing</b> interchangeably since they arguably describe the same method of collision resolution.</p>", "options": {}}, "id": "121378"}