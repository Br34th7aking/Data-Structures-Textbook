{"id": "121622", "block": {"feedback_correct": "", "name": "text", "feedback_wrong": "", "text": "<p>Hopefully by now you are convinced that <b><span class=\"wysiwyg-color-blue\">Cuckoo Hashing</span></b> is by far the most optimized open addressing collision resolution strategy that\n we have discussed in terms of worst-case time complexities. Specifically, it provides us a guaranteed <b>worst-case constant time</b>\n complexity in the \"find\" and \"remove\" operations that the previous strategies \nwere unable to guarantee.</p><p>Because of the complex nature of <b><span class=\"wysiwyg-color-blue\">Cuckoo Hashing</span></b>, however, there are many more analyses and proofs that this lesson has left out for the sake of simplicity. If you are curious and have the desire to skim/read the original 26-page paper that describes the capabilities of <b><span class=\"wysiwyg-color-blue\">Cuckoo Hashing</span></b> beyond what we have described in this lesson, then you can find it <a rel=\"nofollow\" href=\"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.25.4189&amp;rep=rep1&amp;type=pdf\">here</a>. There is also another much shorter and accessible paper that is intended for undergraduates<a rel=\"nofollow\" href=\"http://www.itu.dk/people/pagh/papers/cuckoo-undergrad.pdf\"> here</a>.</p><p>Also, if you want to play around with inserting and deleting elements, you can find an excellent visualization tool\u00a0<a rel=\"nofollow\" href=\"http://www.lkozma.net/cuckoo_hashing_visualization/\">here</a>.<br></p>", "subtitle_files": [], "source": null, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2017-01-05T20:12:53.682126"}