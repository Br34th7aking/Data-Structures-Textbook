{"id": "122114", "block": {"feedback_correct": "", "name": "text", "feedback_wrong": "", "text": "<p>By making the sacrifice of only allowing each key to hash to strictly two different locations (thereby potentially causing the cycle in the first place), we end up getting a reward of a <b><i>worst-case constant</i></b> time complexity for two of our major operations! Specifically:</p><ul><li>For the \"find\" operation: if the key is not in either index1 = $ H_1(k) $ or index2 = $ H_2(k)  $, then it is not in the table; this is a constant time operation</li><li>For the \"delete\" operation: if the key exists in our table, we know that it is either in index1 = $ H_1(k)  $ or index2 = $ H_2(k)  $, and all we have to do is remove the key from its current index; this is a constant time operation<br></li></ul><p> This is unique to <b><span class=\"wysiwyg-color-blue\">Cuckoo Hashing</span></b> because, in all of the other open addressing collision resolution strategies we have discussed thus far, we could only guarantee an <b>average-case</b> constant time complexity with respect to those two operations because, in the worst case, we had to traverse the entire <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>.</p><p>For the \"insert\" operation in <b><span class=\"wysiwyg-color-blue\">Cuckoo Hashing</span></b>, however, we only get an <i>average</i> case constant time complexity because, in the worst case, we would have to rehash the entire table, which has an <b>O(<i>n</i>)</b> time complexity. However, we can prove through amortized cost analysis (which is\u00a0beyond the scope of this text) that, on <i>average</i>,\u00a0we can finish an insertion before the algorithm is forced to terminate and rehash.</p><p><b><span class=\"wysiwyg-color-red\">Fun Fact:</span></b> A lot of proofs about cycles in <b><span class=\"wysiwyg-color-blue\">Cuckoo Hashing</span></b> are solved by converting the keys within the two <b><span class=\"wysiwyg-color-purple\">Hash Tables</span></b> to nodes and their two possible hashing locations to edges to create a graph theory problem!</p><p><b><span class=\"wysiwyg-color-red\">Note:</span></b> <b><span class=\"wysiwyg-color-blue\"> Cuckoo Hashing</span></b> is not necessarily restricted to using just two <b><span class=\"wysiwyg-color-purple\">Hash Tables</span></b>; it is not uncommon to use more than two <b><span class=\"wysiwyg-color-purple\">Hash Tables</span></b>, and generally, for <i>d</i> <b><span class=\"wysiwyg-color-purple\">Hash Tables</span></b>, each <b><span class=\"wysiwyg-color-purple\">Hash Table </span></b>would have a capacity of $ \\frac{M}{d} $,\u00a0where <i>M</i> is the calculated capacity of a single <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> (i.e., the capacity that we would have calculated had we decided to use a different collision resolution strategy that required only one  <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>).</p>", "subtitle_files": [], "source": null, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2017-01-05T20:12:51.988181"}