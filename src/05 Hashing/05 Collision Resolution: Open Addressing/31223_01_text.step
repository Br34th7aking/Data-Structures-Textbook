{"block": {"name": "text", "text": "<p>As we mentioned repeatedly thus far, we have acknowledged that collisions can happen, and even further, we have proven that they are statistically impossible to fully avoid, but we simply glossed over what to do should we actually encounter one. In this section, we will discuss the first of our <b>collision resolution strategies</b> (i.e., what should be done to successfully perform an insert/find/remove operation if we were to run into a collision): <b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b>. The<b> </b>idea behind this strategy is extremely simple: if an object\u00a0<i>key</i> maps to an index that is already occupied,\u00a0simply shift over and try the next available index. <b><span class=\"wysiwyg-color-blue\"><br></span></b></p><p><span class=\"wysiwyg-color-black\">Here is an intuitive example in which the <b><span class=\"wysiwyg-color-green\">hash function</span></b> is defined as <i>H</i>(<i>k</i>) = (<i>k</i>+3) % <i>m</i>, where <i>k</i> is the ASCII value of <i>key</i> and <i>m</i> is the size of the backing array (we add 3 to <i>k</i> to have the letter 'a' hash to index 0 for simplicity):</span></p><p><img height=\"356\" src=\"https://ucarecdn.com/737d90c0-ddf4-4cdc-b4f4-33ac9b6bf8ea/\" width=\"400\" alt=\"\"></p><p><b><span class=\"wysiwyg-color-red\">STOP and Think:</span></b> Suppose you are inserting a new key into a\u00a0<b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>\u00a0that is already full. What do you expect the algorithm to do?</p>", "video": null, "animation": null, "options": {}, "subtitle_files": [], "source": null, "subtitles": {}, "tests_archive": null, "feedback_correct": "", "feedback_wrong": ""}, "id": "121348", "time": "2018-03-04T14:40:38.394485"}