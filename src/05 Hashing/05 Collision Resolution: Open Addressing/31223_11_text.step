{"id": "121623", "block": {"feedback_correct": "", "name": "text", "feedback_wrong": "", "text": "<p>The solution to avoid keys having a higher probability to insert themselves into certain locations\u2014thereby avoiding the creation of clumps\u2014is pretty simple: designate a <i>different</i> offset for each particular key. Once we do this, we ensure that we have an <i>equal</i> probability for a key to hash to any slot. For example, suppose we start with the <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> below:</p><p><img alt=\"\" src=\"https://ucarecdn.com/1a0f102f-777c-4445-bd7a-2e650a8f9a3b/\"></p><p>Our initial problem in <b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b> was that slot 1 had an unequal probability of getting filled (a\u00a0$ \\frac{2}{5} $ chance). This was because slot 1 had two ways of getting filled: if key <i>k</i> initially hashed to index 1 <i>or</i> index 0, thereby guaranteeing that the key <i>k</i> would also hash to index 1. By designating a <i>different</i> offset for each particular key, however, we no longer have the guarantee that just because key <i>k</i> initially hashed to index 0, it will also hash to index 1. As a result, there is no guarantee for a <i>particular</i> area in the <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> to face a higher probability for keys to hash there and we thus consequently eliminate the inevitable creation of clumps.</p><p>We do what is described above using a technique called <b><span class=\"wysiwyg-color-purple\">Double Hashing</span></b>. The concept behind the collision resolution strategy of <b><span class=\"wysiwyg-color-purple\">Double Hashing</span></b> is to use two hash functions: $ H_1(k) $ to calculate the hashing index and\u00a0$ H_2(k) $ to calculate the <i>offset</i> in the probing sequence.</p><p>More formally,\u00a0$ H_2(k) $ should return an integer value between 1 and <i>M-1</i>, where <i>M</i> is the size of the <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>. You can think of <b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b> as originally having\u00a0$ H_2(k)=1 $ (i.e., we always moved the key 1 index away from its original location). A common choice in <b><span class=\"wysiwyg-color-purple\">Double Hashing</span></b> is to set $  H_2(K)=1+\\frac{K}{M}\\ \\%\\ (M\u22121)  $).</p><p>Below is the pseudocode to implement <b><span class=\"wysiwyg-color-purple\">Double Hashing</span></b> when inserting a key <span class=\"wysiwyg-font-tt\">k</span> into a <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> of capacity <span class=\"wysiwyg-font-tt\">M</span> with a backing array called <span class=\"wysiwyg-font-tt\">arr</span>, using a <b><span class=\"wysiwyg-color-green\">hash function</span></b> <span class=\"wysiwyg-font-tt\">H(k)</span>. Note that the pseudocode for <b><span class=\"wysiwyg-color-purple\">Double Hashing</span></b> is extremely similar to that of <b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b> (the changes are highlighted with the comment <span class=\"wysiwyg-font-tt\">NEW</span>):</p><p></p><pre><code class=\"cpp\"><b>insert_DoubleHash(k): // Insert k using Double Hashing as the collision resolution strategy\n</b>\n    index = H1(k) \n\u2003   offset = H2(k) // NEW\n\n    Loop infinitely:\n\n        // check for duplicate insertions (not allowed)\n        if arr[index] == k:\n            return\n\n        // check if the slot of the array is empty (i.e., it is safe to insert)\n        else if arr[index] == NULL:\n            arr[index] = k\n            return\n\n        // there is a collision, so re-calculate index\n        else:\n            index = (index + offset) % M // NEW\n\n        // we have tried all possible indices and we are now going in a circle\n        if index == H(k):\n            throw an exception OR enlarge table </code></pre><p></p><p><b><span class=\"wysiwyg-color-red\">STOP and Think:</span></b> Is <b><span class=\"wysiwyg-color-purple\">Double Hashing</span></b> an <b>open addressing</b> collision resolution strategy?</p>", "subtitle_files": [], "source": null, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2017-01-05T20:12:30.931944"}