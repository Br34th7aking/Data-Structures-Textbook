{"id": "121059", "block": {"feedback_correct": "", "name": "text", "feedback_wrong": "", "text": "<p>It is also important to note that, in practice, we often use a <b><span class=\"wysiwyg-color-green\">Hash Map</span></b> to\n implement \"one-to-many\" relationships. For example, suppose we want to implement an \"office desk\" system in which each desk drawer has a different label: \"pens\", \"pencils\", \"personal papers\", \"official documents\", etc. Inside each particular drawer, we expect to find office items related to the label. In the \"pens\" drawer, we might expect to find our favorite black fountain pen, a red pen for correcting documents, and that pen we \"borrowed\" from our friend months ago.</p><p>How would we use a <b><span class=\"wysiwyg-color-blue\">Hash Map</span></b> to implement this system? Well, the <i>drawer labels</i> would be considered the  <i>keys</i>, and the <i>drawers</i> with the objects inside them would be considered the corresponding <i>values</i>.</p><p>The C++ code to implement this system would be the following:</p><pre><code class=\"cpp\">unordered_map&lt;string, vector&lt;OfficeSupply&gt;&gt; desk = {\n                { \"pens\", {favPen, redPen, stolenPen} },\n                { \"personal papers\", {personalNote}   }\n};</code></pre><p></p><p>In the <b><span class=\"wysiwyg-color-blue\">Hash Map</span></b> above, we are using <i>keys</i> of type <span class=\"wysiwyg-font-tt\">string</span> and <i>values</i> of type <span class=\"wysiwyg-font-tt\">vector&lt;OfficeSupply&gt;</span> (where <span class=\"wysiwyg-font-tt\">OfficeSupply</span> is a custom class we created). Note that the <i>values</i> inserted into the <b><span class=\"wysiwyg-color-blue\">Hash Map</span></b> are <b>NOT</b> <span class=\"wysiwyg-font-tt\">OfficeSupply</span> objects, but <span class=\"wysiwyg-font-tt\">vector</span>s of <span class=\"wysiwyg-font-tt\">OfficeSupply</span> objects.</p><p>If we now wanted to add a printed schedule to the \"personal papers\" drawer of our desk,\u00a0we would do the following:</p><pre><code class=\"cpp\">desk[\"personal papers\"].push_back(schedule); \n\n/*\n   <b>desk[\"personal papers\"]</b> returns the {personalNote} vector\n   <b>push_back</b> adds a schedule object of type OfficeSupply to the <b>{personalNote}</b> vector\n\n   our hash map now looks like this:\n   {\n       { \"pens\", {favPen, redPen, stolenPen} },\n       { \"personal papers\", {personalNote, schedule} }\n   }\n*/</code></pre><p></p><p><b><span class=\"wysiwyg-color-red\"></span></b><b><span class=\"wysiwyg-color-red\">Note:</span></b> If we wanted to calculate the worst-case time complexity of finding an office supply in our desk, we would now need to take into account the time it takes to find an element in an unsorted <span class=\"wysiwyg-font-tt\">vector</span> (which is an Array List) containing <i>n</i> <span class=\"wysiwyg-font-tt\">OfficeSupply</span> objects, which would be O(<i>n</i>). If we wanted to ensure constant-time access across <span class=\"wysiwyg-font-tt\">OfficeSupply</span> objects, we could also use a <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> instead of a <span class=\"wysiwyg-font-tt\">vector</span>  (yes, we are saying that you can use <span class=\"wysiwyg-font-tt\">unordered_set</span> objects as <i>values</i> in your <span class=\"wysiwyg-font-tt\">unordered_map</span>).</p><p>To easily output which pens we have in our desk, we could use a for-each loop like so:</p><pre><code class=\"cpp\">for (auto pen : desk[\"pens\"]) {\n   cout &lt;&lt; pen &lt;&lt;std::endl;\n}\n/* <b>Output:</b>\n   favPen\n   redPen\n   stolenPen\n*/</code></pre>", "subtitle_files": [], "source": null, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2017-02-14T23:19:59.614162"}