{"block": {"name": "text", "text": "<p>We have now seen why, based on probabilistic analysis, it is important to use a <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> that has a capacity larger than the amount of keys we expect to insert in order to avoid collisions. However, it is important to note that we assumed that our keys were always equally likely to be <b><span class=\"wysiwyg-color-blue\">hashed</span></b> to each of our <i>M</i>\u00a0indices; is this always a fair assumption? <br></p><p>Not <i>really</i>. Take for example the pair of <b><span class=\"wysiwyg-color-green\">hash functions</span></b> $ h(k) = 3k\u00a0\u00a0\u00a0$ and $ H(k) = h(k)\\ \\%\\ M\u00a0\u00a0$, where <i>k</i> is the key, <i>M</i> is the capacity of the <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>, and $ H(k)\u00a0  $ returns the index. As you can see, $ h(k)\u00a0\u00a0$ only returns hash values that are multiples of 3. This shouldn't be a problem, <i>unless</i> the capacity of the\u00a0<b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>, $ M\u00a0\u00a0\u00a0 $, happens to be a multiple of 3 as well (e.g. 6). If that happens, then it will never be possible to have $ H(k)\u00a0\u00a0$ produce an index that <i>isn't</i> also a multiple of 3 because of the nature of the mod operation (e.g. 3(1) % 6 = index 3, 3(2) % 6 = index 0, 3(3) % 6 = index 3, etc.). Consequently, there will be some indices in the <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> that will always be empty (indices 1, 2, 4, and 5 in this example). As a result, by having the keys want to map to the same indices, we face a largely unequal distribution of probabilities across our <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>, and as a result, an increase in collisions.</p><p>What's the solution? We avoid getting trapped in the problem described above by always choosing the <b>capacity of our <span class=\"wysiwyg-color-purple\">Ha</span></b><b><span class=\"wysiwyg-color-purple\">sh Table</span> to be a prime number. </b>By definition, a prime number is a natural number that that has no positive divisors other than 1 and itself. Consequently, modding by a prime number will guarantee that there are no factors, other than 1 and the prime number itself, that will cause the mod function to never return some index values. For example, using the pair of <b><span class=\"wysiwyg-color-green\">hash functions</span></b> above with $ M = 7\u00a0\u00a0\u00a0$ we get the following equal distribution of hash values: 3(1) % 7 = index 3, 3(2) % 7 = index 6, 3(3) % 7 = index 2, 3(4) % 7 = index 5, 3(5) % 7 = index 1, 3(6) % 7 = index 4, 3(7) % 7 = index 0, etc.</p><p>Thus, when we choose a capacity for our <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>, even when we are resizing the <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>,\u00a0we always want to round the capacity to the next nearest prime number in order to ensure that that\u00a0$ H(k) $ doesn't yield an unequal distribution. <i>However</i>, it is very important to note that while prime numbers smooth over a number of flaws, they don't necessarily solve the problem of unequal distributions. In cases where there is still not a good distribution, the\u00a0<i>true</i>\ufeff problem lies in a poorly developed hash function that isn't well distributed in the first place.<br></p>", "video": null, "animation": null, "options": {}, "subtitle_files": [], "source": null, "subtitles": {}, "tests_archive": null, "feedback_correct": "", "feedback_wrong": ""}, "id": "122023", "time": "2017-11-07T22:23:36.426045"}