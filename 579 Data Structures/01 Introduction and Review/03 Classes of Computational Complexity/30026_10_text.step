{"id": "116982", "block": {"feedback_correct": "", "name": "text", "feedback_wrong": "", "text": "<p>As computer scientists, our entire lives are focused on solving computational problems. Even if you choose to tackle problems in other fields (e.g. Biology, Economics, Neuroscience, etc.), you will take the original non-computational problem and model it as a formal computational problem formulation. Your goal will then be to solve the computational problem, and the solution you receive will help give you insight about the original non-computational problem.</p><p>As such, it is important to be aware of how to classify computational problems, and understanding the different classes of computational problems will help you predict how fruitful it would be to try to solve the problems you encounter. For example, say you work as an analyst for a sales company, and your boss hands you a\u00a0list of cities and the distances between each pair of cities, and he asks you to find the\u00a0shortest possible route that visits each city exactly once and returns to the origin city. You might spend hours, days, or even years trying to find a polynomial-time solution to the problem, but had you taken a step back and thought about the problem, you would have realized that this problem is exactly the \"Traveling Salesman Problem\", which is\u00a0<b><span class=\"wysiwyg-color-purple\">NP-Complete</span></b>. Thus, you would have immediately realized that, although possible, it is extremely unlikely that you would be able to find a polynomial-time solution to the problem because of its\u00a0<b><span class=\"wysiwyg-color-purple\">NP-Complete</span></b> status.</p><p>In general, when you face a computational problem, if you can deduce that the problem is not in class\u00a0<b><span class=\"wysiwyg-color-green\">P</span></b>\u00a0(and you are unable to simplify the problem to make it part of class <b><span class=\"wysiwyg-color-green\">\ufeffP</span></b><span class=\"wysiwyg-color-green\"></span>), you typically are forced to choose between one of two options:</p><p></p><ul><li>If the input size you are dealing with is small enough, a non-polynomial-time solution may work fine for you</li><li>If the input size is too large for a non-polynomial-time solution, you can try to create a polynomial-time \"heuristic\" (i.e., an algorithm that isn't guaranteed to give the globally optimal solution, but that does a pretty good job coming close to optimality, hopefully \"good enough\" for your purposes)</li></ul><p>We hope that, now that you have learned about the classes of computational problems, you will be able to think about the problem before blindly jumping in to try to solve it to hopefully save yourself some time and effort.<br></p><p></p><p></p>", "subtitle_files": [], "source": null, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2016-09-05T17:03:53.412081"}