{"time": "2016-09-20T01:27:58.805218", "block": {"options": {}, "feedback_correct": "", "text": "<p>We will now discuss the concepts of <b>references</b> and <b>pointers</b>, and how each concept is used (or not used)<b> </b>in Java and C++.\u00a0 <br></p><p><b>Objects vs. primitives in Java:</b> In Java, the rules for what is stored in a variable are simple: all object variables store <i>object references</i> while primitive type variables store values directly.\u00a0 In Java, assignment is done by value, so when you assign a primitive variable's value to another, the actual value is copied, but when it is an object variable, the reference is copied and you get two references to the same object.</p>\r\n\r\n<p><b>Objects and primitives in C++: </b>In C++ on the other hand, there is no such distinction between object and primitive variables.\u00a0 By default\u00a0 <i>all </i>variables, both primitives and objects, actually hold\u00a0<i>values</i>, NOT object references. C++, like Java, does assignment by value.\u00a0\u00a0 However, this means that in C++ when one object variable is assigned to another, a copy of the entire object is made (like calling <span class=\"wysiwyg-font-tt\">clone</span> in Java). <br></p><p></p><pre><code>Student flo(\"Florence\"); // Creates Student object with name \"Florence\" and stores as variable 'flo'\r\n                         // Note that we do NOT use the keyword 'new' to create the object.  \r\nStudent flo2 = flo;      // flo2 stores a copy of the Student, with the same name</code></pre>\r\n\r\n<img height=\"174\" title=\"Image: https://ucarecdn.com/89e35b9b-f766-4e35-a33d-44c12c95fb0e/\" width=\"660\" alt=\"\" src=\"https://ucarecdn.com/89e35b9b-f766-4e35-a33d-44c12c95fb0e/\">\r\n\r\n<p>So by default, C++ stores variable values directly, no matter their type, and assignments are done by copying the data.\u00a0 This includes passing parameters to a function. \u00a0By default the parameter variables get copies of the data in their arguments. \u00a0</p><p>But what if you want to have two ways to access the same data and avoid this copying-the-data behavior?\u00a0 C++ provides two different concepts that give you related but subtly different ways to do this: references and pointers.\u00a0 <br></p><p><b></b></p><p><b>References in C++: \u00a0\r\n</b>C++ references are NOT the same as\u00a0<span>Java references. \u00a0  Although they\r\n are related, how they are used and their syntax are pretty different, \r\nso it's best if you simply think of them as different concepts.\u00a0</span></p><p>References in C++ are simply aliases for existing variables. \u00a0\r\nWhen you define a reference variable in C++, the variable \r\nis treated exactly as another \r\nname as the variable you set it to. \r\n\r\n\u00a0 Thus when you modify the reference variable, you modify the original \r\nvariable as well without needing to do anything special, as shown in the\r\n example below.<br></p><p>\r\n\r\n</p>\r\n\r\nThe syntax for creating a reference variable in C++ is to place a &amp; after the type name in the variable declaration.\u00a0 \r\nIf <span class=\"wysiwyg-font-tt\">T</span> is some type, then <span class=\"wysiwyg-font-tt\">T&amp;</span> is the syntax to declare a reference to a <span class=\"wysiwyg-font-tt\">T</span> variable.\u00a0\u00a0 Reference declarations must be combined with assignments except in the case of function parameters (discussed further on the next page).\u00a0 <br><br>\r\n\r\n<pre><code class=\"cpp\">Student lloyd(\"Lloyd\"); // creates Student object with name \"Lloyd\" and stores as variable 'lloyd'\r\nStudent &amp; ref = lloyd;  // creates reference to 'lloyd' called 'ref'\r\nStudent harry(\"Harry\"); // creates Student object with name \"Harry\" and stores as variable 'harry'\r\n</code><b></b></pre>\r\n\r\nThe picture below shows what the objects and variables look like so far:<br>[PICTURE OF WHAT THIS LOOKS LIKE SO FAR]\r\n<p>Now we can execute the following lines:</p>\r\n<pre><code class=\"cpp\">ref = harry;            // 'ref' is now a copy of 'harry', so 'lloyd' is ALSO now a copy of 'harry'\r\ncout &lt;&lt; lloyd.name;     // this would print \"Harry\"</code></pre>\r\n\r\n<p></p><p>And the picture below shows the result.</p><p>[PICTURE HERE]<br></p>\r\n\r\n<p>There are two main uses for C++ references: parameter passing, and\u00a0<span>aliasing long variable names.\u00a0 In many cases it's extremely useful not to make copies of objects when they are passed to functions, either because you want the function to be able to modify the data in the object, or because you want to avoid wasting time with the\u00a0</span><span>copy.\u00a0 Parameter passing will be discussed in more detail in the next page.</span></p>\r\n\r\n<p>Finally, note that this is an overly simple explanation of references.\u00a0 In particular, C++11 and on has a notion of lvalue references (which are what we showed above) and rvalue references.\u00a0 Don't worry about these subtleties if you don't want to. Throughout this book we'll use only \"classic\" (lvalue) references like what we described above.\u00a0 Though if you want to learn more, there are certainly plenty of websites that would be happy to explain this in more detail!</p>\r\n\r\n\r\n<p></p><p><b>Pointers in C++: </b>Pointers in C++ are actually quite similar <span>to references in Java.\u00a0 They are variables that store the memory address of some data, instead of storing the data directly.\u00a0 That is, their\u00a0</span><i>value</i><span> is a memory address.\u00a0</span></p><p><span>\r\n\r\n</span></p><p>If <span class=\"wysiwyg-font-tt\">T</span>\u00a0is some type, then <span class=\"wysiwyg-font-tt\">T*</span>\u00a0is the syntax to declare a pointer to a <span class=\"wysiwyg-font-tt\">T</span>\u00a0variable. A pointer variable can be initialized with <span class=\"wysiwyg-font-tt\">NULL</span>, with the value of another pointer variable, with the memory address of another variable, or with a call to <span class=\"wysiwyg-font-tt\">new</span>. The memory address of a variable can be attained by placing the <span class=\"wysiwyg-font-tt\">&amp;</span>\u00a0symbol before the variable name. To access the object to which a pointer points, you must \"dereference\" the pointer by placing the <span class=\"wysiwyg-font-tt\">*</span>\u00a0symbol before the variable name. To access an instance variable of the o</p><p>bject to which a pointer points, you can either dereference the pointer and access the instance variable using the <span class=\"wysiwyg-font-tt\">.</span>\u00a0symbol as normal, or you can use the <span class=\"wysiwyg-font-tt\">-&gt;</span>\u00a0operator on the pointer directly (which is the more conventional way).</p><p></p><pre><code class=\"cpp\">Student lloyd(\"Lloyd\");                // initialize Student object\r\nStudent* harry = new Student(\"Harry\"); // initialize Student pointer\r\nStudent* ptr1 = &amp;lloyd;                // initialize ptr1 to store the address of 'lloyd'\r\nStudent* ptr2 = harry;                 // initialize Student pointer pointing to same object as 'harry'\r\ncout &lt;&lt; (*ptr1).name;                  // prints \"Lloyd\"\r\ncout &lt;&lt; ptr2-&gt;name;                    // prints \"Harry\"</code></pre><p></p><p>Beware of the nomenclature used with pointers. The nomencl</p><pre></pre><p>ature goes as follows: we can either say that a pointer <i>points to</i>\u00a0an object, or we can say that a pointer <i>stores the address</i>\u00a0of an object. For example, in the code above, look at the line where we initialize <span class=\"wysiwyg-font-tt\">ptr2</span>. After doing the assignment <span class=\"wysiwyg-font-tt\">ptr2 = harry</span>, we can either say \"<span class=\"wysiwyg-font-tt\">ptr2</span>\u00a0<i>points to</i>\u00a0<span class=\"wysiwyg-font-tt\">harry</span>\", or we can say \"<span class=\"wysiwyg-font-tt\">ptr2</span>\u00a0<i>stores the address</i>\u00a0of <span class=\"wysiwyg-font-tt\">harry</span>\". However, it would be inaccurate to say that \"<span class=\"wysiwyg-font-tt\">ptr2</span>\u00a0<i>points to the address of</i>\u00a0<span class=\"wysiwyg-font-tt\">harry</span>\". The reason why we're bringing attention to this seemingly meaningless formality is because, in C++, you can actually have a pointer that points to another pointer! For example, the following lines of code are perfectly valid, and the notion of a \"pointer to a pointer\" can actually be useful in many contexts:</p><p></p><p></p><pre><code class=\"cpp\">Student lloyd(\"Lloyd\");   // initialize Student object\r\nStudent* dumb = &amp;lloyd;   // initialize Student pointer to store address of 'lloyd'\r\nStudent** dumber = &amp;dumb; // i</code><code class=\"cpp\">nitialize Student pointer pointer to store address of 'dumb'</code></pre><p></p><p>Also, in Java, since all non-primitive data types function in a manner similar to C++ pointers, it was very easy to define a class and have it contain a reference to another object of the same class. However, in C++, because variables hold <i>objects</i>\u00a0by default, a class cannot have member variables of its own type. For example, imagine we are designing a <span class=\"wysiwyg-font-tt\">Human</span>\u00a0class, and one of the member variables is <span class=\"wysiwyg-font-tt\">parent</span>, which represents this <span class=\"wysiwyg-font-tt\">Human</span>\u00a0object's parent. If we were to make <span class=\"wysiwyg-font-tt\">parent</span>\u00a0be of type <span class=\"wysiwyg-font-tt\">Human</span>, when we try to create a <span class=\"wysiwyg-font-tt\">Human</span>\u00a0object, it will automatically try to create <span class=\"wysiwyg-font-tt\">parent</span>, which is also of type <span class=\"wysiwyg-font-tt\">Human</span>. When it tries to create <span class=\"wysiwyg-font-tt\">parent</span>, the resulting <span class=\"wysiwyg-font-tt\">Human</span>\u00a0object will also automatically to create its own<span class=\"wysiwyg-font-tt\">\u00a0parent</span>. This cycle of recursion would be infinite, so the code would simply crash. Instead, we need <span class=\"wysiwyg-font-tt\">parent</span>\u00a0to be of type <span class=\"wysiwyg-font-tt\">Human*</span>.</p>\r\n\r\n<br><p></p><p><b>Object creation (and destruction):</b> In Java, to invoke an object's constructor, you must use the new operator.\u00a0 This will create a new object (on the heap) and return a reference to this newly created object.\u00a0\u00a0 On the other hand in C++, you often do <i>not</i> use the new operator to call the object's constructor and create a new instance of the object.\u00a0\u00a0 You simply supply the construction parameters after the variable name.\u00a0 This is called creating an object using \"static\" creation, or creating the object \"statically\".\u00a0 As discussed above, this will create a new object whose value (and <i>not</i> a Java-style reference) is stored in the variable to which it is assigned.\u00a0\u00a0</p><p>In Java, all objects are destroyed automatically by the garbage collector when there is no longer a way to reach them.\u00a0 In C++, objects created statically are automatically destroyed (via a call to their destructor, <br></p><p></p><pre><code class=\"cpp\">Turtle harry(0,0);\r\nTurtle lloyd = harry;\r\nharry.move(1,1); // this will only modify harry, NOT lloyd!</code></pre><p></p><p><b>References:</b> When you define a reference variable in C++, the functionality is NOT the same as in Java. In C++, a reference is treated exactly as another name as the variable you set it to. If <span class=\"wysiwyg-font-tt\">T</span> is some type, then <span class=\"wysiwyg-font-tt\">T&amp;</span> is the syntax to declare a reference to a <span class=\"wysiwyg-font-tt\">T</span> variable. Thus, when you modify the reference variable, you modify the original variable as well.</p><p></p><pre><code class=\"cpp\">Student lloyd(\"Lloyd\"); // creates Student object with name \"Lloyd\" and stores as variable 'lloyd'\r\nStudent &amp; ref = lloyd;  // creates reference to </code><code class=\"cpp\">'lloyd' called 'ref'\r\nStudent harry(\"Harry\"); // creates Student object with name \"Harry\" and stores as variable 'harry'\r\nref = harry;            // 'ref' is now a copy of 'harry', so 'lloyd' is ALSO now a copy of 'harry'\r\ncout &lt;&lt; lloyd.name;     // this would print \"Harry\"</code></pre><p></p><p><b>Pointers:</b> To obtain the functionality seen in Java variables, one needs to use C++ pointers. I</p>", "animation": null, "video": null, "source": null, "subtitles": {}, "subtitle_files": [], "name": "text", "tests_archive": null, "feedback_wrong": ""}, "id": "95893"}