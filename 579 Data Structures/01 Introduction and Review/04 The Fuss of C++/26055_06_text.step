{"id": "95893", "block": {"subtitles": {}, "source": null, "video": null, "feedback_wrong": "", "options": {}, "animation": null, "text": "<p>We will now discuss the differences between <b>objects</b>, <b>references</b>, and <b>pointers </b>in Java and C++.</p><p><b>Objects:</b> Recall that, in Java, all object variables are\u00a0<i>object references</i>. In C++, however, all object variables actually hold\u00a0<i>values</i>, NOT object references. When one object is assigned to another, a copy of the actual values is made (like calling <span class=\"wysiwyg-font-tt\">clone</span> in Java). This is important when you want to write functions that modify the objects passed in, as you must make sure to call by reference (and not by value). Also, the <span class=\"wysiwyg-font-tt\">new</span> operator is never used when constructing objects in C++: you simply supply the construction parameters after the variable name.</p><p></p><pre><code class=\"cpp\">Turtle harry(0,0);\nTurtle lloyd = harry;\nharry.move(1,1); // this will only modify harry, NOT lloyd!</code></pre><p></p><p><b>References:</b> When you define a reference variable in C++, the functionality is NOT the same as in Java. In C++, a reference is treated exactly as another name as the variable you set it to. If <span class=\"wysiwyg-font-tt\">T</span> is some type, then <span class=\"wysiwyg-font-tt\">T&amp;</span> is the syntax to declare a reference to a <span class=\"wysiwyg-font-tt\">T</span> variable. Thus, when you modify the reference variable, you modify the original variable as well.</p><p></p><pre><code class=\"cpp\">Student lloyd(\"Lloyd\"); // creates Student object with name \"Lloyd\" and stores as variable 'lloyd'\nStudent &amp; ref = lloyd;  // creates reference to 'lloyd' called 'ref'\nStudent harry(\"Harry\"); // creates Student object with name \"Harry\" and stores as variable 'harry'\nref = harry;            // 'ref' is now a copy of 'harry', so 'lloyd' is ALSO now a copy of 'harry'\ncout &lt;&lt; lloyd.name;     // this would print \"Harry\"</code></pre><p></p><p><b>Pointers:</b> To obtain the functionality seen in Java variables, one needs to use C++ pointers. If <span class=\"wysiwyg-font-tt\">T</span> is some type, then <span class=\"wysiwyg-font-tt\">T*</span> is the syntax to declare a pointer to a <span class=\"wysiwyg-font-tt\">T</span> variable. A pointer variable can be initialized with <span class=\"wysiwyg-font-tt\">NULL</span>, with another pointer variable (or the memory address of an object variable), or with a call to <span class=\"wysiwyg-font-tt\">new</span>. The memory address of an object variable can be attained by placing the <span class=\"wysiwyg-font-tt\">&amp;</span>\u00a0symbol before the variable name. To access the object to which a pointer points, you must \"dereference\" the pointer by placing the <span class=\"wysiwyg-font-tt\">*</span> symbol before the variable name. To access an instance variable of the object to which a pointer points, you can either dereference the pointer and access the instance variable using the <span class=\"wysiwyg-font-tt\">.</span> symbol as normal, or you can use the <span class=\"wysiwyg-font-tt\">-&gt;</span> operator on the pointer directly (which is the more conventional way).</p><p></p><pre><code class=\"cpp\">Student lloyd(\"Lloyd\");                // initialize Student object\nStudent* harry = new Student(\"Harry\"); // initialize Student pointer\nStudent* ptr1 = &amp;lloyd;                // initialize ptr1 to store the address of 'lloyd'\nStudent* ptr2 = harry;                 // initialize Student pointer pointing to same object as 'harry'\ncout &lt;&lt; (*ptr1).name;                  // prints \"Lloyd\"\ncout &lt;&lt; ptr2-&gt;name;                    // prints \"Harry\"</code></pre><p></p><p>Beware of the nomenclature used with pointers. The nomenclature goes as follows: we can either say that a pointer <i>points to</i> an object, or we can say that a pointer\u00a0<i>stores the address</i> of an object. For example, in the code above, look at the line where we initialize <span class=\"wysiwyg-font-tt\">ptr2</span>. After doing the assignment <span class=\"wysiwyg-font-tt\">ptr2 = harry</span>, we can either say \"<span class=\"wysiwyg-font-tt\">ptr2</span> <i>points to</i> <span class=\"wysiwyg-font-tt\">harry</span>\", or we can say \"<span class=\"wysiwyg-font-tt\">ptr2</span> <i>stores the address</i> of <span class=\"wysiwyg-font-tt\">harry</span>\". However, it would be inaccurate to say that \"<span class=\"wysiwyg-font-tt\">ptr2</span> <i>points to the address of</i> <span class=\"wysiwyg-font-tt\">harry</span>\". The reason why we're bringing attention to this seemingly meaningless formality is because, in C++, you can actually have a pointer that points to another pointer! For example, the following lines of code are perfectly valid, and the notion of a \"pointer to a pointer\" can actually be useful in many contexts:</p><p></p><p></p><pre><code class=\"cpp\">Student lloyd(\"Lloyd\");   // initialize Student object\nStudent* dumb = &amp;lloyd;   // initialize Student pointer to store address of 'lloyd'\nStudent** dumber = &amp;dumb; // initialize Student pointer pointer to store address of 'dumb'</code></pre><p></p><p>Also, in Java, since all non-primitive data types function in a manner similar to C++ pointers, it was very easy to define a class and have it contain a reference to another object of the same class. However, in C++, because variables hold\u00a0<i>objects</i> by default, a class cannot have member variables of its own type. For example, imagine we are designing a <span class=\"wysiwyg-font-tt\">Human</span> class, and one of the member variables is <span class=\"wysiwyg-font-tt\">parent</span>, which represents this <span class=\"wysiwyg-font-tt\">Human</span> object's parent. If  we were to make <span class=\"wysiwyg-font-tt\">parent</span> be of type <span class=\"wysiwyg-font-tt\">Human</span>, when we try to create a <span class=\"wysiwyg-font-tt\">Human</span> object, it will automatically try to create <span class=\"wysiwyg-font-tt\">parent</span>, which is also of type <span class=\"wysiwyg-font-tt\">Human</span>. When it tries to create <span class=\"wysiwyg-font-tt\">parent</span>, the resulting <span class=\"wysiwyg-font-tt\">Human</span> object will also automatically to create its own<span class=\"wysiwyg-font-tt\"> parent</span>. This cycle of recursion would be infinite, so the code would simply crash. Instead, we need <span class=\"wysiwyg-font-tt\">parent</span> to be of type <span class=\"wysiwyg-font-tt\">Human*</span>.</p>", "feedback_correct": "", "tests_archive": null, "subtitle_files": [], "name": "text"}, "time": "2016-09-03T01:05:28.327151"}