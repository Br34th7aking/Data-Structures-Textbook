{"block": {"video": null, "tests_archive": null, "feedback_correct": "", "animation": null, "text": "<p>We have now discussed yet another data structure that can be used to implement a lexicon: the\u00a0<b><span class=\"wysiwyg-color-blue\">Ternary Search Tree</span></b>. Because of the\u00a0<b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b> properties of the\u00a0<b><span class=\"wysiwyg-color-blue\">Ternary Search Tree</span></b>, the\u00a0<b><i>average</i>-case time complexity</b> to find, insert, and remove elements is\u00a0<b>O(log\u00a0<i>n</i>)</b>\u00a0as well as a\u00a0<b><i>worst</i>-case time complexity</b> of\u00a0<b>O(<i>n</i>)</b>. Also, because inserting elements in a\u00a0<b><span class=\"wysiwyg-color-blue\">Ternary Search Tree</span></b> is very similar to inserting elements in a\u00a0<b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b>, the structure of a\u00a0<b><span class=\"wysiwyg-color-blue\">Ternary Search Tree</span></b> (i.e., the balance), and as a result, the performance of a\u00a0<b><span class=\"wysiwyg-color-blue\">Ternary Search Tree</span></b>, largely depends on the order in which we insert elements. As a result, if the words we will be inserting are known in advance, it is common practice to randomly shuffle the words before inserting them to help improve the balance of the tree.</p><p>Because of the structure of a\u00a0<b><span class=\"wysiwyg-color-blue\">Ternary Search Tree</span></b>,\u00a0we can easily and efficiently iterate through the words in the lexicon in alphabetical order (either ascending or descending order) by performing a <b><span class=\"wysiwyg-color-green\">pre-order traversal</span></b>. We can use this exact <b><span class=\"wysiwyg-color-green\">pre-order traversal</span></b>\u00a0technique to create <b>auto-complete</b>\u00a0functionality for our lexicon.<br></p><p><b><span class=\"wysiwyg-color-blue\">Ternary Search Trees</span></b> are a bit slower than\u00a0<b><span class=\"wysiwyg-color-red\">Multiway Tries</span></b>, but they are <i>significantly</i> more <b>space-efficient</b>, and as a result, they are often chosen as the data structure of choice when people implement lexicons. In short,\u00a0<b><span class=\"wysiwyg-color-blue\">Ternary Search Trees</span></b> give us a nice middle-ground between the\u00a0<b>time-efficiency</b> of a\u00a0<b><span class=\"wysiwyg-color-red\">Multiway Trie</span></b> and the\u00a0<b>space-efficiency</b> of a\u00a0<b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b>.<br></p>", "subtitle_files": [], "subtitles": {}, "feedback_wrong": "", "name": "text", "source": null, "options": {}}, "id": "122685", "time": "2016-09-14T00:14:05.610341"}