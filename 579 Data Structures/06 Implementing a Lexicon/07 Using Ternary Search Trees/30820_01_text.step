{"id": "118226", "block": {"feedback_correct": "", "name": "text", "feedback_wrong": "", "text": "<p>Thus far, we have discussed implementing a lexicon using a few different data structures, and we discussed their respective pros and cons. Recall that the \"best\" data structures we discussed for this task were the following, where <i>n</i> is the number of words in our lexicon and\u00a0<i>k</i> is the length of the longest word:</p><p></p><ul><li>A\u00a0<b>balanced <span class=\"wysiwyg-color-green\">Binary Search Tree</span></b> (such as an\u00a0<b><span class=\"wysiwyg-color-purple\">AVL Tree</span></b> or a\u00a0<b><span class=\"wysiwyg-color-red\">Red-Black Tree</span></b>), which is the <b>most space-efficient</b> we can get, but which has a\u00a0<b>worst-case time complexity</b> of\u00a0<b>O(log\u00a0<i>n</i>)</b>. A\u00a0<b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b> has the added benefit of being able to iterate over the elements of the lexicon in\u00a0<b>alphabetical order</b></li><li>A\u00a0<b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>, which is not\u00a0<i>quite</i> as space-efficient as a\u00a0<b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b>\u00a0(but not\u00a0<i>too</i> bad), and which has an\u00a0<b>average-case time complexity</b> of\u00a0<b>O(<i>k</i>)</b>\u00a0(when we take into account the time it takes to compute a hash value of a string of length <i>k</i>) and a <b>worst-case time complexity</b> of\u00a0<b>O(<i>n</i>)</b>. Unfortunately, the elements of a\u00a0<b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> are\u00a0<b>unordered</b>, so there is no clean way of iterating through the elements of our lexicon in a meaningful order</li><li>A\u00a0<b><span class=\"wysiwyg-color-red\">Multiway Trie</span></b>, which is the most\u00a0<b>time-efficient</b> we can get in the\u00a0<b>worst case</b>,\u00a0<b>O(<i>k</i>)</b>, but which is\u00a0<i><b>extremely</b></i><b> inefficient memory-wise</b>. A\u00a0<b><span class=\"wysiwyg-color-red\">Multiway Trie</span></b> has the added benefit of being able to iterate over the elements of the lexicon in\u00a0<b>alphabetical order</b> as well as the ability to perform\u00a0<b>auto-complete</b> by performing a simple Depth First Search</li></ul><p></p><p>In this section, we will discuss the\u00a0<b><span class=\"wysiwyg-color-blue\">Ternary Search Tree</span></b>, which is a data structure that serves as a middle-ground between the\u00a0<b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b> and the\u00a0<b><span class=\"wysiwyg-color-red\">Multiway Trie</span></b>. The <b><span class=\"wysiwyg-color-blue\">Ternary Search Tree</span></b> is a type of trie, structured in a fashion similar to\u00a0<b><span class=\"wysiwyg-color-green\">Binary Search Trees</span></b>, that\u00a0was first described in 1979 by\u00a0Jon Bentley and James Saxe.</p><p><img width=\"439\" alt=\"\" height=\"486\" src=\"https://ucarecdn.com/d252f0f2-a38a-47d1-ab61-94e9524f148f/\"></p><p class=\"wysiwyg-text-align-center\"><b>Figure:</b>\ufeff Jon Bentley<br></p>", "subtitle_files": [], "source": null, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2016-09-07T23:40:50.911888"}