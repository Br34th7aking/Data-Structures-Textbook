{"id": "121820", "time": "2016-09-01T21:53:14.160557", "block": {"subtitle_files": [], "feedback_wrong": "", "options": {}, "name": "text", "subtitles": {}, "tests_archive": null, "source": null, "text": "<p>Abstractly, when we draw\u00a0<b><span class=\"wysiwyg-color-red\">Multiway Tries</span></b>, for any given node, we only depict the outgoing edges that we actually see, and we completely omit any edges that we don't observe. For example, below is an example of a\u00a0<b><span class=\"wysiwyg-color-red\">Multiway Trie</span></b> with\u00a0\u03a3 = {A, C, G, T} which stores the words TGA, TAA, and TAG (the three STOP codons of protein translation as they appear in DNA, for those who are interested):</p><p><img alt=\"\" src=\"https://ucarecdn.com/8fd9215c-e2c6-4dc5-9574-68a14e038ef9/\"></p><p>Based on this representation, intuitively, we might think that each Node object should have a list of edges. Recall that our motivation for discussing a\u00a0<b><span class=\"wysiwyg-color-red\">Multiway Trie</span></b> was to achieve a worst-case time complexity of O(<i>k</i>), where <i>k</i> is the length of the longest word,\u00a0to find, insert, and remove words, which would mean that each individual edge traversal should be O(1) (and we do <i>k</i> O(1) edge traversals, one for each letter of our word, resulting in a O(<i>k</i>) time complexity overall). However, if we were to store the edges as a list, we would unfortunately have to perform a O(|\u03a3|) search operation to find a given edge, where |\u03a3| is the size of our alphabet.</p><p>To combat this and maintain the O(1) edge traversals, we instead allocate space for\u00a0<i>all</i> of the edges that can come out of a given node right off the bat in the form of an array. We fill in the slots for edges that we use, and we leave the slots for unused edges empty. This way, if we're at some node\u00a0<i>u</i>, if we're given some character\u00a0<i>c</i>, we can find the edge coming out of\u00a0<i>u</i> that is labeled by\u00a0<i>c</i> in O(1) time by simply going to the corresponding slot of the array of edges. This O(1) time complexity to find an edge given a character\u00a0<i>c</i> assumes that we have a way of mapping\u00a0<i>c</i> to an index in our array of edges in O(1) time, which is a safe assumption. For example, if\u00a0\u03a3 = {a, ..., z}, in C++, we could do something like this:</p><p></p><pre><code class=\"cpp\">// this simple C++ function maps 'a' to 0, 'b' to 1, ..., 'z' to 25 in O(1) time\nint index(char c) {\n    return (int)c - (int)'a'; // subtract the ASCII value of the char 'a' from that of c\n}</code></pre><p></p><p>Below is a diagram representing the same\u00a0<b><span class=\"wysiwyg-color-red\">Multiway Trie</span></b> as above, but in a fashion more similar to the actual implementation. Note that, in the example, just like before, we are using the DNA alphabet for the sake of simplicity (i.e.,\u00a0\u03a3 = {A, C, G, T}),\u00a0<i>not</i> the English alphabet.</p><p><img alt=\"\" src=\"https://ucarecdn.com/6faf9496-14b9-4323-805d-7c5c66d92072/\" title=\"Image: https://ucarecdn.com/6faf9496-14b9-4323-805d-7c5c66d92072/\"></p><p>Of course, the more implementation-like representation of\u00a0<b><span class=\"wysiwyg-color-red\">Multiway Tries</span></b> is a bit harder to read, which is why we draw them the more abstract way (as opposed to a bunch of arrays of edges). We will continue to draw them using the abstract way, but be sure to never forget what they actually look like behind-the-scenes.</p>", "feedback_correct": "", "video": null, "animation": null}}