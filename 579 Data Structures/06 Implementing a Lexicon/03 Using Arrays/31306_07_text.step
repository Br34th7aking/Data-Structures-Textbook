{"time": "2016-09-05T12:33:02.823420", "block": {"tests_archive": null, "animation": null, "feedback_correct": "", "subtitles": {}, "source": null, "text": "<p>As you can see, we improved our performance by using an\u00a0<b><span class=\"wysiwyg-color-green\">Array</span></b> to implement our lexicon instead of a\u00a0<b><span class=\"wysiwyg-color-blue\">Linked List</span></b>. We wanted to be able to exploit the\u00a0<b>Binary Search</b> algorithm, so we forced ourselves to keep our\u00a0<b><span class=\"wysiwyg-color-green\">Array</span> sorted</b>.</p><p>By keeping the elements in our\u00a0<b><span class=\"wysiwyg-color-green\">Array</span></b> sorted, we are able to use Binary Search to <b>find</b> elements, which, as you should hopefully recall, has a\u00a0<b>worst-case time complexity</b> of\u00a0<b>O(log\u00a0<i>n</i>)</b>. However, because we need to keep our elements sorted to be able to do Binary Search, the <b>time complexity</b>\ufeff of\u00a0<b>inserting</b> and\u00a0<b>removing</b> elements is\u00a0<b>O(<i>n</i>)</b> in the\u00a0<b>worst case</b>. This is because, even if we do a Binary Search to\u00a0<i>find</i> the insertion point, we might have to move over O(<i>n</i>) elements to make room for our new element in the worst case.</p><p>Also, by keeping the elements in our\u00a0<b><span class=\"wysiwyg-color-green\">Array</span></b> sorted, if we were to iterate over the elements of the list, the elements <i>would</i>\u00a0be in a meaningful order: they would be in <b>alphabetical order</b>. Also, we could choose if we wanted to iterate in <i>ascending\u00a0</i>alphabetical order or in <i>descending</i>\u00a0alphabetical order by simply choosing from which end of the\u00a0<b><span class=\"wysiwyg-color-green\">Array</span></b>\u00a0we wanted to begin our iteration.</p><p>In terms of memory efficiency, with\u00a0<b>Dynamic <span class=\"wysiwyg-color-green\">Arrays</span></b>, as we grow the <b><span class=\"wysiwyg-color-green\">Array</span></b>, we typically double its size, meaning at any point in time, we will have allocated at most 2<i>n</i> slots, giving this approach a <b>space complexity</b> of\u00a0<b>O(<i>n</i>)</b>, which is as good as we can get if we want to store all\u00a0<i>n</i> elements.</p><p>We started off by saying that insert and remove operations are pretty uncommon in this specific application, so even though both operations are O(<i>n</i>) in this implementation, we find them acceptable. However, our motivation in this entire text is speed, so like always, we want to ask ourselves: can we go even\u00a0<i>faster</i>?\u00a0In the next section, we will discuss an even better approach for implementing our lexicon ADT: the\u00a0<b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b>.</p>", "options": {}, "subtitle_files": [], "name": "text", "video": null, "feedback_wrong": ""}, "id": "121527"}