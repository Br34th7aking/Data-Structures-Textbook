{"block": {"feedback_wrong": "", "subtitles": {}, "animation": null, "name": "text", "text": "<p>As you can see, we improved our performance even further by using a <b>self-balancing</b>\u00a0<b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b>\u00a0to implement our lexicon. By doing so, the <b>worst-case time complexity</b> of\u00a0<b>finding</b>,\u00a0<b>inserting</b>, and\u00a0<b>removing</b> elements is\u00a0<b>O(log\u00a0<i>n</i>)</b>.</p><p>Also, because we are using a\u00a0<b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b> to store our words, if we were to perform an\u00a0<b><span class=\"wysiwyg-color-blue\">in-order traversal</span></b> on the tree, we would iterate over the elements in a meaningful order: they would be in\u00a0<b>alphabetical order</b>. Also, we could choose if we wanted to iterate in <i>ascending\u00a0</i>alphabetical order or in <i>descending</i>\u00a0alphabetical order by simply changing the order in which we recurse during the in-order traversal:</p><p></p><pre><code class=\"cpp\"><b>ascendingInOrder(node):  // Recursively iterate over the words in ascending order\n</b>    ascendingInOrder(node.leftChild)   // Recurse on left child\n    output node.word                   // Visit current node\n    ascendingInOrder(node.rightChild)  // Recurse on right child\n</code></pre><p></p><p></p><pre><code class=\"cpp\"><b>descendingInOrder(node): // Recursively iterate over the words in descending order\n</b>    descendingInOrder(node.rightChild) // Recurse on right child\n    output node.word                   // Visit current node\n    descendingInOrder(node.leftChild)  // Recurse on left child</code></pre><p></p><p>In terms of memory efficiency, a\u00a0<b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b> has exactly one node for each word, meaning the <b>space complexity</b> is <b>O(</b><i><b>n</b></i><b>)</b>, which is as good as we can get if we want to store all\u00a0<i>n</i> elements.</p><p>Of course, yet again, it is impossible to satisfy a computer scientist, so like always, we want to ask ourselves: can we go even\u00a0<i>faster</i>? Note that, up until now, every approach we described had a time complexity that depended on\u00a0<i>n</i>, the number of elements in the data structure. In other words, as we insert more and more words into our data structure, the three operations we described take longer and longer. In the next section, we will discuss another good approach for implementing our lexicon: the\u00a0<b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> (as well as the\u00a0<b><span class=\"wysiwyg-color-green\">Hash Map</span></b>\u00a0to implement a dictionary.</p>", "tests_archive": null, "source": null, "subtitle_files": [], "options": {}, "feedback_correct": "", "video": null}, "id": "121608", "time": "2016-09-06T23:48:41.906575"}