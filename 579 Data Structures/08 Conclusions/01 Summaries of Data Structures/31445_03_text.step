{"block": {"animation": null, "source": null, "text": "<h1>Skip List</h1><p><b>Summary Description</b></p><ul><li>Skip Lists are like Linked Lists, except every node has multiple <i>layers</i>, where each layer is a forward pointer</li><li>We denote the number of layers a given node has as the node's\u00a0<i>height</i></li><li>We typically choose a maximum height,\u00a0<i>h</i>, that any node in our Skip List can have, where\u00a0<i>h</i> &lt;&lt;\u00a0<i>n</i> (the total number of nodes)</li><li>We are able to \"skip\" over multiple nodes in our searches (unlike in Linked Lists, where we had to traverse through the nodes one-by-one), which allows us to mimic Binary Search when searching for an element in the list</li><li>To determine the height of a new node, we repeatedly flip a weighted coin that has probability\u00a0<i>p</i> to land on heads, and we keep adding layers to the new node until we encounter our first tails</li><li>Just like with a Linked List, to insert or remove an element, we first run the regular find algorithm and then perform a single O(<i>h</i>) operation to fix pointers<br></li></ul><p></p><p><br></p><h2>Time/Space Complexities of a Skip List</h2><p><b>Worst-Case Time Complexity</b></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(<i>n</i>)</b> \u2014 If all of our nodes have the same height (low probability, but possible), we just have a regular Linked List</li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(<i>n</i>)</b>\u00a0\u2014 Perform find, which is O(<i>n</i>) in the worst case, and then perform a single O(<i>h</i>) pointer fix (<i>h</i> &lt;&lt;\u00a0<i>n</i>)<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(<i>n</i>)</b>\u00a0\u2014 Perform find, which is O(<i>n</i>) in the worst case, and then perform a single O(<i>h</i>) pointer fix (<i>h</i> &lt;&lt; <i>n</i>)<br></li></ul><p><b>Average-Case Time Complexity</b></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(log <i>n</i>)</b>\u00a0\u2014 The formal proof is too complex for a summary slide</li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(log <i>n</i>)</b>\u00a0\u2014\u00a0Perform find, which is O(log <i>n</i>) in the average case, and then perform a single O(<i>h</i>) pointer fix (<i>h</i> &lt;&lt; <i>n</i>)<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(log <i>n</i>)</b>\u00a0\u2014\u00a0Perform find, which is O(log <i>n</i>) in the average case, and then perform a single O(<i>h</i>) pointer fix (<i>h</i> &lt;&lt; <i>n</i>)<br></li></ul><p><b>Best-Case Time Complexity</b><br></p><p></p><ul><li><b><span class=\"wysiwyg-color-green\">Find:</span> O(1)</b>\u00a0\u2014 If our query is the first element we check<br></li><li><b><span class=\"wysiwyg-color-purple\">Insert:</span> O(<i>h</i>)</b>\u00a0\u2014 Perform find, which is O(1)\u00a0in the best case, and then perform a single O(<i>h</i>) pointer fix (<i>h</i> &lt;&lt; <i>n</i>)<br></li><li><b><span class=\"wysiwyg-color-red\">Remove:</span> O(<i>h</i>)</b>\u00a0\u2014 Perform find, which is O(1) in the best case, and then perform a single O(<i>h</i>) pointer fix (<i>h</i> &lt;&lt; <i>n</i>)</li></ul><p><b>Space Complexity</b><br></p><p></p><ul><li><b>Worst-Case: O(<i>n</i>\u00a0log <i>n</i>)</b>\u00a0\u2014 The formal proof is too complex for a summary slide</li><li><b>Average-Case: O(log\u00a0<i>n</i>)</b>\ufeff\u00a0\u2014 The formal proof is too complex for a summary slide<br></li></ul><p></p>", "feedback_correct": "", "feedback_wrong": "", "video": null, "name": "text", "subtitles": {}, "subtitle_files": [], "options": {}, "tests_archive": null}, "id": "124150", "time": "2016-09-20T01:15:33.088866"}