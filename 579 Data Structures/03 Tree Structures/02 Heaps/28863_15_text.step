{"id": "117410", "block": {"feedback_wrong": "", "tests_archive": null, "text": "<p>We have now very efficiently solved our initial problem of implementing a queue-like data type that can take into account a sense of ordering (based on \"priority\") of the elements it contains. We first described the\u00a0<b>Priority Queue</b> ADT, which defined the functions we needed in such a data type.</p><p>Then, we dove into implementation specifics by discussing the\u00a0<b>Heap</b> data structure, which is almost always used to implement a\u00a0<b>Priority Queue</b>.\u00a0<span>Because of the constraints of the\u00a0</span><b>Heap</b><span> data structure, we are able to guarantee a </span><b>worst-case</b><span> time complexity of </span><b>O(log\u00a0</b><i><b>n</b></i><b>)</b><span> for both </span><b>inserting</b><span> and </span><b>removing</b><span> elements, as well as a\u00a0</span><b>O(1)</b><span> worst-case time complexity for\u00a0</span><b>peeking</b><span>\ufeff at the highest-priority element.</span></p><p>In the next sections of this chapter, we will continue to explore other types of binary trees, and it will hopefully become clear why we would want to have so many different data structures and ADTs in our arsenal of tools.</p>", "subtitle_files": [], "options": {}, "name": "text", "subtitles": {}, "animation": null, "feedback_correct": "", "source": null, "video": null}, "time": "2016-09-04T00:46:47.115379"}