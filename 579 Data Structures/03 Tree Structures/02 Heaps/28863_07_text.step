{"id": "115257", "time": "2016-09-09T16:57:06.560017", "block": {"subtitle_files": [], "text": "<p>The first heap algorithm we will discuss is the insertion operation. It might seem complex at a first glance, but it is actually quite simple when we use the constraints of a heap to derive it.</p><p>First, recall that one of the constraints of a heap is that it must be a full tree. Given this constraint, the first step of the heap insertion algorithm is quite intuitive: simply insert the new element in the next open slot of the tree (the new node will be a leaf in the bottom level of the tree, by definition of \"next open slot\"). In doing so, we have maintained the\u00a0<i>Shape Property</i>, so the only constraint that might be violated is the\u00a0<i>Heap Property</i>: the new element might potentially have higher priority than its parent, which would make the heap invalid.</p><p>Thus, the next (and last) step of the insertion algorithm should be intuitive as well: we must fix the (potentially) disrupted\u00a0<i>Heap Property</i> of our tree. To do so, we must\u00a0<b>bubble up</b> the newly-inserted element: if the new element has a higher priority than its parent, swap it with its parent; now, if the new element has higher priority than the new parent, swap; repeat until it has reached its correct place (either it has lower priority than its parent, or it is the root of the tree).</p><p>Formally, the pseudocode of heap insertion is as follows:</p><p></p><pre><code class=\"cpp\"><b>insert(element):\n</b>    place element in next open slot (as defined by a \"full tree\")\n    while element has a parent and element.priority &gt; element.parent.priority:\n        swap element and element.parent</code></pre><p></p><p>Below is a visualization of the heap insertion algorithm, where we insert 5 into the existing max-heap:</p><p><img alt=\"\" src=\"https://ucarecdn.com/fc73bb33-f119-43dd-9eb9-ea483e3966a9/\"></p><p>Because of the\u00a0<b></b><i>Shape Property</i> of a heap, we are guaranteed to have a perfectly balanced binary tree, which means that we are guaranteed to have <b></b>O(log\u00a0<i>n</i>)<b></b> levels in our tree. If we have\u00a0<i>L</i> levels in our tree, in the worst case, we do\u00a0<i>L</i>-1 comparisons for the bubble up process. As a result, if\u00a0<i>L</i> = O(log\u00a0<i>n</i>) and we do O(<i>L</i>) comparisons for the insertion algorithm, the overall <b>insertion</b> algorithm is\u00a0<b>O(log\u00a0<i>n</i>)</b>.</p>", "feedback_correct": "", "tests_archive": null, "subtitles": {}, "source": null, "name": "text", "video": null, "feedback_wrong": "", "options": {}, "animation": null}}