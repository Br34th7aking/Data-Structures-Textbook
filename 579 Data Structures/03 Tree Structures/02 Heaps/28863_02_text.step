{"block": {"feedback_wrong": "", "subtitles": {}, "animation": null, "name": "text", "text": "<p>Recall from when we introduced the previous ADTs that an ADT is defined by a set of functions. The\u00a0<b>Priority Queue</b> ADT can be formally defined by the following set of functions:</p><ul><li><b><span class=\"wysiwyg-font-tt\">insert(element)</span>:</b> Add <span class=\"wysiwyg-font-tt\">element</span> to the Priority Queue<br></li><li><b><span class=\"wysiwyg-font-tt\">peek()</span>:</b> Look at the highest priority element in the Priority Queue</li><li><b><span class=\"wysiwyg-font-tt\">remove()</span>:</b> Remove the highest priority element from the Priority Queue<br></li></ul><p>Although we are free to implement a\u00a0<b>Priority Queue</b> any way we want (because it is an ADT), you'll soon realize that the data structures we've learned about so far make it a bit difficult to guarantee a good worst-case time complexity for <i>both</i> insertion and removal. We could theoretically use a <b>sorted Linked List</b> to back our <b>Priority Queue</b>, which would result in O(1) peeking and removing (we would have direct access to the highest priority element), but insertion would be O(<i>n</i>) to guarantee that our list remains sorted (we would have to scan through the sorted list to find the correct insertion site). Likewise, we could theoretically use an <b>unsorted Linked List</b>\u00a0to back our <b>Priority Queue</b>, which would result in O(1) insertion (we could just insert at the head or tail of the list), but peeking and removing would be O(<i>n</i>) (we would have to scan through the unsorted list to find the highest priority element). If you were to implement this using a <b>sorted</b> or <b>unsorted Array</b>, the worst-case time complexities would be the same as for a <b>sorted</b> or\u00a0<b>unsorted Linked List</b>.</p><p>It turns out that there is a specific data structure that developers typically use to implement the\u00a0<b>Priority Queue</b> ADT that guarantees <b>O(1)</b> peeking and <b>O(log\u00a0</b><i><b>n</b></i><b>)</b> insertion and removal in the worst case. In this section of the text, we will explore the first of our tree structures: the\u00a0<b>Heap</b>\ufeff.</p>", "tests_archive": null, "source": null, "subtitle_files": [], "options": {}, "feedback_correct": "", "video": null}, "id": "117044", "time": "2016-09-06T23:43:45.559605"}