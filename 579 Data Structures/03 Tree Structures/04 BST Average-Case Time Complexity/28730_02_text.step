{"id": "110139", "block": {"feedback_wrong": "", "tests_archive": null, "text": "<p>The first step of the proof is to simply change around nomenclature (easy enough, right?). Recall that \"time complexity\" is really just a metric of the number of operations it takes to execute some algorithm. Therefore, \"average-case time complexity\" is really just \"average-case\u00a0<i>number of operations</i>\" (in Big-O notation, as usual). Also, recall from statistics that the \"average\" of some distribution is simply the \"expected value\" (a computable value) of the distribution. In our case, our \"distribution\" is \"number of operations\", so finding the \"average number of operations\" is equivalent to computing the \"<i>expected</i> number of operations\". In other words, \"finding the average-case time complexity\" to perform a successful \"find\" operation in a <b><span class=\"wysiwyg-color-green\">BST</span></b> is simply <b>\"computing the expected number of operations\"</b> needed to perform a successful \"find\" operation in a <b><span class=\"wysiwyg-color-green\">BST</span></b>.</p><p>\"Number of operations\" is a value we can compute during the execution of our \"find\" algorithm in a specific case (by simply counting the number of operations executed), but it's a bit of an abstract term. We want to do a formal mathematical proof, so we need to use values that can be derived from the tree itself. Recall that the \"find\" algorithm starts at the root and traverses left or right, performing a \"single comparison\" (it really does 3 comparisons in the worst case, but even if it does 3 comparisons at each node, that's still O(1) comparisons at each node) until it finds the node of interest. Therefore, it performs O(1) comparisons at each node on the path from the root to the node. <br></p><p>Let's slap on a formal definition: for a node <i>i</i>\u00a0in a <b><span class=\"wysiwyg-color-green\">BST</span></b>, define the\u00a0<b>depth of node\u00a0<i>i</i></b>,\u00a0$ d_i$,\u00a0to be the number of nodes along the path from the root of the <b><span class=\"wysiwyg-color-green\">BST</span></b> to <i>i</i>. The depth of the root is 1, the depths of the root's children are 2, etc. Below is a <b><span class=\"wysiwyg-color-green\">BST</span></b> with the depth of each node labeled below it in red:</p><p><img title=\"Image: https://ucarecdn.com/c8f73a1a-f37a-4c6f-8c95-9ed8038a563b/\" src=\"https://ucarecdn.com/c8f73a1a-f37a-4c6f-8c95-9ed8038a563b/\" alt=\"\"></p><p>With this definition, we can revise the value we are trying to compute: we are now <b>\"computing the expected\u00a0</b><i><b>depth</b></i><i></i><b>\"</b> of a <b><span class=\"wysiwyg-color-green\">BST</span></b> with <i>n</i> nodes.</p>", "subtitle_files": [], "options": {}, "name": "text", "subtitles": {}, "animation": null, "feedback_correct": "", "source": null, "video": null}, "time": "2016-09-04T00:47:03.644521"}