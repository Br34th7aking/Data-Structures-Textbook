{"id": "110108", "block": {"feedback_correct": "", "name": "text", "feedback_wrong": "", "text": "<p>As you might have noticed, although <b><span class=\"wysiwyg-color-green\">Binary Search Trees</span></b> are relatively efficient when they are balanced, they can become unbalanced fairly easily depending on the order in which the elements are inserted.</p><p><b><span class=\"wysiwyg-color-red\">STOP and Think:</span></b> If we were to insert elements into a <b><span class=\"wysiwyg-color-green\">BST</span></b> in sorted order (i.e., insert the smallest element, then insert the next smallest, etc.), what would the resulting tree look like?</p><p>We found out that a <b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b> performs pretty badly in the worst case, but that it performs pretty well when it is well-balanced. How does the <b><span class=\"wysiwyg-color-green\">BST</span></b> perform on average (i.e., what is its average-case time complexity)? Although this is a seemingly simple question, it requires formal mathematical exploration to answer, which we will dive into in the next section.</p>", "subtitle_files": [], "source": null, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2016-09-05T17:08:14.326668"}