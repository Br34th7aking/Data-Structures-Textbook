{"id": "110108", "time": "2016-09-02T18:27:02.711208", "block": {"animation": null, "text": "<p>As you might have noticed, although <b><span class=\"wysiwyg-color-green\">Binary Search Trees</span></b> are relatively efficient when they are balanced, they can become unbalanced fairly easily depending on the order in which the elements are inserted.</p><p><b><span class=\"wysiwyg-color-red\">STOP and Think:</span></b> If we were to insert elements into a <b><span class=\"wysiwyg-color-green\">BST</span></b> in sorted order (i.e., insert the smallest element, then insert the next smallest, etc.), what would the resulting tree look like?</p><p>We found out that a <b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b> performs pretty badly in the worst case, but that it performs pretty well when it is well-balanced. How does the <b><span class=\"wysiwyg-color-green\">BST</span></b> perform on average (i.e., what is its average-case time complexity)? Although this is a seemingly simple question, it requires formal mathematical exploration to answer, which we will dive into in the next section.</p>", "options": {}, "feedback_correct": "", "source": null, "subtitle_files": [], "name": "text", "feedback_wrong": "", "subtitles": {}, "tests_archive": null, "video": null}}