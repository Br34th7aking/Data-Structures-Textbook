{"block": {"video": null, "tests_archive": null, "feedback_correct": "", "animation": null, "text": "<p>In the previous section, we were motivated by the goal of storing a set of elements in such a manner that we could quickly access the\u00a0<i>highest priority</i> element in the set, which led us to the\u00a0<b>Heap</b> data structure (and its use to implement the\u00a0<b>Priority Queue</b> ADT). However, although we obtained fast access to the highest priority element, we had no way of efficiently looking at any other element. What if, instead, we want a data structure that could store a set of elements such that we could find any arbitrary element fairly quickly?</p><p>The second type of binary tree we will discuss is the\u00a0<b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b><b><span class=\"wysiwyg-color-green\"> (BST)</span></b>, which\u00a0is a rooted binary tree (i.e., there is a single \"root\" node, and all nodes have either 0, 1, or 2 children) in which any given node is larger than all nodes in its left subtree and smaller than all nodes in its right subtree. As can be inferred, a <b><span class=\"wysiwyg-color-green\">BST</span></b> can only store elements if there exists some way of comparing them (e.g. strings, characters, numbers, etc.): there must be some inherent order between elements. We will be learning about the following functions of a <b><span class=\"wysiwyg-color-green\">BST</span></b>: <b>find</b>, <b>size</b>, <b>clear</b>, <b>insert</b>, <b>empty</b>, <b>successor</b>, and the <b>iterator</b> pattern. Below is an example of a typical valid <b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b>:</p>\n\n<img alt=\"\" src=\"https://ucarecdn.com/bf1e683e-f4a5-4d00-942a-86d9e3c58127/\">", "subtitle_files": [], "subtitles": {}, "feedback_wrong": "", "name": "text", "source": null, "options": {}}, "id": "110098", "time": "2016-09-14T00:09:44.857375"}