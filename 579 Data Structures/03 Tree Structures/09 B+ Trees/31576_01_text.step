{"block": {"animation": null, "source": null, "text": "<p>As we have now seen, the \u00a0<b><span class=\"wysiwyg-color-green\">B-Tree</span></b>\u00a0is an exceptionally optimized way to store and read data on the Hard Disk. Consequently, when saving a large dataset on the Hard Disk, it is only natural to want to use the  <b><span class=\"wysiwyg-color-green\">B-Tree </span></b><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">structure to take advantage of all of its perks (i.e., it keeps our data sorted and lets us query fairly fast in practice).\u00a0</span></span></p><p><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">A common way to store a large dataset is to use a relational database. If we wanted to store a relational database using the <span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">B-Tree</span></b></span><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\"> structure, we would store each data\u00a0<i>entry</i> (commonly stored as a row in a database, with multiple data fields stored as columns) as a single key. </span></span>However, there are a couple of aspects to working with databases that make the </span></span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">B-Tree</span></b></span><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\"> structure not so ideal for this purpose:<br></span></span></p><ol><li><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">More often than not, database entries are actually really big (each row can have tens of columns). Also, we often only want to query a single database entry at a time. Consequently, in the worst case, if we wanted to find <i>one</i> database entry in\u00a0a  <span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">B-Tree</span></b></span></span><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">,</span></span><b> </b><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">we would need to traverse O($ log_{b} n $<span></span></span></span><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">) database entries to reach it. Since our databases can consist of\u00a0<i>millions</i> of large rows, traversing O($ log_{b} n\u00a0\u00a0\u00a0\u00a0 $) entries can be a <i>huge</i> waste of time to only look up\u00a0<i>one</i> database entry!</span></span></span></li><li><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">Another common task typically performed on databases is to query all the entries at once (e.g. to output everything currently being stored). If we wanted to query all the keys in a <span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">B-Tree</span></b></span>, we would have to traverse <i>up</i> and <i>down all</i> the nodes in all levels of the tree (i.e. execute a pre-order traversal), thereby having to figure out exactly <i>where</i> the pointer to the node is located in memory (L1 cache, Main Memory, Hard Disk...)</span></span> each time we go both\u00a0<i>down</i> and\u00a0<i>up</i> the tree. Potentially having to figure out where a node is located <i>twice</i> thus adds a large time overhead for an operation that definitely shouldn't need it.<br></li></ol>", "feedback_correct": "", "feedback_wrong": "", "video": null, "name": "text", "subtitles": {}, "subtitle_files": [], "options": {}, "tests_archive": null}, "id": "123046", "time": "2016-09-20T01:10:47.365546"}