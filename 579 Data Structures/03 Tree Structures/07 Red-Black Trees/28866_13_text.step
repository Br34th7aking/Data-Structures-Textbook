{"id": "120931", "time": "2016-09-09T16:58:26.400831", "block": {"subtitle_files": [], "text": "<p>We hope that you may be a bit confused at this point. We started this entire discussion with the motivation that we would be deviating from the\u00a0<b><span class=\"wysiwyg-color-blue\">AVL Tree</span></b>, which is always pretty close to the optimal height of a <b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b> (i.e., around\u00a0<b><span class=\"wysiwyg-color-blue\">1 log\u00a0</span></b><i><b><span class=\"wysiwyg-color-blue\">n</span></b></i>)\u00a0and towards the\u00a0<b><span class=\"wysiwyg-color-red\">Red-Black Tree</span></b> for the sole intention of getting even better speed in-practice, yet we just formally proved that a\u00a0<b><span class=\"wysiwyg-color-red\">Red-Black Tree</span></b> can potentially be so out-of-balance that it can hit roughly twice the optimal height\u00a0of a\u00a0<b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b>\u00a0(i.e., around\u00a0<b><span class=\"wysiwyg-color-red\">2 log </span></b><i><b><span class=\"wysiwyg-color-red\">n</span></b></i>), which would be\u00a0<i>slower</i> in practice!</p><p>Our response to you is: fair enough. You are indeed correct that, given a\u00a0<b><span class=\"wysiwyg-color-red\">Red-Black Tree</span></b> and an\u00a0<b><span class=\"wysiwyg-color-blue\">AVL Tree</span></b> containing the same elements, the\u00a0<b><span class=\"wysiwyg-color-blue\">AVL Tree</span></b> will probably be able to perform slightly faster <i>find</i> operations in-practice. Specifically, in the absolute worst case (where a <b><span class=\"wysiwyg-color-red\">Red-Black Tree</span></b> has roughly twice the height of a corresponding\u00a0<b><span class=\"wysiwyg-color-blue\">AVL Tree</span></b>), the\u00a0<b><span class=\"wysiwyg-color-red\">Red-Black Tree</span></b> will take roughly twice\u00a0as long\u00a0to find an element in comparison to the corresponding\u00a0<b><span class=\"wysiwyg-color-blue\">AVL Tree</span></b>\u00a0(around\u00a0<b><span class=\"wysiwyg-color-red\">2 log </span></b><i><b><span class=\"wysiwyg-color-red\">n</span></b></i>\u00a0vs. around\u00a0<b><span class=\"wysiwyg-color-blue\">log </span></b><i><b><span class=\"wysiwyg-color-blue\">n</span></b></i>\u00a0operations). If this logic wasn't clear, just note that a find operation on any\u00a0<b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b> takes steps proportional to the height of the tree in the worst-case because we simply traverse down the tree, so since the\u00a0<b><span class=\"wysiwyg-color-blue\">AVL Tree</span></b> has roughly half the height of the\u00a0<b><span class=\"wysiwyg-color-red\">Red-Black Tree</span></b> in the absolute worst case, it performs roughly half the operations to perform a find.</p><p>However, what about <i>insert</i> and\u00a0<i>remove</i> operations? Using the same exact logic, if a\u00a0<b><span class=\"wysiwyg-color-red\">Red-Black Tree</span></b> is extremely out of balance, it will take roughly the same amount of time\u00a0to remove or insert an element in comparison to the corresponding\u00a0<b><span class=\"wysiwyg-color-blue\">AVL Tree</span></b>\u00a0(around <b><span class=\"wysiwyg-color-red\">2 log </span></b><i><b><span class=\"wysiwyg-color-red\">n</span></b></i>\u00a0vs. around <b><span class=\"wysiwyg-color-blue\">2 log </span></b><i><b><span class=\"wysiwyg-color-blue\">n</span></b></i>\u00a0operations). However, if a\u00a0<b><span class=\"wysiwyg-color-red\">Red-Black Tree</span></b> is pretty balanced, it will take roughly\u00a0<i>half</i> the time to remove or insert an element in comparison to the corresponding\u00a0<b><span class=\"wysiwyg-color-blue\">AVL Tree</span></b> (around\u00a0<b><span class=\"wysiwyg-color-red\">log\u00a0</span><i><span class=\"wysiwyg-color-red\">n</span></i></b> vs. around\u00a0<b><span class=\"wysiwyg-color-blue\">2 log\u00a0</span><i><span class=\"wysiwyg-color-blue\">n</span></i></b> operations). If this logic wasn't clear, just note that an insertion or a removal operation on a\u00a0<b><span class=\"wysiwyg-color-red\">Red-Black Tree</span></b> only takes one pass down the tree, whereas an insertion or removal operation on an\u00a0<b><span class=\"wysiwyg-color-green\">AVL Tree</span></b> takes two passes (one down, and one back up), so if the two trees are roughly equally balanced, the\u00a0<b><span class=\"wysiwyg-color-red\">Red-Black Tree</span></b> performs the insertion or removal using roughly half as many operations.</p><p>In short, we typically see\u00a0<b><span class=\"wysiwyg-color-blue\">AVL Trees</span></b> perform better with find operations, whereas we typically see\u00a0<b><span class=\"wysiwyg-color-red\">Red-Black Trees</span></b> perform better with insert and remove operations. In practice, most data structures we use will be updated frequently, as we rarely know all of the elements we need in advance. As a result, because insertions and removals are actually very frequent in practice, it turns out that\u00a0<b><span class=\"wysiwyg-color-red\">Red-Black Trees</span></b> are the\u00a0<b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b> of choice for ordered\u00a0data structures in many programming languages (e.g. the C++ <span class=\"wysiwyg-font-tt\">map</span> or <span class=\"wysiwyg-font-tt\">set</span>).</p>", "feedback_correct": "", "tests_archive": null, "subtitles": {}, "source": null, "name": "text", "video": null, "feedback_wrong": "", "options": {}, "animation": null}}