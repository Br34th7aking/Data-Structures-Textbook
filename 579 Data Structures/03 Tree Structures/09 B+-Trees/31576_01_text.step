{"id": "122790", "time": "2016-09-09T16:58:45.379374", "block": {"subtitle_files": [], "text": "<p>Outline:<br>B-Trees<br><br></p><ul><li>All this time we've been making an \nassumption: that all accesses take the same amount of time. However, \nthis can't possibly be the truth because we have a memory hierarchy with\n limited memory <br><ul><li>Memory Hierarchy Image with levels + access times <br></li><li>Memory access times are shorter with Memory locality and accesses (array index example) a[i] &amp; a[i+1] will be loaded up<br></li></ul></li><li>This\n assumption is vastly relevant when dealing with trees, since trees are \nessentially built using pointers and pointers can really point <i>anywhere</i>. Thus we don't even know, but some nodes take way longer to access than others<br><ul><li>Hardcore\n truth: it takes more time on average (with respect to hardware) to \ntraverse a pointer (go from node to node) then to read all the data \nstored within one node. Why? Because of data locality!</li></ul></li><li>So\n being computer scientists, we want things to work as fast as possible. \nSo how can we take advantage of knowing how hardware works to not just \nhave the data structure be fast <i>theoretically</i> but also be fast <i>in practice</i> based on where modern technology stands?<ul><li>Fun\n Fact: There are many current debates surrounding whether it is even \nfair in the first place that theory assumes we have computational power \nfar beyond what we <i>really</i> have today. <br></li></ul></li><li>The \nanswer is minimize the amount of node traversals we have to do to find \ndata (i.e. make the trees as shallow as possible). AND store as much \ndata as possible close together (make the nodes big i.e. have each node \nstore multiple pieces of data)<ul><li>How do we store a lot of data in \none node? We can use an array! Each node is designed to fit in one \"disk\n block\" in order to ensure that we read the entire node when reading the\n disk<br></li><li>example of a B tree</li></ul></li><li>So how do we define a B- tree/ properties<ul><li>M,L = number of maximum children , number of data items stored in a node</li><li>Formally, we define a B-tree of order <i>M</i> to be a tree that satisfies these properties: <br><ol>\n<li>Every node has at most <i>M</i> children.</li>\n<li>Every non-leaf node (except root) has at least \u2308<i>M</i>/2\u2309 children.</li>\n<li>The root has at least two children if it is not a leaf node.</li>\n<li>A non-leaf node with <i>k</i> children contains <i>k</i>\u22121 keys.</li>\n<li>All leaves appear in the same level</li></ol></li><li>A non-leaf node is also called an \"internal node.\" Each internal node\u2019s keys act as separation values which divide the \nsubtrees. For example, for a B-tree of <i>M </i>= 2 and an internal node has 3 child nodes (or subtrees), the node must have 3-1 or 2 keys: <i>a</i><span class=\"wysiwyg-font-sub\">1</span> and <i>a</i><span class=\"wysiwyg-font-sub\">2</span>. All values in the leftmost subtree will be less than <i>a</i><span class=\"wysiwyg-font-sub\">1</span>, all values in the middle subtree will be between <i>a</i><span class=\"wysiwyg-font-sub\">1</span> (inclusive) and <i>a</i><span class=\"wysiwyg-font-sub\">2</span> (exclusive), and all values in the rightmost subtree will be greater than or equal to <i>a</i><span class=\"wysiwyg-font-sub\">2</span>.<br><ul><li>Have a figure of a B tree that check marks each of the following properties in a B-tree</li><li>EXERCISE BREAK: Select all the valid B-trees. (1. B tree with more keys than children. 2. )</li></ul></li></ul></li><li>B-tree OPERATIONS: Find<ul><li>Very similar to Find in a Binary Search algorithmically<ul><li>When\n we hit a node, we read the entire thing from disk into main memory. At \nthat point we use the separation values to figure out where to go next \nto read in the next node. Therefore the number of disk reads is equal to\n the height of the tree! <br></li></ul></li><li>Pseudocode <br></li><li>Analysis: O(log N) operation because of the perfectly balanced tree structure (pretty intuitive).</li><li>Deeper analysis? (see kube's slides)<br></li></ul></li><li>B-tree OPERATIONS: Insert<ul><li>Include viz inserting into a completely empty B-tree</li><li>Note:\n B-trees grow up instead of down! So the only way the height of a B-tree\n can increase is if the root splits into two to create a new root on \ntop. <br></li><li>Pseudocode <br></li></ul></li><li>B-tree OPERATIONS: Delete?<br><ol>\n</ol></li><li>Pros: Do not need re-balancing unlike other trees, but \nwaste more space (you will learn later that a B-tree is really a type of\n Multi-way Search Tree)</li></ul><p><br></p><p>B+ Tree Outline:</p><ul><li>Store all data in the leaves and use <b>keys</b> to help navigate the tree structure to find the data<ul><li>Maximizes branching factor</li><li>Key can be defined as whatever we used in the comparison function to sort the nodes. The key must be unique <br></li></ul></li></ul><br><p></p>", "feedback_correct": "", "tests_archive": null, "subtitles": {}, "source": null, "name": "text", "video": null, "feedback_wrong": "", "options": {}, "animation": null}}