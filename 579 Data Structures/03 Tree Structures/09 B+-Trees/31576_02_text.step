{"id": "123046", "block": {"name": "text", "tests_archive": null, "animation": null, "feedback_wrong": "", "subtitle_files": [], "video": null, "options": {}, "text": "As we have now seen,  <b><span class=\"wysiwyg-color-green\">B-Trees</span></b> are an exceptionally optimized way to store and read data on the Hard Disk. Consequently, when saving a large data set on the Hard Disk, it is only natural to want to use the  <b><span class=\"wysiwyg-color-green\">B-Tree </span></b><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">structure to take advantage of all of its perks (i.e., it keeps our data sorted and lets us query it fairly fast in practice). <br><br>A common format for a large data set to be stored in is in a relational database. If we were to want to store a database using the <span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">B-Tree</span></b></span><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\"> structure, then we would store each data\u00a0<i>entry</i> (commonly stored as a row in a database, with multiple data fields stored as columns) as a single key. </span></span>However, there are a couple of aspects to database creation that doesn't make the </span></span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">B-Tree</span></b></span><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\"> structure ideal:<br><br></span></span><ol><li><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">More often than not, database entries are actually really big (i.e., each row can have tens of columns). Also, we often only want to query single database entries at a time. Consequently, worst-case scenario in a  <span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">B-Tree,</span></b></span><b> </b></span><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">if we just wanted to find one database entry, we would need to traverse O($ log_{b} n $<span></span><span></span></span></span><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">) database entries to reach it. Since our databases can be\u00a0<i>millions</i> of large rows, traversing O($ log_{b} n\u00a0\u00a0\u00a0\u00a0 $) entries can be a <i>huge</i> waste of time to only look up\u00a0<i>one</i> database entry!</span></span></span></li><li><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">Another common thing to do with databases is to query all the entries at once (i.e., to figure out what is stored in this particular database). If we wanted to query all the keys in a <span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">B-Tree</span></b></span>, we would have to traverse <i>up</i> and <i>down all</i> the nodes in all levels of the tree, thereby having to figure out exactly <i>where</i> the pointer to the node is located in memory (L1 cache, Main Memory, Hard Disk...)</span></span> when we go both\u00a0<i>down</i> and\u00a0<i>up</i> the tree. Having to worst-case figure out where a node is located <i>twice</i> thus adds a large time overhead for an operation that definitely shouldn't need it. <br></li></ol><p>So how do we take into consideration the concerns above to transform the   <span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">B-Tree</span></b></span> structure into a more useful structure to implement large data sets? <br></p><ol><li>If we are worried about having to traverse nodes filled with other database entries before reaching the <i>single</i> database entry we queried, then how about we store the actual full database entries <i>only</i> at the leaves? In order to still be able to traverse the tree however, our keys above the leaves would be kept to storing <i>only</i> the single field we used to <i>sort</i> the data records. That way, we get to traverse <i>smaller</i> nodes to reach the query. By having less data to traverse, we would thus be increasing our chances that the smaller nodes are stored <i>closer to each other</i> in memory, thereby making it more likely that they are in a <i>closer section of memory</i>, such as the L1 Cache\u00a0 (remember, this is because the CPU determines which data to put in closer sections of memory based on <i>temporal</i> and <i><b>spatial</b></i> locality). By having the keys be in a closer section of memory, it will thus take less time to access the queried database entry. <br></li><li>Now that we have all the full data records guaranteed to be at the leaves, let's take advantage of this situation to create an easier way to read all the data entries <i>without</i> having to traverse up and down the tree; let's link together all the leaf nodes (i.e., implement the leaf nodes as a linked list)! That way, we can just do a linear scan of our leaf nodes to read <i>all</i> of our database entries.<br></li></ol>In practice, the implementation of the two ideas above in the   <span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">B-Tree</span></b></span> structure produces a variant structure called the <b><span class=\"wysiwyg-color-purple\">B+-Tree</span></b>. Let's look at the next step to see how a <b><span class=\"wysiwyg-color-purple\">B+-Tree</span></b> actually looks. <br>", "source": null, "subtitles": {}, "feedback_correct": ""}, "time": "2016-09-12T22:29:20.403054"}