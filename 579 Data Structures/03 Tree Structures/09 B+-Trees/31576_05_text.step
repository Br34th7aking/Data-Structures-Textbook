{"id": "122790", "block": {"name": "text", "feedback_correct": "", "animation": null, "subtitle_files": [], "video": null, "feedback_wrong": "", "options": {}, "source": null, "text": "<p>B+ Tree Outline:</p><ul><li>Store all data in the leaves and use <b>keys</b> to help navigate the tree structure to find the data<ul><li>Maximizes branching factor</li><li>Key can be defined as whatever we used in the comparison function to sort the nodes. The key must be unique </li></ul></li></ul><br><p></p><ul><li><ul><li>A non-leaf node is also called an \"internal node.\" Each internal node\u2019s keys act as separation values which divide the \nsubtrees. For example, for a B-tree of <i>M </i>= 2 and an internal node has 3 child nodes (or subtrees), the node must have 3-1 or 2 keys: <i>a</i><span class=\"wysiwyg-font-sub\">1</span> and <i>a</i><span class=\"wysiwyg-font-sub\">2</span>. All values in the leftmost subtree will be less than <i>a</i><span class=\"wysiwyg-font-sub\">1</span>, all values in the middle subtree will be between <i>a</i><span class=\"wysiwyg-font-sub\">1</span> (inclusive) and <i>a</i><span class=\"wysiwyg-font-sub\">2</span> (exclusive), and all values in the rightmost subtree will be greater than or equal to <i>a</i><span class=\"wysiwyg-font-sub\">2</span>.<br><br></li></ul></li><li>B-tree OPERATIONS: Find<ul><li>Deeper analysis? (see kube's slides)<br></li></ul></li><li>B-tree OPERATIONS: Insert<ul><li>Pseudocode <br></li></ul></li><li>B-tree OPERATIONS: Delete<br><ol>\n</ol></li><li>Pros: Do not need re-balancing unlike other trees, but \nwaste more space (you will learn later that a B-tree is really a type of\n Multi-way Search Tree)</li></ul><p></p>", "subtitles": {}, "tests_archive": null}, "time": "2016-09-15T15:01:34.231412"}