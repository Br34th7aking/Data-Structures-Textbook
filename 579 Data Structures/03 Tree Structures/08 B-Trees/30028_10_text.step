{"block": {"tests_archive": null, "feedback_correct": "", "subtitle_files": [], "text": "<p>So how do we delete a key from a <b><span class=\"wysiwyg-color-green\">B-Tree</span></b>? If we're lazy and don't care about memory management, then we can do a \"lazy deletion\" in which we just mark the key as \"deleted\" and just make sure that we check whether a key is marked as deleted or not in the find operation. However, the whole essence of <b><span class=\"wysiwyg-color-green\">B-Trees</span></b> is to gain fast access to elements, partly by minimizing node traversals; thus, if we start piling up \"deleted keys,\" our nodes will fill up much quicker and we will start having to create unnecessary new levels of nodes. By continually doing so, our find and insert operations will take longer and we thus essentially lose the efficiency that we just spent so much time designing. Consequently, most programmers chose to invest their time into implementing a more <i>proper</i> delete method.<br></p><p>So how do we implement a <i>proper</i> delete method? <br></p><p>The delete operation has 4 different cases we need to consider:</p><p>\n\n\n\n\n\n\n\n\n\n\n</p><ol><li>Delete a key at a leaf \u2013 no\nunderflow\n\n</li><li>Delete non-leaf key \u2013 no underflow\n\n</li><li>Delete leaf-key; underflow, and \"rich\nsibling\" <br></li><li>Delete leaf-key; underflow, and \"poor\nsibling\"\n\n\n\n</li></ol>Let's start with the easiest example, <b>Case 1: Delete a key at a leaf \u2013 no\nunderflow</b>. Within this first case, no properties are violated if we just remove the key:<br><br><img src=\"https://ucarecdn.com/e6adb0c8-1f8b-4986-8416-acc52f752fad/\" height=\"275\" title=\"Image: https://ucarecdn.com/e6adb0c8-1f8b-4986-8416-acc52f752fad/\" width=\"465\"><br><b>Case 2: Delete non-leaf key \u2013 no underflow.\u00a0</b>Within this second case, we face the problem of re-assigning empty key \"slots\" because there are pointers to leaves that need to be kept (this is different than in case 1 where we just deleted the key \"slot\").<br><br><img src=\"https://ucarecdn.com/3aea775a-4745-4727-9988-e1eb2cbc8880/\" height=\"281\" title=\"Image: https://ucarecdn.com/3aea775a-4745-4727-9988-e1eb2cbc8880/\" width=\"478\"><br><img src=\"https://ucarecdn.com/696e6665-d300-4b44-a633-a98aada42993/\" height=\"156\" title=\"Image: https://ucarecdn.com/696e6665-d300-4b44-a633-a98aada42993/\" width=\"493\"><br>When filling the empty key, we have two different options to chose which key we want to use as a replacement:<br><ol><li>The largest key from the left subtree</li><li>The smallest key from the right subtree</li></ol><p><b><span class=\"wysiwyg-color-red\">Note: </span></b><span class=\"wysiwyg-color-red\"><span class=\"wysiwyg-color-black\">If the node that we used to borrow a key from now also has an empty \"slot\" that needs to be filled (i.e., it wasn't a leaf), just repeat the same steps above recursively until we hit a leaf node!</span></span></p>", "feedback_wrong": "", "options": {}, "subtitles": {}, "name": "text", "source": null, "video": null, "animation": null}, "time": "2016-09-11T01:08:38.273520", "id": "122897"}