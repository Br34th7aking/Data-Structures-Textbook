{"id": "122876", "time": "2016-09-09T16:58:37.548696", "block": {"subtitle_files": [], "text": "<p>Therefore, the pseudocode for\u00a0a <b><span class=\"wysiwyg-color-green\">B-Tree</span></b> insert operation looks likes this (note that the real code to implement insert is usually near a page long because of the shuffling of keys and pointer manipulation that needs to take place):</p><p></p><pre><code>insert(key): # return true upon success\n \n    if key is already in tree:\n        return false\n    \n    find the leaf node to insert the key into\n    \n    search leaf node to find spot to insert key based on sorted order\n  \n    # while the extra key doesn't fit in the node, grow the tree\n    while(node-&gt;size &gt; 2*b):\n\n        split the node in half\n        remove largest key from first half of split node and attach it to parent node\n        node = parent \n\n</code></pre><br><p></p><p>So what is the worst-case time complexity for a <b><span class=\"wysiwyg-color-green\">B-Tree</span></b> insert operation? Well worst case scenario for each node we need to traverse all the keys, and since the maximum amount of keys we can have in a node is<i> </i>2*b - 1, the amount of keys in a node becomes O(<i>b</i>). As mentioned before, the tree has a depth of O($ log_{b}n $), and thus the <i>total</i> worst-case time complexity turns out to be O($ b*log_{b}n\u00a0 $). <br></p><p></p>", "feedback_correct": "", "tests_archive": null, "subtitles": {}, "source": null, "name": "text", "video": null, "feedback_wrong": "", "options": {}, "animation": null}}