{"id": "122876", "block": {"name": "text", "tests_archive": null, "animation": null, "feedback_wrong": "", "subtitle_files": [], "video": null, "options": {}, "text": "<p>Therefore, the steps for\u00a0a <b><span class=\"wysiwyg-color-green\">B-Tree</span></b> insert operation look likes this (note that the real code to implement insert is usually near a page long because of the shuffling of keys and pointer manipulations that need to take place):</p><p></p><pre><code class=\"python\">insert(key): # return true upon success\n \n    if key is already in tree:\n        return false\n    \n    find the leaf node to insert the key into\n    \n    search leaf node to find spot to insert key based on sorted order\n  \n    # while the extra key doesn't fit in the node, grow the tree\n    while(node-&gt;size &gt; 2*b):\n\n        split the node in half\n        remove largest key from first half of split node and attach it to parent node\n        attach parent pointers to new split nodes\n        node = parent \n\n</code></pre><br><p></p><p>So what is the worst-case time complexity for a <b><span class=\"wysiwyg-color-green\">B-Tree</span></b> insert operation? Well worst case scenario, for each node we need to traverse all the keys and since the maximum amount of keys we can have in a node is<i> </i>2*b - 1, the amount of keys in a node becomes O(<i>b</i>). As mentioned before, the tree has a depth of O($ log_{b}n $), and thus the <i>total</i> worst-case time complexity turns out to be O($ b*log_{b}n\u00a0 $). <br></p><p></p>", "source": null, "subtitles": {}, "feedback_correct": ""}, "time": "2016-09-12T22:29:10.773585"}