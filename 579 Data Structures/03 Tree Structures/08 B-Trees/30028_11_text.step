{"block": {"tests_archive": null, "feedback_correct": "", "subtitle_files": [], "text": "<p>Within the next two cases of the delete operation, we now face the problem of violating<b> </b>the <i>\"a non-leaf node with <i>k</i> children contains <i>k</i>\u22121 keys\"\u00a0</i>property (i.e., we face an \"underflow\") and thus have to re-structure the tree to avoid the violation (i.e., we can't just get rid of the \"slot\" as we did in the previous cases because that would lead to a parent node without enough children). In both of the following cases we re-structure the tree by taking a key from the parent node. However, the difference between the following two cases now is determined by whether we also <i><b>take</b></i> a key from the immediate sibling or <i><b>merge</b></i> with a key from the immediate sibling. <b><br></b></p><p><b>Case 3: Delete leaf-key; underflow, and \"rich\nsibling\"</b>\u00a0 <br></p><p><img height=\"260\" width=\"460\" alt=\"\" src=\"https://ucarecdn.com/0889ab24-0c09-417c-bb5b-747c5a1a20ba/\"></p><p><img height=\"214\" width=\"469\" alt=\"\" src=\"https://ucarecdn.com/e28d04dd-a33b-40fa-8387-a887af07a854/\"></p><p>Note that in the case above, the sibling was \"rich\" enough to provide a key to trade with the parent in order for the parent to be able to give a key to the empty node. <br></p><p><b><span class=\"wysiwyg-color-red\">STOP and Think:</span> </b>Why is it not okay to just move the sibling's largest key to the empty node (i.e., what becomes violated)?</p><p>But what happens if the empty node doesn't have an immediate sibling that can provide a key without causing more underflow?<br></p><p><b>Case 4: Delete leaf-key; underflow, and \"poor\nsibling\" </b><b><br></b></p><p><img height=\"220\" width=\"458\" alt=\"\" src=\"https://ucarecdn.com/8686292f-18de-4135-96bb-41b49d6d8b8d/\"></p><p><img height=\"203\" width=\"449\" src=\"https://ucarecdn.com/fbae87f7-72fc-498a-a1f2-dc2dd0a59844/\" alt=\"\" title=\"Image: https://ucarecdn.com/fbae87f7-72fc-498a-a1f2-dc2dd0a59844/\"></p><p><span class=\"wysiwyg-color-red\"><span class=\"wysiwyg-color-black\">So what is the worst-case time complexity of the delete operation for a <b><span class=\"wysiwyg-color-green\">B-Tree</span></b>? It turns out that it is the same as the insert operation, O($ b*log_{b} n $<span></span></span> <span class=\"wysiwyg-color-black\">). Why? Because worst-case scenario we need to traverse through all the keys in a node (<span class=\"wysiwyg-color-red\"><span class=\"wysiwyg-color-black\"> O($ b $) ) </span></span>in all levels of the tree ( O($ log_{b} n\u00a0 $), similarly to insert. </span><br></span></p><p><b><span class=\"wysiwyg-color-red\">Note: </span></b>Some programmers chose to voluntarily violate the \"underflow\" conditions described above in order to simplify the deletion process. However, by doing so, we risk having a taller tree than necessary, thereby making it more inefficient. Also note that the real code to implement the delete operation is usually near <i>two</i> pages long because of the excessive shuffling of keys and pointer manipulation that needs to take place.</p>", "feedback_wrong": "", "options": {}, "subtitles": {}, "name": "text", "source": null, "video": null, "animation": null}, "time": "2016-09-11T01:08:39.128157", "id": "122901"}