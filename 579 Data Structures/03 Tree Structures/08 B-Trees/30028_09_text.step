{"id": "122792", "block": {"name": "text", "tests_archive": null, "animation": null, "feedback_wrong": "", "subtitle_files": [], "video": null, "options": {}, "text": "<p>So how would we go about finding an element in a <b><span class=\"wysiwyg-color-green\">B-Tree</span></b>? Finding a key is actually very simple and similar to performing a Binary type search for each key in the node.\u00a0</p><p></p><pre><code class=\"python\">find(key, root): #return true upon success\n\n    for value in root:\n  \n        if key == value:\n\n            return true\n\n        if key &gt; value and value is not last: # move on to next value in root to compare key against\n            continue \n\n        else if key &lt; value: # search in the left subtree\n\n            find(key, value-&gt;leftChild) # make a recursive call\n\n        else: #we are at the last value in root, the only place left to look is the right subtree\n\n            find(key, value-&gt;rightChild) # make a recursive call\n\n    #looks like all the traversing is done and key wasn't found\n    return false</code></pre><p></p><p>So what is the worst-case time complexity of the find operation? As you probably have guessed by now, since we are dealing with a self-balancing tree, the worst-case time to find an element is equal to the height of a balance tree which is <b>O($ log_{b}n $)</b>. <br></p>", "source": null, "subtitles": {}, "feedback_correct": ""}, "time": "2016-09-12T22:29:12.524629"}