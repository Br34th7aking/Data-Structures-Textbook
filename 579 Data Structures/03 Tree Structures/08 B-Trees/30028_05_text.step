{"id": "122792", "time": "2016-09-09T16:58:33.750578", "block": {"subtitle_files": [], "text": "<p>So how would we go about finding an element in a <b><span class=\"wysiwyg-color-green\">B-tree</span></b>? Finding a key is actually very simple and similar to performing a Binary Search type search for each key in a node.\u00a0</p><p></p><pre><code class=\"python\">find(key, root): #return true upon success\n\n    for value in root:\n  \n        if key == value:\n\n            return true\n\n        if key &gt; value and value is not last: #if key is greater, move on to next node\n            continue # move on to next value to compare the key against\n\n        else if key &lt; value:\n\n            find(key, value-&gt;leftChild) # make a recursive call\n\n        else: #value is last in node, the only place left to look is the right child\n\n            find(key, value-&gt;rightChild) # make a recursive call\n\n    #looks like all the traversing is done and key wasn't found\n    return false</code></pre><p></p><p>So what is the worst-case time complexity of the find operation? As you probably have guessed by now, since we are dealing with a self-balancing tree, the worst-case time to find an element is equal to the height of a balance tree which is <b>O(log n)</b>. <br></p>", "feedback_correct": "", "tests_archive": null, "subtitles": {}, "source": null, "name": "text", "video": null, "feedback_wrong": "", "options": {}, "animation": null}}