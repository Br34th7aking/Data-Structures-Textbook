{"id": "122787", "block": {"name": "text", "tests_archive": null, "animation": null, "feedback_wrong": "", "subtitle_files": [], "video": null, "options": {}, "text": "<p>So how can we take advantage of the information we just learned about \nspatial locality of memory to not just have a tree structure be fast <i>theoretically,</i> but also be fast <i>in practice</i>? The answer is to minimize the amount of node traversals we have to do to \nfind data (i.e., make the trees as shallow as possible) <b>and</b> store\n as \nmuch data as possible close together (i.e., have each \nnode store multiple keys). Why? By minimizing the amount of node \ntraversals we minimize the risk of having to access a section of memory \nthat takes longer<b>. </b>By having a node store multiple \nkeys we are able to trick the CPU into loading more than one key at once\n into a fast section of memory (the L1 cache), thereby making to find another key within the same node faster since it will already be in \nthe L1 cache (as opposed to somewhere else in Main Memory).<br></p><p>The data structure that does the above is called a <b><span class=\"wysiwyg-color-green\">B-Tree</span></b>. A <b><span class=\"wysiwyg-color-green\">B-Tree</span></b> is a self-balancing tree data structure that generally allows for a node to have more than two children (to keep the tree wide and therefore from growing in height) and keeps multiple inserted keys in one node.\u00a0We usually define a  <b><span class=\"wysiwyg-color-green\">B-Tree\u00a0</span></b><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">to have \"order <i>b</i>\" where\u00a0<i>b\u00a0</i>is the minimum <span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">number of</span></span> children allowed and 2<i>b</i> is the maximum number of children allowed. </span></span>Below is an example of a  <b><span class=\"wysiwyg-color-green\">B-Tree</span></b> with <i>b</i>=2:<br></p><img height=\"185\" src=\"https://ucarecdn.com/16dad929-3cf5-43f7-abd8-23d3fed13dcc/\" alt=\"\" width=\"449\"><br>In the <b><span class=\"wysiwyg-color-green\">B-Tree</span></b> above, each integer is considered a separate key (i.e., each integer would have had its own node in a BST) and just like in other trees, every key in the left subtree is smaller than the current key and every key in the right subtree is greater (e.g starting at key 7, keys 2,3,6 are all smaller and key 13 is greater). Also note that since the maximum number of children is 2*2 = 4, a node can therefore only store up to 3 keys (because pointers to children are stored <i>in between</i> keys). More generally, we say that a node can store up to 2*b - 1 keys. <br><br>Formally, we define a <b><span class=\"wysiwyg-color-green\">B-Tree</span></b> of order <i>b</i> to be a tree that satisfies these properties: <br><ol>\n<li>Every node has at most <i>2b</i> children.</li>\n<li>Every non-leaf node (except root) has at least <i>b</i> children.</li>\n<li>The root has at least two children if it is not a leaf node.</li>\n<li>A non-leaf node with <i>k</i> children contains <i>k</i>\u22121 keys.</li>\n<li><b>All leaves appear in the same level. </b>(We will later see how this is enforced during the insert operation)<br></li></ol>", "source": null, "subtitles": {}, "feedback_correct": ""}, "time": "2016-09-12T22:29:07.402543"}