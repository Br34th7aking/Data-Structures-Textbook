{"id": "110661", "block": {"name": "text", "tests_archive": null, "animation": null, "feedback_wrong": "", "subtitle_files": [], "video": null, "options": {}, "text": "<p>In the previous section of this chapter, we were able to formally prove that, after making two assumptions about randomness, the average-case time complexity of <b><span class=\"wysiwyg-color-green\">BST</span></b> insertion, removal, and finding is O(log\u00a0<i>n</i>). However, we also concluded that, in practice, those two assumptions we made were pretty unrealistic. Can we salvage all of the hard work we just did? Is there some clever way for us to simulate the same random distribution of tree topologies? If, in practice, we are somehow able to successfully simulate the same exact randomness in tree structure that we assumed in our proof, we would be able to actually experience this average-case time complexity.</p><p>It turns out that, by tying in the\u00a0<i><b><span class=\"wysiwyg-color-red\">Heap Property</span></b></i> (from the previous section on Heaps) with some random number generation to our <b><span class=\"wysiwyg-color-green\">Binary Search Trees</span></b>, we can actually achieve this simulation, and as a result, the O(log\u00a0<i>n</i>) average-case time complexity. The data structure we will be discussing in this section is the\u00a0<b><span class=\"wysiwyg-color-blue\">Randomized Search Tree (RST)</span></b>.</p>", "source": null, "subtitles": {}, "feedback_correct": ""}, "time": "2016-09-12T22:28:28.076606"}