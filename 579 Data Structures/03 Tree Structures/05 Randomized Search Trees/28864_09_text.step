{"block": {"tests_archive": null, "feedback_correct": "", "subtitle_files": [], "text": "<p>Hopefully the question about worst-case time complexity on the previous step jolted your memory a bit: remember that we are jumping through all of these hoops in order to obtain a O(log <i>n</i>)\u00a0<i>average-case</i> time complexity, but the\u00a0<i>worst-case</i> time complexity remains unchanged at O(<i>n</i>) if the tree is very unbalanced.</p><p>Nevertheless, below is a more complex example of insertion into a\u00a0<b><span class=\"wysiwyg-color-purple\">Treap</span></b>. In the example below, the element being inserted is\u00a0<b>(<span class=\"wysiwyg-color-green\">R</span>, <span class=\"wysiwyg-color-red\">20</span>)</b>:</p><p><img src=\"https://ucarecdn.com/b5785ec3-f47c-4d23-ba26-59d4c3bf323f/\" alt=\"\"></p><p>Now that we've done the naive\u00a0<b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b> insertion algorithm, we need to bubble up to fix the\u00a0<b><i><span class=\"wysiwyg-color-red\">Heap Property</span></i></b>. First, we see that the new element's priority, 20, is larger than its parent's priority, 5, so we need to perform an AVL rotation (a left rotation) to fix this:</p><p><img src=\"https://ucarecdn.com/e525bd15-82dc-40f7-b99b-62c1aeec49c9/\" alt=\"\"></p><p>Next, we see that the new element's priority, 20, is larger than its parent's priority, 10, so we need to again perform an AVL rotation (a right rotation) to fix this:</p><p><img src=\"https://ucarecdn.com/6f6e1b09-bb32-4ace-9250-e91b0ef2744e/\" alt=\"\"></p><p>Finally, we see that the new element's priority, 20, is larger than its parent's priority, 15, so we need to perform one final AVL rotation (a left rotation) to fix this:</p><p><img src=\"https://ucarecdn.com/878457e6-498d-410e-9234-7b2683bc8fe5/\" alt=\"\"></p><p>Again, success! We were able to insert our new (<i>key</i>,\u00a0<i>priority</i>) element into our\u00a0<b><span class=\"wysiwyg-color-purple\">Treap</span></b> in a manner that maintained the\u00a0<b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b> properties (with respect to\u00a0<i>keys</i>) as well as the\u00a0<b><i><span class=\"wysiwyg-color-red\">Heap Property</span></i></b><i></i> (with respect to\u00a0<i>priorities</i>). Also, hopefully you noticed something interesting: after the initial naive\u00a0<b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b> insertion step of the\u00a0<b><span class=\"wysiwyg-color-purple\">Treap</span></b> insertion algorithm, the resulting tree was quite out of balance, but by chance, because of the new element's\u00a0<i>priority</i>, the bubble-up step of the\u00a0<b><span class=\"wysiwyg-color-purple\">Treap</span></b> insertion algorithm actually improved our tree's balance! This peculiar phenomenon motivates the data structure we introduced at the beginning of this section: the\u00a0<b><span class=\"wysiwyg-color-blue\">Randomized Search Tree</span></b>.</p>", "feedback_wrong": "", "options": {}, "subtitles": {}, "name": "text", "source": null, "video": null, "animation": null}, "time": "2016-09-11T01:07:59.413443", "id": "120155"}