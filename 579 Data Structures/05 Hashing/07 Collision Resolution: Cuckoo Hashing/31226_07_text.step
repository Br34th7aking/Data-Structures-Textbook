{"id": "121818", "block": {"feedback_correct": "", "name": "text", "feedback_wrong": "", "text": "In the previous step, we saw that the bulk of the algorithm ran inside a while loop that was bounded by a MAX limit. So why do we even have a limit in the first place?<br><br>You may have noticed within the second visualization we provided<span class=\"wysiwyg-color-black\"> that</span><b> </b>inserting\u00a0a <b><span class=\"wysiwyg-color-blue\">key</span></b> started to take longer because different <b><span class=\"wysiwyg-color-blue\">keys</span></b> started bouncing back and forth between places; for example, inserting the integer <b><span class=\"wysiwyg-color-blue\">key</span>\u00a0</b>17 took 4 iterations of hashing. As both tables begin to fill up, the probability of collisions start to increase. <i>However</i>, unlike the other <b><span class=\"wysiwyg-color-red\">collision resolution strategies\u00a0</span></b><span class=\"wysiwyg-color-red\"><span class=\"wysiwyg-color-black\">we discussed in which a\u00a0<b><span class=\"wysiwyg-color-blue\">key</span></b> <i>k</i> could end up trying every single\u00a0<b><span class=\"wysiwyg-color-purple\">Hash Table\u00a0</span></b>slot until the entire\u00a0<b><span class=\"wysiwyg-color-purple\">Hash Table</span>\u00a0</b>was full (e.g.\u00a0<b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b></span><span class=\"wysiwyg-color-black\">,</span><b><span class=\"wysiwyg-color-blue\"> Double Hashing</span></b><span class=\"wysiwyg-color-black\">,</span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-blue\"> Random Hashing</span></b>)\u00a0a<span class=\"wysiwyg-color-blue\">\u00a0</span><b><span class=\"wysiwyg-color-blue\">key</span></b>\u00a0<i>k</i> in <b><span class=\"wysiwyg-color-blue\">Cuckoo Hashing</span></b> only has\u00a0<b>two</b> different locations that it can map to (index1 =\u00a0$ H_1(k) $\r\n    and index2 =\u00a0$ H_2(k)  $). Consequently, if both hashable locations for <i>all</i> <b><span class=\"wysiwyg-color-blue\">keys</span> </b>are full, then the algorithm faces an infinite cycle as seen in the visualization below (this visualization leaves off from where the previous one ended).</span></span> Use the arrows in the bottom left to walk through the slides. </p><p><iframe src=\"https://docs.google.com/presentation/d/1uNYS51BNM66GJmM0vDIWnac-Y9VUQxOpYikpJoKXJyo/embed?start=false&amp;loop=false&amp;delayms=60000\" width=100% height=\"550\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\"></iframe><br><br>", "subtitle_files": [], "source": null, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2016-09-05T17:13:00.404528"}