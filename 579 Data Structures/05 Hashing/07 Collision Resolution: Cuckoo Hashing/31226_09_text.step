{"time": "2016-09-05T12:32:19.039043", "block": {"tests_archive": null, "animation": null, "feedback_correct": "", "subtitles": {}, "source": null, "text": "<p>By only allowing each <b><span class=\"wysiwyg-color-blue\">key</span></b> to hash to strictly two different locations (thereby potentially causing the cycle in the first place), we end up getting a <b><i>worst-case constant</i></b><i> </i>time complexity for two of our major operations! Specifically:</p><ul><li>For the \"find\" method: we know that if the <b><span class=\"wysiwyg-color-blue\">key</span></b> is not in either index1 = $ H_1(k)\u00a0\u00a0$ or index2 = $ H_2(k)  $, then it is not in the table; this is a constant time operation.</li><li>For the \"delete\" method: we know that the <b><span class=\"wysiwyg-color-blue\">key</span></b> is either in index1 =\u00a0$ H_1(k)  $\n    or index2 =\u00a0$ H_2(k)  $ and all we have to do is remove the <b><span class=\"wysiwyg-color-blue\">key</span></b> from its current index; this is a constant time operation. (We've included an interactive visualization <a href=\"http://www.lkozma.net/cuckoo_hashing_visualization/\">here</a> where you can play around with inserting and deleting elements).<br></li></ul><p> This is super unique to <b><span class=\"wysiwyg-color-blue\">Cuckoo Hashing</span></b> because in all the other <b>open addressing</b> <b><span class=\"wysiwyg-color-red\">collision resolution strategies</span></b> that we have discussed so far, we could only guarantee an <b>average</b><b>-case</b> constant time complexity with respect to our those two operations because worst-case scenario we had to traverse the entire <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>.<br></p><p>For the \"insert\" method in <b><span class=\"wysiwyg-color-blue\">Cuckoo Hashing</span></b> however, we only get an <i>average</i> case constant time complexity since worst-case scenario we would have to rehash the entire table, which has an O(n) time complexity. In an <i>average</i> case scenario however,---though beyond the scope of this text--- we can prove through amortized cost analysis that we can finish an insertion before the algorithm is forced to terminate and re-hash. <br></p><p><b><span class=\"wysiwyg-color-red\">Fun Fact:</span> </b>A lot of proofs about cycles in <b><span class=\"wysiwyg-color-blue\">Cuckoo Hashing</span></b> are solved by converting the<span class=\"wysiwyg-color-blue\">\u00a0</span><b><span class=\"wysiwyg-color-blue\">keys</span></b> within the two <b><span class=\"wysiwyg-color-purple\">Hash Tables</span></b> to nodes and their two possible hashing locations to edges to create a graph theory problem! <br></p><p><b><span class=\"wysiwyg-color-red\">Note:</span></b><b><span class=\"wysiwyg-color-blue\"> Cuckoo Hashing</span> </b>is not necessarily restricted to using just two <b><span class=\"wysiwyg-color-purple\">Hash Tables</span></b>; it is not uncommon to use beyond two hash tables and generally, for <i>d</i>  <b><span class=\"wysiwyg-color-purple\">Hash Tables<span class=\"wysiwyg-color-black\">, </span></span></b>each <b><span class=\"wysiwyg-color-purple\">Hash Table </span></b>would have a size of <i>M</i>/<i>d,</i> where <i>M</i> is the calculated capacity of a single <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> (i.e., the capacity that we would have calculated had we decided to use a different <b><span class=\"wysiwyg-color-red\">collision resolution strategy </span></b>that required only one  <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b><span class=\"wysiwyg-color-purple\"><span class=\"wysiwyg-color-black\">). </span></span><br></p>", "options": {}, "subtitle_files": [], "name": "text", "video": null, "feedback_wrong": ""}, "id": "122114"}