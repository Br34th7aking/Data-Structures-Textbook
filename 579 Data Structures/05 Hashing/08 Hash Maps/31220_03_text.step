{"time": "2016-09-20T20:58:36.256045", "block": {"name": "text", "subtitles": {}, "source": null, "subtitle_files": [], "feedback_wrong": "", "video": null, "animation": null, "feedback_correct": "", "tests_archive": null, "text": "<p>The <b><span class=\"wysiwyg-color-green\">Map</span> ADT</b> can theoretically be implemented in a multitude of ways. For example, we could implement it as a <b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b>: we would store <i>two</i> items inside each node, the <i>key</i> and the <i>value</i>, but we would keep the <b><span class=\"wysiwyg-color-green\">Binary Search Tree</span></b> ordering property based on just <i>keys</i>.</p><p><i>However</i>, if we didn't care so much about the sorting property but rather wanted faster <i>put</i> and <i>has</i> operations (if we desired a constant time-complexity, for example), then the <b><span class=\"wysiwyg-color-green\">Map</span> ADT</b> could also be implemented effectively as a <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>: we refer to this implementation as a <b><span class=\"wysiwyg-color-blue\">Hash Map</span></b>.</p><p>Implementation-wise, a <b><span class=\"wysiwyg-color-blue\">Hash Map</span></b> has the following set of operations:</p><ul><li><b><span class=\"wysiwyg-font-tt\">insert(&lt;key,value&gt;)</span>:</b> perform the insertion, and return the previous <i>value</i> if overwriting, otherwise null</li><li><b><span class=\"wysiwyg-font-tt\">find(key)</span>:</b> return the <i>value</i> associated with the <i>key</i></li><li><b><span class=\"wysiwyg-font-tt\">remove(key)</span>:</b> remove the (<i>key</i>, <i>value</i>) pair associated with key, and return <i>value</i>\u00a0upon success or null on failure</li><li><b><span class=\"wysiwyg-font-tt\">hashFunction(key)</span>:</b>\u00a0return a hash value for\u00a0<i>key</i>\ufeff, which will then be used to map to an index of the backing array</li><li><b><span class=\"wysiwyg-font-tt\">key_equality(key1, key2)</span>:</b> return true if\u00a0<i>key1</i> is equal to\u00a0<i>key2</i>, otherwise return false</li><li><b><span class=\"wysiwyg-font-tt\">size()</span>:</b> return the number of (<i>key</i>, <i>value</i>) pairs currently stored in the <b><span class=\"wysiwyg-color-blue\">Hash Map</span></b></li><li><b><span class=\"wysiwyg-font-tt\">isEmpty()</span>:</b> return true if the <b><span class=\"wysiwyg-color-blue\">Hash Map</span></b> does not contain any (<i>key</i>, <i>value</i>) pairs, otherwise return false</li></ul><p>Just like a <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>, a <b><span class=\"wysiwyg-color-blue\">Hash Map</span></b> uses a <b><span class=\"wysiwyg-color-green\">hash function</span></b> for the purpose of being able to access the addresses of the tuples inserted. Consequently, in a <b><span class=\"wysiwyg-color-blue\">Hash Map</span></b>,  keys must be hashable and have an associated equality test to be able \nto check for uniqueness. In other words, to use a custom class type as a key, one would have to overload the hash and equality member functions.</p>", "options": {}}, "id": "122547"}