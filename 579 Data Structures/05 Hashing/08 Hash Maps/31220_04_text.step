{"id": "122547", "block": {"name": "text", "tests_archive": null, "animation": null, "feedback_wrong": "", "subtitle_files": [], "video": null, "options": {}, "text": "In practice, a  <b><span class=\"wysiwyg-color-green\">Map</span> ADT</b> can be implemented in a multitude of ways. For example, we can implement it as a Binary Search Tree by inserting the &lt;<b><span class=\"wysiwyg-color-blue\">key</span>,</b> value&gt; tuples into the tree and sort by using the <b><span class=\"wysiwyg-color-blue\">keys</span></b>.\u00a0 <i>However</i>, if we didn't care so much about the sorting property but rather wanted a faster <i>put</i> and <i>has </i>capability (if we desired a constant time-complexity, for example), then a <b><span class=\"wysiwyg-color-green\">Map</span> ADT</b> can also be implemented using a\u00a0<b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>: we refer to this implementation as a <b><span class=\"wysiwyg-color-green\">Hash Map</span></b>. <br><br>Implementation-wise, a<b>\u00a0</b><b><span class=\"wysiwyg-color-green\">Hash Map</span></b> uses the following set of functions:<br><ul><li><b><span class=\"wysiwyg-font-tt\">insert(&lt;key,value&gt;): </span></b><b></b><span class=\"wysiwyg-font-tt\"><span class=\"wysiwyg-font-tt\">perform the insertion</span></span><b><span class=\"wysiwyg-font-tt\"></span></b><span class=\"wysiwyg-font-tt\">: return previous value if overwriting, otherwise null</span><b><span class=\"wysiwyg-font-tt\"><br></span></b></li><li><b><span class=\"wysiwyg-font-tt\">find(key): </span></b><span class=\"wysiwyg-font-tt\"><b></b>return the <i>value</i> associated with the key</span><b><span class=\"wysiwyg-font-tt\"><br></span></b></li><li><b><span class=\"wysiwyg-font-tt\"><b><span class=\"wysiwyg-font-tt\">remove(key)</span></b>:<b><span class=\"wysiwyg-font-tt\"><b></b></span></b></span></b><span class=\"wysiwyg-font-tt\"><span class=\"wysiwyg-font-tt\"><span class=\"wysiwyg-font-tt\"> remove the <i>tuple</i> associated with the key</span><span class=\"wysiwyg-font-tt\">: return true upon success, otherwise false</span></span></span><b><span class=\"wysiwyg-font-tt\"><br></span></b></li><li><b><span class=\"wysiwyg-font-tt\">hashFunction(key)</span></b><span class=\"wysiwyg-font-tt\">: to produce a hash value for a key to use to map the tuple to a valid index</span><b><span class=\"wysiwyg-font-tt\"><br></span></b></li><li><b><span class=\"wysiwyg-font-tt\">key_equality(key1, key2):</span></b><span class=\"wysiwyg-font-tt\"> to check if two keys are equal, to avoid duplicate key insertions</span></li><li><span class=\"wysiwyg-font-tt\"><b>size()</b><b>: </b>return the size of the Hash Map<b><br></b></span></li><li><span class=\"wysiwyg-font-tt\"><b>isEmpty()<b>:</b></b> return true if Hash Map is empty, otherwise false<br></span></li></ul><p><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">Just like a <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>, a <span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">Hash Map</span></b> </span>uses <span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">a <b>hash function</b> for the purpose of being able to access the addresses of the tuples inserted. </span></span><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">Consequently, in\u00a0a <span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">Hash Map</span></b>, </span> th</span></span>e <b><span class=\"wysiwyg-color-blue\">key</span></b>\n must be hashable and have an associated equality test to be able \nto check for uniqueness (i.e. to use a custom class type as a key, one \nwould have to overload the hash and equal_to member functions). </span></span></p><p></p><code class=\"cpp\"></code><p></p><p></p><p></p>", "source": null, "subtitles": {}, "feedback_correct": ""}, "time": "2016-09-12T22:31:58.129294"}