{"id": "121059", "block": {"feedback_correct": "", "name": "text", "feedback_wrong": "", "text": "In C++, a <span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">Hash Map</span></b><span class=\"wysiwyg-color-green\">\u00a0</span></span><span class=\"wysiwyg-color-black\">is called an <a rel=\"nofollow\" href=\"http://www.cplusplus.com/reference/unordered_map/unordered_map/\">unordered_map</a>. Just to remind you, a <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> was an <a rel=\"nofollow\" href=\"http://www.cplusplus.com/reference/unordered_set/unordered_set/\">unordered_set</a>. Referring back to the office  metaphor from the previous step, the C++ code to implement the </span><b><span class=\"wysiwyg-color-green\">Hash Map</span> </b><span class=\"wysiwyg-color-black\">would be:</span> <br><p></p><pre><code><pre><code class=\"cpp\">std::unordered_map&lt;std::string, vector&lt;officeSupply&gt;&gt; desk = {\n                { \"pens\", {favPen, redPen, freePen}},\n                { \"personal papers\", {personalNote}} };</code></pre></code></pre><br>In the<b> <span class=\"wysiwyg-color-green\">Hash Map </span></b>above, we have made the <b><span class=\"wysiwyg-color-blue\">keys</span></b> as type string and the objects being inserted as <b>vectors </b>of officeSupply objects. Note that the objects inserted into the<b> <span class=\"wysiwyg-color-green\">Hash Map </span></b>are <b>NOT </b>office supplies, but a <i><b>vector</b> </i>of office supplies. This is an important nuance<span class=\"wysiwyg-color-green\"><b> </b><span class=\"wysiwyg-color-black\">to understand because it illustrates to us the simultaneous advantage and draw back of such an organizational structure. On the one hand, such a structure allows us to easily edit the values that the <b><span class=\"wysiwyg-color-blue\">keys</span></b> are stored with (remember, keys were immutable in an unordered_set) without having to overwrite the previous items. For example, if we wanted to add a printed schedule to our desk </span></span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">Hash Map</span></b></span><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\"><b>\u00a0</b>we would do the following: <br><br><pre><code class=\"cpp\">(desk[\"personal papers\"]).push_back(schedule); \n\n// desk[\"personal papers\"] returns the {personalNote} vector\n// push_back adds a schedule officeSupply to the {personalNote} vector\n\n// our hash map now looks like\n// {{ \"pens\", {favPen, redPen, freePen} },{ \"personal papers\", {personalNote, schedule} }}\n</code></pre><br>Since we are using keys to access objects, we would reasonably expect that the average case time complexity to access objects would be the same\u00a0a <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>. However, it is important to note that by inserting<b> vectors </b>into the <span class=\"wysiwyg-color-green\"><b>Hash Map</b></span>, we no longer have the same time complexity to access <i>individual</i> office objects as we would have if we inserted <i>individual</i> office objects into a <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>. Remember, a constant time complexity would only refer to the actual objects we inserted into the </span></span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">Hash Map</span></b></span><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\"><b> </b>which, in the case above, would mean we have an average case constant time complexity to return the <i><b>vector</b></i> of office supplies. If we would want to calculate the worst case time complexity of, for example, finding an <i>office supply</i> in our desk </span></span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">Hash Map</span></b></span><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">, we would need to take into account the time it takes to find an element in an unsorted vector: O(N).</span></span><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\"><br>\u00a0<br>If for some reason we want to guarantee average case constant time <span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">access </span></span>across <i>all </i>of our <i>individual </i>objects, we have a couple of\u00a0 different options to achieve this goal. We could use a <b><span class=\"wysiwyg-color-purple\">Hash Table </span></b></span><span class=\"wysiwyg-color-purple\"><span class=\"wysiwyg-color-black\">instead of a vector (yes, we are saying that you can use an unordered_set <i>in</i> your unordered_map)</span> <span class=\"wysiwyg-color-black\">or </span></span><span class=\"wysiwyg-color-black\">assign each officeSupply object to its own key or just ditch the <span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">Hash Map</span></b></span> and use a <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> for the entire thing! Note that the moment we switch to any of the later two options, we lose the benefit of having a key act as a nice way to cluster multiple objects for us. <br><br>For example, I can easily check exactly which pens<i></i> I have in my desk with the following code:<br><br><pre><code><pre><code><pre><code class=\"cpp\">for (auto individualPens: desk[\"pens\"]) {\n   std::cout &lt;&lt; individualPens &lt;&lt;std::endl;\n}</code></pre>// Output:\n// favPen\n// redPen\n// freePen\n</code></pre></code></pre></span></span><br><p></p>", "subtitle_files": [], "source": null, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2016-09-02T19:37:32.753570"}