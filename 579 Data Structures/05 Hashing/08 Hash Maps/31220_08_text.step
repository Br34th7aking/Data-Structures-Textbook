{"id": "121059", "block": {"feedback_correct": "", "name": "text", "feedback_wrong": "", "text": "<span class=\"wysiwyg-color-black\"><p><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">It is also important to note that in practice, we often use <span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">a</span> </span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">Hash Map</span></b> </span>to\n implement a one to many relationship. For example, suppose we want to\n implement an \"office desk\" system where each desk drawer has a different label: \"pens\", \"pencils\", \"personal papers\", <span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">\"official documents\"</span></span>\n etc. Inside each particular drawer, we expect to find office \nitems related to the label. In the \"pens\" drawer we might expect to \nfind our favorite black fountain pen, a red pen for correcting \ndocuments and that free pen we got from that last event. In the \n\"personal papers\" drawer we might expect to find a personal note. <span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\"><br></span></span></span></span></p><p><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\"><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">So how would we use a <b><span class=\"wysiwyg-color-green\">Hash Map</span></b> to implement this system? Well, <span class=\"wysiwyg-color-black\">the <i>drawer labels</i> would be considered the </span> <b><span class=\"wysiwyg-color-blue\">keys </span></b></span><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\">and</span></span><b> </b><span class=\"wysiwyg-color-black\">the <i>drawers</i> with the objects inside them would be considered the value being inserted/mapped in the </span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">Hash Map</span></b></span>. <br></span></span></span></p>The C++ code would therefore be</span><span class=\"wysiwyg-color-black\">:</span> <br><p></p><pre><code><pre><code class=\"cpp\">std::unordered_map&lt;std::string, vector&lt;OfficeSupply&gt;&gt; desk = {\n                { \"pens\", {favPen, redPen, freePen}},\n                { \"personal papers\", {personalNote}} };</code></pre></code></pre><br>In the<b> <span class=\"wysiwyg-color-green\">Hash Map </span></b>above, we have made the <b><span class=\"wysiwyg-color-blue\">keys</span></b> as type string and the values as <b>vectors </b>of OfficeSupply objects. Note that the values inserted into the<b> <span class=\"wysiwyg-color-green\">Hash Map </span></b>are <b>NOT </b>office supplies, but a <i><b>vector</b> </i>of office supplies. <span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\"><br><br>If we now wanted to add a printed schedule to our desk </span></span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">Hash Map</span></b></span><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\"><b>\u00a0</b>we would do the following: <br><br><pre><code class=\"cpp\">(desk[\"personal papers\"]).push_back(schedule); \n\n// desk[\"personal papers\"] returns the {personalNote} vector\n// push_back adds a schedule OfficeSupply to the {personalNote} vector\n\n// our hash map now looks like\n// {{ \"pens\", {favPen, redPen, freePen} },{ \"personal papers\", {personalNote, schedule} }}\n</code></pre><br></span></span><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-red\">Note:</span></b> If we wanted to calculate the worst case time complexity of, for \nexample, finding an office supply in our desk Hash Map, we would now \nneed to take into account the time it takes to find an element in an \nunsorted vector: O(N). If we for some reason wanted to ensure constant \ntime access across values, we could also use a <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> instead of a \nvector (yes, we are saying that you can use an unordered_set in your \nunordered_map).<br><br>To easily check which pens we have in our desk, we could do the following:<br><br><pre><code><pre><code><pre><code class=\"cpp\">for (auto individualPens: desk[\"pens\"]) {\n   std::cout &lt;&lt; individualPens &lt;&lt;std::endl;\n}</code></pre>// Output:\n// favPen\n// redPen\n// freePen\n</code></pre></code></pre></span></span><br><p></p>", "subtitle_files": [], "source": null, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2016-09-07T23:39:51.419226"}