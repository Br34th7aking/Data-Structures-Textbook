{"block": {"feedback_wrong": "", "subtitles": {}, "animation": null, "name": "text", "text": "<span class=\"wysiwyg-color-black\"><p><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">It is also important to note that in practice, we often use <span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">a</span> </span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">Hash Map</span></b> </span>to\n implement a one to many relationship. For example, suppose we wanted to\n implement an \"office desk\" system with different drawers like so:</span></span></p><p><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">Each drawer has a different label: \"pens\", \"pencils\", \"personal papers\", <span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">\"official documents\"</span></span>\n etc. Inside each particular drawer, you would expect to find office \nitems related to the label. In the \"pens\" drawer you might expect to \nfind your favorite black fountain pen, a red pen for correcting \ndocuments and that free pen you got from that last event. In the \n\"personal papers\" drawer you might expect to find a personal note. <span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">With respect to <span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">a </span></span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">Hash Map</span></b>, the <i>drawer labels</i> would be considered the </span> <b><span class=\"wysiwyg-color-blue\">keys </span></b></span><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\">and</span></span><b> </b><span class=\"wysiwyg-color-black\">the <i>drawers</i> with the objects inside them would be considered the value being inserted/mapped in the </span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">Hash Map</span></b></span>. </span></span></span><br></p><p><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\"><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\"><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\"><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\"><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\"><br></span></span></span></span></span></span></span></span></span></span></p><p></p><br><br>Referring back to the office  metaphor from the previous step, the C++ code to use a </span><b><span class=\"wysiwyg-color-green\">Hash Map</span> </b><span class=\"wysiwyg-color-black\">would be:</span> <br><p></p><pre><code><pre><code class=\"cpp\">std::unordered_map&lt;std::string, vector&lt;OfficeSupply&gt;&gt; desk = {\n                { \"pens\", {favPen, redPen, freePen}},\n                { \"personal papers\", {personalNote}} };</code></pre></code></pre><br>In the<b> <span class=\"wysiwyg-color-green\">Hash Map </span></b>above, we have made the <b><span class=\"wysiwyg-color-blue\">keys</span></b> as type string and the values as <b>vectors </b>of OfficeSupply objects. Note that the values inserted into the<b> <span class=\"wysiwyg-color-green\">Hash Map </span></b>are <b>NOT </b>office supplies, but a <i><b>vector</b> </i>of office supplies. This is an important nuance<span class=\"wysiwyg-color-green\"><b> </b><span class=\"wysiwyg-color-black\">to understand because it illustrates to us the simultaneous advantage and draw back of such an organizational structure. On the one hand, such a structure allows us to easily edit the <i>values</i> that the <b><span class=\"wysiwyg-color-blue\">keys</span></b> are stored with (remember, keys are always immutable in both unordered_maps and unordered_sets) without having to overwrite the previous items. For example, if we wanted to add a printed schedule to our desk </span></span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-green\">Hash Map</span></b></span><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\"><b>\u00a0</b>we would do the following: <br><br><pre><code class=\"cpp\">(desk[\"personal papers\"]).push_back(schedule); \n\n// desk[\"personal papers\"] returns the {personalNote} vector\n// push_back adds a schedule OfficeSupply to the {personalNote} vector\n\n// our hash map now looks like\n// {{ \"pens\", {favPen, redPen, freePen} },{ \"personal papers\", {personalNote, schedule} }}\n</code></pre><br></span></span><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-red\">Note:</span></b> If we wanted to calculate the worst case time complexity of, for \nexample, finding an office supply in our desk Hash Map, we would now \nneed to take into account the time it takes to find an element in an \nunsorted vector: O(N). If we for some reason wanted to ensure constant \ntime access across values, we could also use a Hash Table instead of a \nvector (yes, we are saying that you can use an unordered_set in your \nunordered_map).<br><br>For example, I can easily check exactly which pens<i></i> I have in my desk with the following code:<br><br><pre><code><pre><code><pre><code class=\"cpp\">for (auto individualPens: desk[\"pens\"]) {\n   std::cout &lt;&lt; individualPens &lt;&lt;std::endl;\n}</code></pre>// Output:\n// favPen\n// redPen\n// freePen\n</code></pre></code></pre></span></span><br><p></p>", "tests_archive": null, "source": null, "subtitle_files": [], "options": {}, "feedback_correct": "", "video": null}, "id": "121059", "time": "2016-09-06T23:48:06.577186"}