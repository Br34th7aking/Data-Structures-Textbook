{"id": "121905", "block": {"name": "text", "feedback_correct": "", "animation": null, "subtitle_files": [], "video": null, "feedback_wrong": "", "options": {}, "source": null, "text": "<p>So far, all of our insertions have been working smoothly in <b>constant time</b> because we have avoided discussing what happens when a key indexes\u00a0to a slot that is already occupied (i.e., when we encounter a <i>collision</i>). However, this is arguably the most important part of implementing an optimized <b><span class=\"wysiwyg-color-purple\">Hash Table. </span></b><span class=\"wysiwyg-color-black\">Why?</span> More often than not, we are\u00a0mapping from a large space of possible keys (e.g. the numbers 1 to 1,000,000 for a <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> storing yearly household incomes, a large number of strings representing every possible human name for a\u00a0<b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> storing Google employee information, etc.) to a much smaller space: \nthe slots of the array that is backing the\u00a0<b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>. Since computers do not have unlimited memory, a <b><span class=\"wysiwyg-color-purple\">Hash Table's</span></b> capacity is in fact <i>much much</i> smaller than the vast set of possible keys.  As a result, we will inevitably encounter\u00a0<i>collisions</i>: two different keys indexing to the same <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> location.</p><p>Earlier in this lesson, our pseudocode for the insert operation of a <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> simply refused to insert a key\u00a0if a collision were to occur.\u00a0In practice, however, we would be facing a terrible data structure if we couldn't insert all the values we wanted. As a result, we need to invest time into thinking about the best possible ways to\u00a0<i>avoid</i> collisions in the first place, as well as <i>what to do</i> if a collision were to occur. For the time being, we'll keep the topic of <i>resolving</i> collisions on hold just a bit longer, but in the next lesson, we will use probability theory to discuss the causes of collisions in more depth, and we will think about how to choose an optimal\u00a0<b>capacity</b>\u00a0and a good indexing <b><span class=\"wysiwyg-color-green\">hash function</span></b>\u00a0for a <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>\u00a0to help us <i>avoid</i>\u00a0collisions.</p>", "subtitles": {}, "tests_archive": null}, "time": "2016-09-15T15:03:25.646757"}