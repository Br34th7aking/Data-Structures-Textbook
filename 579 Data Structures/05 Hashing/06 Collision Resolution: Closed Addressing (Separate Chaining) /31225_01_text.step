{"id": "121064", "block": {"subtitles": {}, "source": null, "video": null, "feedback_wrong": "", "options": {}, "animation": null, "text": "<p>In the previous section, we discussed our first attempt at handling collisions using a technique called\u00a0<b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b>, where, if a key maps to a slot in our\u00a0<b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> that is already occupied by a different key, we simply slide over and try again; if that slot is also full, we slide over again; etc. On <b>average</b>, assuming we've designed our <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> intelligently, we experience <b>O(1)</b> find, insert, and remove operations with\u00a0<b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b>. However, in the <b>worst case</b>, we could theoretically have to iterate over all\u00a0<i>N</i> elements to find a key of interest, making our three operations <b>O(</b><i><b>N</b></i><b>)</b>.</p><p>Also, we saw that keys tend to form \"clumps\" that make probing excessively slow, and these clumps are probabilistically favored to grow.\u00a0We introduced\u00a0<b><span class=\"wysiwyg-color-blue\">Double Hashing</span></b> and\u00a0<b><span class=\"wysiwyg-color-blue\">Random Hashing</span></b>, which helped solve our issue of clump formation and helped speed things up a bit.</p><p>Recall that, if we try to insert a key and <i>don't</i> encounter a collision, the probability of subsequent collisions must increase, regardless of how we choose to handle collisions (because we have now occupied a previously-unfilled slot of our\u00a0<b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>). If we try to insert a key and we\u00a0<i>do</i> encounter a collision, with\u00a0<b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b>, we take a performance hit on two accounts: we have to linearly scan until we find an open slot for insertion (so we take a hit now), and because we've now filled a previously-unfilled slot of our\u00a0<b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>, we have yet again increased the probability of subsequent collisions (so we will take a hit in a future insertion).</p><p>Upon a collision, the current insertion will take a performance hit, no matter which\u00a0<b><span class=\"wysiwyg-color-red\">collision resolution strategy</span></b> we choose. In other words, the performance hit we take now is inevitable. However, in this section, we will discuss another\u00a0<b><span class=\"wysiwyg-color-red\">collision resolution strategy</span></b>,\u00a0<b><span class=\"wysiwyg-color-blue\">Separate Chaining</span></b>, in which collisions\u00a0<i>do not</i> increase the probability of future collisions, so we avoid taking the additional performance hit in the future.</p>", "feedback_correct": "", "tests_archive": null, "subtitle_files": [], "name": "text"}, "time": "2016-09-03T01:11:28.312297"}