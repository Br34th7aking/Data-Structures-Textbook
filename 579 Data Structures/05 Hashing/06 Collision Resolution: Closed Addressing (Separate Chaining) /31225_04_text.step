{"id": "121378", "time": "2016-09-02T18:29:36.331469", "block": {"animation": null, "text": "<div><div><div><div><div><div>So how do we go about implementing this <b><span class=\"wysiwyg-color-red\">collision resolution strategy</span></b>? Here is the pseudo-code to implement <b><span class=\"wysiwyg-color-blue\">Separate Chaining </span></b>when inserting a key <i><b>k</b></i>, in a table of size <i><b>M</b></i> with a backing array called <b>arr</b>, using a <b><span class=\"wysiwyg-color-green\">hash function </span></b><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">H(<b><i>k</i></b>):</span></span><p></p><pre><code class=\"python\">insert_SeperateChaining(Key <b>k</b>):\n\n    index = H(<b>k</b>) \n\n        #check for duplicate insertions\n        if linked list in <b>arr</b>[index] contains <b>k</b>:\n\n            return\n\n        #insert the key\n        else:\n\n            insert k into linked list at <b>arr</b>[index]\n\n            return\n</code></pre><br>Notice that the core of the <b><span class=\"wysiwyg-color-blue\">Separate Chaining</span></b> algorithm is defined by this line:<br><pre><code>insert k into linked list at <b>arr</b>[index]</code></pre><br>As you might have noticed, we have been pretty vague as to which implementation of a linked list (singly, double, etc.) to use because it is really up to the programmer to decide exactly which implementation to choose based on his or her needs. Just like we have been discussing throughout this entire text, we can get vastly different time complexities based on which backing implementation we use and <i>how </i>we chose to use it.\u00a0 <br><br>A common implementation choice is to use a singly linked list with just a head pointer. By choosing that implementation, we consequently add new elements to the <i>front</i> of our linked list (i.e., reassign the head pointer and next pointer of the new element) as opposed to the back of the linked list (i.e., traverse the entire linked list and then reassign the next pointer of the last element). Note that, if we were to not care about checking for duplicate insertions, the mere change of insertion location can result in a worst case <i>constant</i> time complexity to turn into a worst case <i>linear</i> time complexity. <br><br>By obeying the algorithm above, we are ensuring that our key is inserted strictly within the\u00a0<i>single</i> index (or more formally an address) that it originally hashed to<span class=\"wysiwyg-color-purple\"><span class=\"wysiwyg-color-black\">. Consequently, we call this a <b>closed addressing</b> <b><span class=\"wysiwyg-color-red\">collision resolution strategy</span></b> (i.e. the key <i>must</i> be located in the original address</span></span><span class=\"wysiwyg-color-purple\"><span class=\"wysiwyg-color-black\">). Moreover, since we are now allowing multiple keys to be at a single index, we like to say that <b><span class=\"wysiwyg-color-blue\">Separate Chaining</span></b> is an <b>open hashing <b><span class=\"wysiwyg-color-red\">collision resolution strategy</span></b></b> (i.e. </span></span>the keys do not necessarily need to be physically inside the hash table itself<span class=\"wysiwyg-color-purple\"><span class=\"wysiwyg-color-black\">).<br><br><b><span class=\"wysiwyg-color-red\">Note:</span></b> You will most likely encounter people using the terms <b>open hashing </b>and <b>closed addressing </b>interchangeably since they arguably describe the same method of </span></span><b><span class=\"wysiwyg-color-red\">collision resolution</span></b>.<br></div></div></div></div></div></div>", "options": {}, "feedback_correct": "", "source": null, "subtitle_files": [], "name": "text", "feedback_wrong": "", "subtitles": {}, "tests_archive": null, "video": null}}