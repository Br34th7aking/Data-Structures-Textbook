{"id": "122035", "block": {"feedback_wrong": "", "tests_archive": null, "text": "<p>Let's imagine we are designing a\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> for keys that are ASCII characters (e.g. the <span class=\"wysiwyg-font-tt\">unsigned char</span> primitive data type of C++). Below is an implementation of a C++\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b>\u00a0that is\u00a0<i>valid</i>, because keys that are of equal value will have the same hash value, and\u00a0<i>good</i>\u00a0(<i>perfect</i>, actually), because keys of unequal value are guaranteed to have different hash values:</p><p></p><pre><code class=\"cpp\">unsigned int hashValue(unsigned char key) {\n    return (unsigned int)key; // cast key to unsigned int\n}</code></pre><p></p><p>Because each of the C++ primitive data types that are less than or equal to 4 bytes in size (<span class=\"wysiwyg-font-tt\">bool</span>, <span class=\"wysiwyg-font-tt\">char</span>, <span class=\"wysiwyg-font-tt\">unsigned char</span>, <span class=\"wysiwyg-font-tt\">int</span>, <span class=\"wysiwyg-font-tt\">unsigned int</span>, etc.) are stored in memory in a way that can be interpreted as an <span class=\"wysiwyg-font-tt\">unsigned int</span>, simply casting them as an <span class=\"wysiwyg-font-tt\">unsigned int</span> would result in a perfect <b><span class=\"wysiwyg-color-blue\">hashing</span></b>. Also, because primitive data types in most, if not all, languages can be cast to an integer in O(1) time, this perfect\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> has a worst-case time complexity of <b>O(1)</b>.</p><p>Let's imagine now that we are designing a\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> for keys that are strings. Below is an implementation of a C++\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> that is\u00a0<i>valid</i>, because keys that are of equal value will have the same hash value, and\u00a0<i>good</i>, because keys with different values will\u00a0<i>tend</i> to have different hash values:</p><p></p><pre><code class=\"cpp\">unsigned int hashValue(string key) {\n    unsigned int val = 0;\n    for(int i = 0; i &lt; key.length(); i++) {\n        val += (unsigned int)(key[i]); // cast each character of key to unsigned int\n    }\n    return val;                        // return the sum over all characters in key\n}</code></pre><p></p><p>This hash function is pretty good because keys with different lengths or characters will probably return different hash values. However, if two keys have the exact same letters, just in a different order, they will collide. Nevertheless, for a string of length\u00a0<i>k</i>, a good\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> must iterate over all\u00a0<i>k</i> characters when computing the hash value. For example, if we were to only consider the first character of a string, or even the first two characters, any valid\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> would return the same hash value for strings that share the same first two letters. Therefore, a good\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> for strings of length\u00a0<i>k</i> must have a time complexity of\u00a0<b>O(<i>k</i>)</b>. If you are interested in learning about clever\u00a0<b><span class=\"wysiwyg-color-green\">hash functions</span></b>\u00a0for strings, see <a rel=\"nofollow\" href=\"http://www.cse.yorku.ca/~oz/hash.html\">this brief article</a> by Ozan Yigit at York University.</p><p>Let's now imagine that we are designing a\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> for keys of some arbitrary datatype <span class=\"wysiwyg-font-tt\">Data</span> (it doesn't matter what <span class=\"wysiwyg-font-tt\">Data</span> is: the point we will make will be clear regardless of datatype). Below is an implementation of a C++\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> that is\u00a0<i>valid</i>, because keys that are of equal value will have the same hash value, but that is pretty terrible, because we will have a\u00a0<i>lot</i> of collisions:</p><p></p><pre><code class=\"cpp\">unsigned int hashValue(Data key) {\n    return 0;\n}</code></pre><p></p><p>It should hopefully be obvious why this is such a bad\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b>: no matter what\u00a0<i>key</i> is, it will always have a hash value of 0. In other words, the hash value of\u00a0<i>key</i> tells us absolutely nothing useful about\u00a0<i>key</i> and can't really be used to do anything.</p><p>Let's again imagine that we are designing a\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> for keys of the same arbitrary datatype Data. Below is an implementation of a C++\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> that is\u00a0<i>not valid</i>, because keys that are of equal value will\u00a0<i>not necessarily</i> have the same hash value:</p><p></p><pre><code class=\"cpp\">unsigned int hashValue(Data key) {\n    return (unsigned int)rand(); // return a random integer\n}</code></pre><p></p><p>Even if two keys are identical, if I compute their hash values separately, because my\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> simply generates a random number each time it's called, they will almost certainly have different hash values. Recall that, for a\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> to be\u00a0<i>valid</i>, the\u00a0<b>Property of Equality</b> <i>must</i> hold, but the fact that equal keys can have different hash values violates this property.</p>", "subtitle_files": [], "options": {}, "name": "text", "subtitles": {}, "animation": null, "feedback_correct": "", "source": null, "video": null}, "time": "2016-09-04T00:49:30.648750"}