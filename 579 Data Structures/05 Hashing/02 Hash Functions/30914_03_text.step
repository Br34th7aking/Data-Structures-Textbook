{"block": {"tests_archive": null, "feedback_correct": "", "subtitle_files": [], "text": "<p>Let's imagine we are designing a\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> for keys that are ASCII characters (e.g. the <span class=\"wysiwyg-font-tt\">unsigned char</span> primitive data type of C++). Below is a C++ implementation of a\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b>\u00a0that is\u00a0<i>valid</i>, because keys that are of equal value will have the same hash value, and\u00a0<i>good</i>\u00a0(<i>perfect</i>, actually), because keys of unequal value are guaranteed to have different hash values:</p><p></p><pre><code class=\"cpp\">unsigned int hashValue(unsigned char key) {\n    return (unsigned int)key; // cast key to unsigned int\n}</code></pre><p></p><p>Because each of the C++ primitive data types that are less than or equal to 4 bytes in size (<span class=\"wysiwyg-font-tt\">bool</span>, <span class=\"wysiwyg-font-tt\">char</span>, <span class=\"wysiwyg-font-tt\">unsigned char</span>, <span class=\"wysiwyg-font-tt\">int</span>, <span class=\"wysiwyg-font-tt\">unsigned int</span>, etc.) are stored in memory in a way that can be interpreted as an <span class=\"wysiwyg-font-tt\">unsigned int</span>, simply casting them as an <span class=\"wysiwyg-font-tt\">unsigned int</span> would result in a perfect <b><span class=\"wysiwyg-color-blue\">hashing</span></b>. Also, because primitive data types in most, if not all, languages can be cast to an integer in O(1) time, this perfect\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> has a worst-case time complexity of <b>O(1)</b>.</p><p>Let's imagine now that we are designing a\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> for keys that are strings. Below is a C++ implementation of a\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> that is\u00a0<i>valid</i>, because keys that are of equal value will have the same hash value and keys with different values will\u00a0<i>tend</i> to have different hash values:</p><p></p><pre><code class=\"cpp\">unsigned int hashValue(string key) {\n    unsigned int val = 0;\n    for(int i = 0; i &lt; key.length(); i++) {\n        val += (unsigned int)(key[i]); // cast each character of key to unsigned int\n    }\n    return val;                        // return the sum over all characters in key\n}</code></pre><p></p><p>This hash function is pretty good because keys with different lengths or characters will probably return different hash values. If we didn't take into account all of the characters of the string, we would have more collisions than we would want. For example, if we wrote some <b><span class=\"wysiwyg-color-green\">hash function</span></b> that only looks at the first character of a string, even though the <b><span class=\"wysiwyg-color-green\">hash function</span></b> would be O(1), it would always return the same hash value for strings that had the same first character (e.g. \"<b>H</b>ello\" and \"<b>H</b>ashing\" have the same first character, so a <b><span class=\"wysiwyg-color-green\">hash function</span></b> that only checks the first character of a string\u00a0<i>must</i> return the same hash value for these two very different strings).\u00a0As a result, for a string (or list, or collection, etc.) of length\u00a0<i>k</i>, a good\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> must iterate over <b>all\u00a0</b><i><b>k</b></i><b> characters</b>.</p><p>However, in the function above, even though we iterate over all <i>k</i> characters of a given string, we can still have a lot of collisions. For example, using the <b><span class=\"wysiwyg-color-green\">hash function</span></b> above, because we simply add up the ASCII values of each character, the strings \"Hello\" and \"eHlol\" will have the same hash value because, even though their letters are jumbled, they contain the same exact letters, so the overall sum will be the same.\u00a0Formally, if the arithmetic of our <b><span class=\"wysiwyg-color-green\">hash function</span></b>\u00a0is commutative, the order of the letters will not affect the results of the math, potentially resulting in unnecessary collisions.</p><p>Therefore, a good\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> for strings of length\u00a0<i>k</i>\u00a0(or generally, lists/containers/etc. with <i>k</i> elements)\u00a0must have a time complexity of\u00a0<b>O(<i>k</i>)</b>\u00a0and must perform arithmetic that is <b>non-commutative</b>.\u00a0If you are interested in learning about clever\u00a0<b><span class=\"wysiwyg-color-green\">hash functions</span></b>\u00a0for strings, see <a rel=\"nofollow\" href=\"http://www.cse.yorku.ca/~oz/hash.html\">this brief article</a> by Ozan Yigit at York University.</p><p>Let's now imagine that we are designing a\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> for keys of some arbitrary datatype <span class=\"wysiwyg-font-tt\">Data</span> (it doesn't matter what <span class=\"wysiwyg-font-tt\">Data</span> is: the point we will make will be clear regardless of datatype). Below is a C++ implementation of a\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> that is\u00a0<i>valid</i>, because keys that are of equal value will have the same hash value, but that is pretty terrible, because we will have a\u00a0<i>lot</i> of collisions:</p><p></p><pre><code class=\"cpp\">unsigned int hashValue(Data key) {\n    return 0;\n}</code></pre><p></p><p>It should hopefully be obvious why this is such a bad\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b>: no matter what\u00a0<i>key</i> is, it will always have a hash value of 0. In other words, the hash value of\u00a0<i>key</i> tells us absolutely nothing useful about\u00a0<i>key</i> and can't really be used to do anything.</p><p>Let's again imagine that we are designing a\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> for keys of the same arbitrary datatype Data. Below is a C++ implementation of a\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> that is\u00a0<i>not valid</i>, because keys that are of equal value will\u00a0<i>not necessarily</i> have the same hash value:</p><p></p><pre><code class=\"cpp\">unsigned int hashValue(Data key) {\n    return (unsigned int)rand(); // return a random integer\n}</code></pre><p></p><p>Even if two keys are identical, if I compute their hash values separately, because my\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> simply generates a random number each time it's called, they will almost certainly have different hash values. Recall that, for a\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> to be\u00a0<i>valid</i>, the\u00a0<b>Property of Equality</b> <i>must</i> hold, but the fact that equal keys can have different hash values violates this property.</p>", "feedback_wrong": "", "options": {}, "subtitles": {}, "name": "text", "source": null, "video": null, "animation": null}, "time": "2016-09-11T01:10:14.460145", "id": "122035"}