{"block": {"feedback_wrong": "", "subtitles": {}, "animation": null, "name": "text", "text": "<p>In this text, we are introducing <b><span class=\"wysiwyg-color-green\">hash functions</span></b> with the intent of using them to implement a\u00a0<b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>, but\u00a0there are many real-world applications in which we use \"good\" <b><span class=\"wysiwyg-color-green\">hash functions</span></b> outside the realm of Data Structures! One very practical example is checking the validity of a large file after you download it. Let's say you want to install a new Operating System on your computer, where the installation file for an Operating System can sometimes reach a few gigabytes in size, or let's say you want to watch some entertainment (legally on the public domain, of course), or perhaps you want to download a video game to play (again, legally on the public domain, of course). In all of these examples (which are quite different at a glance), the computational task is the same: there is a large file hosted on some remote server, and you want to download it to your computer. However, because these network transfer protocols don't have many provisions for ensuring data integrity, there is larger chance that the file could become corrupted. This is because as the files get larger, the chances of the files getting corrupted increase. As a result, you want some way to check your large file for validity before you try to use it.</p><p>Ideally, you might want to do a basic Unix command (e.g. <span class=\"wysiwyg-font-tt\">diff downloadedFile originalFile</span>) to check your downloaded file against the original for equality, but you can't check for equality unless you actually had the original file locally, which you don't! That was the whole reason why you were downloading it in the first place! Instead, many people who host these large files will <i>also</i>\u00a0<b><span class=\"wysiwyg-color-blue\">hash</span></b>\u00a0the file and post the hash value, which is just an integer (typically represented as a hexadecimal number) that you can easily copy (or just read) without any worries of corruption. You can then download the large file, compute a hash value from it, and just visually compare your file's hash value against the original one listed online:</p><p></p><ul><li>If your hash value is <i>different</i>, the file you downloaded does not match the original (because of the <b>Property of Equality</b>, which is a <b>must</b>\u00a0for a <b><span class=\"wysiwyg-color-green\">hash function</span></b>\u00a0to be valid), so something must have gotten corrupted during the download process</li><li>If your hash value <i>matches</i> the one online, even though there is <i>technically</i>\u00a0still a chance that your file is different than the original (because the <b>Property of Inequality</b>\u00a0is simply a \"nice feature,\" but not a requirement), the <b><span class=\"wysiwyg-color-green\">hash functions</span></b>\u00a0used by these <b><span class=\"wysiwyg-color-blue\">hashing</span></b>\u00a0tools are very good, so you can assume that the chance that your file being corrupted is negligible<br></li></ul><p></p><p>If you are curious to learn more about using <b><span class=\"wysiwyg-color-blue\">hashing</span></b>\u00a0to check a file for validity, be sure to check out the main <b><span class=\"wysiwyg-color-green\">hash functions</span></b>\u00a0used for this task today: <a href=\"https://en.wikipedia.org/wiki/MD5\" rel=\"nofollow\">MD5</a>, <a href=\"https://en.wikipedia.org/wiki/SHA-1\" rel=\"nofollow\">SHA-1</a>, and <a href=\"https://en.wikipedia.org/wiki/Cyclic_redundancy_check\" rel=\"nofollow\">CRC</a>\u00a0(where CRC32 is typically the most popular out of the types of CRC).</p>", "tests_archive": null, "source": null, "subtitle_files": [], "options": {}, "feedback_correct": "", "video": null}, "id": "122034", "time": "2016-09-06T23:46:51.211940"}