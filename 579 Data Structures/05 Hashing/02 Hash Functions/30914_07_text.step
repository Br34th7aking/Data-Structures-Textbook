{"block": {"tests_archive": null, "feedback_correct": "", "subtitle_files": [], "text": "<p>Thus far, we have seen examples of\u00a0<b><span class=\"wysiwyg-color-green\">hash functions</span></b>\u00a0that were good (or even\u00a0<i>perfect</i>, like <i>h</i>(<i>k</i>) in the previous step).\u00a0Nevertheless, picking an unfortunate size for our array or choosing a bad indexing\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b>\u00a0(like\u00a0<i>H</i>(<i>k</i>) in the previous step) can still result in numerous collisions.</p><p>Also, we saw that, if a given object <i>key</i>\u00a0has\u00a0<i>k</i> elements (e.g. a string with\u00a0<i>k</i> characters, or a list with\u00a0<i>k</i> numbers), a good\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b>\u00a0for\u00a0<i>key</i> will incorporate each of\u00a0<i>key</i>'s\u00a0<i>k</i> elements into <i>key</i>\ufeff's\u00a0hash value, meaning a good\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> would be\u00a0<b>O(<i>k</i>)</b>. Also, to avoid collisions that come about when comparing objects containing the same elements but in a different order, we need the arithmetic we perform to be\u00a0<b>non-commutative</b>.<b></b></p><p>Thus far, we have discussed\u00a0<b><span class=\"wysiwyg-color-blue\">hashing</span></b> and the motivation for\u00a0<b><span class=\"wysiwyg-color-purple\">Hash Tables</span></b>, and we have defined what a\u00a0<b><span class=\"wysiwyg-color-green\">hash function</span></b> is as well as what makes one good or bad, but we still have yet to actually formally discuss\u00a0<b><span class=\"wysiwyg-color-purple\">Hash Tables</span></b> themselves. In the next section, we will finally shed light on this seemingly mystical data structure that achieves O(1) average-case finds, insertions, and removals.</p>", "feedback_wrong": "", "options": {}, "subtitles": {}, "name": "text", "source": null, "video": null, "animation": null}, "time": "2016-09-11T01:10:17.747655", "id": "118620"}