{"id": "121348", "time": "2016-09-01T21:51:46.892774", "block": {"subtitle_files": [], "feedback_wrong": "", "options": {}, "name": "text", "subtitles": {}, "tests_archive": null, "source": null, "text": "<p>The first type of <b><span class=\"wysiwyg-color-red\">collision resolution strategy</span></b> for <b><span class=\"wysiwyg-color-purple\">Hash Tables</span> </b>that we will discuss is called\u00a0<b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b>. The<b> </b>idea behind this strategy is extremely simple; if an inserting object wants to be at a location that is already taken by another object, attempt to re-insert the object in the next available index. <b><span class=\"wysiwyg-color-blue\"><br></span></b></p><p><span class=\"wysiwyg-color-black\">Here is an intuitive example in which the <b><span class=\"wysiwyg-color-green\">hash function</span></b> is defined as <i>H</i>(<i><b>k</b></i>) = ((<i><b>k</b> </i>+3) % <i><b>m</b></i>), where <i><b>k</b> </i>is the ASCII value of the key and <i><b>m</b></i> is the size of the backing array (we add 3 to<b> </b><i><b>k</b></i> to have the letter <b>a</b> hash to index 0 for simplicity): <br></span></p><img alt=\"\" src=\"https://ucarecdn.com/737d90c0-ddf4-4cdc-b4f4-33ac9b6bf8ea/\" width=\"400\" height=\"356\"><br><b><span class=\"wysiwyg-color-red\">STOP and Think:</span></b> <span class=\"wysiwyg-color-red\"><span class=\"wysiwyg-color-black\">Suppose you are inserting a new key when the entire <b><span class=\"wysiwyg-color-purple\">hash table</span></b> is already full; what do you expect the algorithm to do?</span></span><br>", "feedback_correct": "", "video": null, "animation": null}}