{"id": "121395", "block": {"subtitles": {}, "source": null, "video": null, "feedback_wrong": "", "options": {}, "animation": null, "text": "<p>As you hopefully agree, <b><span class=\"wysiwyg-color-blue\">Linear Probing </span></b><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\">is a fairly simple and straightforward solution to <b><span class=\"wysiwyg-color-red\">collision resolution</span></b>. What's the catch? <br></span></span></p><p><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\">We had originally introduced\u00a0<b><span class=\"wysiwyg-color-purple\">Hash Tables</span></b> </span><span class=\"wysiwyg-color-purple\"><span class=\"wysiwyg-color-black\">because we wanted to achieve extremely fast find, insert, and remove operations. Unfortunately,\u00a0</span></span><b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b> <span class=\"wysiwyg-color-black\">slows us down extensively. As you might have noticed while doing the previous exercises, </span><b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b> <span class=\"wysiwyg-color-black\">can resort to having to <i>linearly scan</i> the <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> to find an open slot to insert a key. As a result, </span><span class=\"wysiwyg-color-black\">our <b>worst-case</b> time complexity for an insert operation becomes <b>O(</b><i><b>N</b></i><b>)</b>. </span><span class=\"wysiwyg-color-black\">The same goes for attempting to <i>find</i> a key in the </span><b><span class=\"wysiwyg-color-purple\">Hash Table</span></b><span class=\"wysiwyg-color-black\">: in the worst-case scenario, we must linearly scan the entire <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> to see if the key exists. <span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\">However, with a table that is not very full, we can in fact  achieve an <i><b>average</b></i><b>-case O(1)</b> time complexity for our operations.</span></span><br></span></span></p><p><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\">Another negative quality about <b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b>\u00a0that you may have noticed is that it results in clusters, or \"clumps,\" of keys in the <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>. This comes as a direct result of the keys being quite cozy creatures and attempting to re-insert themselves right <i>next</i> to another key. We also see the same problem when clusters of \"deleted\" flags start to appear as we attempt to delete elements. Consequently, once all these clusters start dominating the <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>, our performance deteriorates extremely fast.<br></span></span></p><p><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\">So how can we avoid being slowed down by clusters of keys? </span></span><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\"><br></span></span></p>", "feedback_correct": "", "tests_archive": null, "subtitle_files": [], "name": "text"}, "time": "2016-09-03T01:11:22.834302"}