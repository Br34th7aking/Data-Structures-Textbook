{"id": "121623", "time": "2016-09-09T17:01:09.919232", "block": {"subtitle_files": [], "text": "<p></p><p><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\">The solution to avoid keys having a higher probability to insert themselves into certain locations--thereby avoiding the creation of clumps -- is pretty simple: designate a <i>different</i> offset for each particular key. Once we do this, we ensure that we have an <i>equal</i> probability for a key to hash to any slot. For example, suppose we start with the <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> below:<br></span></span></p><p><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\"><img title=\"Image: https://ucarecdn.com/1a0f102f-777c-4445-bd7a-2e650a8f9a3b/\" alt=\"\" src=\"https://ucarecdn.com/1a0f102f-777c-4445-bd7a-2e650a8f9a3b/\"><br></span></span></p><p><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\">Our initial problem in <span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b></span> was that slot 1 had an unequal probability of getting filled (a\u00a0$ \\frac{2}{5} $ chance). This was because slot 1 had two ways of getting filled: if </span></span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-blue\">key</span></b></span><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\"> <i>k</i> initially hashed to index 1 OR if we initially hit index 0, thereby guaranteeing that the </span></span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-blue\">key</span></b></span><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\"><b>\u00a0</b><i>k</i> would also hash to index 1. By designating a <i>different</i> offset for each particular </span></span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-blue\">key </span></b></span><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\">however, </span></span><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\">we no longer have the guarantee that just because </span></span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-blue\">key</span></b></span><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\"> <i>k</i> initially <span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\">hashed</span></span> to index 0, it will also hash to index 1. As a result, there is no guarantee for a <i>particular</i> area in the <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> to face a higher probability for </span></span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-blue\">keys</span></b></span><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\"> to hash there and we thus consequently eliminate the inevitable creation of clumps.<br></span></span></p><p><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\">We do what is described above using a technique called </span></span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-purple\">Double Hashing</span></b></span><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\">. The concept behind the <b><span class=\"wysiwyg-color-red\">collision resolution strategy</span></b> of </span></span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-purple\">Double Hashing</span></b></span><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\"> is to use two hash functions: $ H_1(k) $ to calculate the hashing index and\u00a0$ H_2(k) $ to calculate the <i>offset</i> in the probing sequence<b>.</b> <span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\"><br></span></span></span></span></p><p><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\"><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\">More formally,\u00a0$ H_2(k) $<span></span><span></span><span></span></span></span> should return an integer value between 1 and <i>M-1</i>, where <i>M</i> is the size of the<b> <span class=\"wysiwyg-color-purple\">hash table</span></b>. <span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\">You can think of<b> </b></span></span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b></span><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\"> as originally having\u00a0$ H_2(k)=1 $ (i.e., we always moved the key 1 index away from its original location). </span></span>A common choice in</span></span><span class=\"wysiwyg-color-black\"> <b><span class=\"wysiwyg-color-purple\">Double Hashing</span></b></span><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\"> is to set $  H_2(K)=1+\\frac{K}{M}\\ \\%\\ (M\u22121)  $).</span></span><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\"><br></span></span></p><p><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\">Here is the pseudo-code to implement <span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-purple\">Double Hashing</span></b></span> when inserting a key <i><b></b>k<b></b></i>, in a table of size <i>M</i> with a backing array called <b>arr,</b> using a <b><span class=\"wysiwyg-color-green\">hash function </span></b><span class=\"wysiwyg-color-green\"><span class=\"wysiwyg-color-black\">H(<b><i></i></b><i>k</i><b><i></i></b>). Note that </span></span>the pseudocode for  <span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-purple\">Double Hashing</span></b></span> is extremely similar to <span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\"><b> </b></span></span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b></span> (the changes are highlighted with the comment #NEW):<br></span></span></p><p></p><pre><code class=\"python\">insert_DoubleHash(Key <b></b><b>k</b><b></b>, int <b><i></i></b><i><b></b></i><b>M</b><b><i></i></b>):\n\n    index = H1(<b>k</b>) \n\u2003   offset = H2(<b>k</b>) #NEW\n\n    while(true):\n\n        #check for duplicate insertions\n        if <b>arr</b>[index] == <b>k</b>:\n\n            return\n\n        #check if it is safe to insert \n        else if <b>arr</b>[index] == NULL:\n\n            <b>arr</b>[index] = <b>k</b>\n\n            return\n\n        #there is a collision, re-calculate index\n        else:\n\n            index = (index + offset) % <b>M </b>#NEW<b>\n\n        </b>#we have tried all possible indexes and we are now going in a circle<b>\n        </b>if index == H(<b>k</b>):\n\n            throw an exception OR enlarge table </code></pre><br><b><span class=\"wysiwyg-color-red\">STOP and Think:</span></b> Is <b><span class=\"wysiwyg-color-purple\">Double Hashing</span></b> an <b>open addressing</b> <b><span class=\"wysiwyg-color-red\">collision resolution strategy<span class=\"wysiwyg-color-black\">\ufeff</span></span></b><span class=\"wysiwyg-color-red\"><span class=\"wysiwyg-color-black\">?</span></span><b><span class=\"wysiwyg-color-red\"><span class=\"wysiwyg-color-black\"><br></span></span></b><p></p><p></p>", "feedback_correct": "", "tests_archive": null, "subtitles": {}, "source": null, "name": "text", "video": null, "feedback_wrong": "", "options": {}, "animation": null}}