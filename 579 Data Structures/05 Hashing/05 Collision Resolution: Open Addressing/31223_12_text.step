{"id": "122112", "block": {"name": "text", "tests_archive": null, "animation": null, "feedback_wrong": "", "subtitle_files": [], "video": null, "options": {}, "text": "<p>Another collision resolution strategy that solves <b><span class=\"wysiwyg-color-blue\">Linear Probing's</span></b> clumping problem is called <b><span class=\"wysiwyg-color-green\">Random Hashing</span></b>. The idea behind <b><span class=\"wysiwyg-color-green\">Random Hashing</span></b> is that we use a pseudorandom number generator <b>seeded by the key</b> to produce a <b>sequence</b> of hash values. Once an individual hash value is returned, the algorithm just mods it by the capacity of the <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>, <i>M</i>, to produce a valid index that the key can map to. If there is a collision, the algorithm just chooses the next hash value in the pseudorandomly-produced sequence of hash values.</p><p>Below is pseudocode for implementing <b><span class=\"wysiwyg-color-green\">Random Hashing</span></b> when inserting a key <span class=\"wysiwyg-font-tt\">k</span> into a <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> of capacity <span class=\"wysiwyg-font-tt\">M</span> with a backing array called <span class=\"wysiwyg-font-tt\">arr</span>:</p><p></p><pre><code class=\"cpp\"><b>insert_RandomHash(k): // Insert k using Random Hashing as the collision resolution strategy\n</b>\n    RNG = new Pseudorandom Number Generator seeded with k\n    nextNumber = next pseudorandom number generated by RNG\n    index = nextNumber % M\n\n    Loop infinitely:\n\n        // check for duplicate insertions (not allowed)\n        if arr[index] == k:\n            return\n\n        // check if the slot of the array is empty (i.e., it is safe to insert)\n        else if arr[index] == NULL:\n            arr[index] = k\n            return\n\n        // there is a collision, so re-calculate index\n        else:\n            nextNumber = next pseudorandom number generated by RNG\n            index = nextNumber % M\n\n        // we have tried all possible indices and we are now going in a circle\n        if all M locations have been probed:\n            throw an exception OR enlarge arr and rehash all existing elements</code></pre><p></p><p>An important nuance of <b><span class=\"wysiwyg-color-green\">Random Hashing</span></b> is that we must seed the pseudorandom number generator by the key. Why? Because we need to make sure that our <b><span class=\"wysiwyg-color-green\">hash function</span></b> is deterministic (i.e., that it will <i>always</i> produce the same hash value sequence for the same key). Therefore, the only way we can do that is to guarantee to always use the same seed: the key we are currently hashing.</p><p>In practice, <b><span class=\"wysiwyg-color-green\">Random Hashing</span></b> is considered to work just as well as <b><span class=\"wysiwyg-color-purple\">Double Hashing</span></b>. However, <i>very good</i> pseudo random generation can be an inefficient procedure (i.e., polynomial time) and as a \nresult, it is more common to just stick with <b><span class=\"wysiwyg-color-purple\">Double Hashing</span></b>.</p>", "source": null, "subtitles": {}, "feedback_correct": ""}, "time": "2016-09-12T22:31:30.069957"}