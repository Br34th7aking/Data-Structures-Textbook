{"id": "121801", "time": "2016-09-01T21:51:43.230187", "block": {"subtitle_files": [], "feedback_wrong": "", "options": {}, "name": "text", "subtitles": {}, "tests_archive": null, "source": null, "text": "So what does all of this analysis tell us at the end of the day? The analysis illustrates that as the size of our data grows, collisions become inevitable. Of course we will often resort to re-sizing the backing array of our <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> to be bigger in order to <i>avoid</i> collisions, but we have now seen that it is not impossible for even the first two inserting\u00a0<b><span class=\"wysiwyg-color-blue\">keys</span></b> to collide. As a result, it becomes important to research good <b><span class=\"wysiwyg-color-red\">collision resolution strategies</span></b>. <span class=\"wysiwyg-color-purple\"><span class=\"wysiwyg-color-black\">A </span></span><b><span class=\"wysiwyg-color-red\">collision resolution strategy</span></b> can simply be thought of as what the <b><span class=\"wysiwyg-color-blue\">hashing</span></b> algorithm should do when an inserting key wants to be in a  <b><span class=\"wysiwyg-color-purple\">hash table</span></b> location that is already taken by another key. We will explore many different <b><span class=\"wysiwyg-color-red\">collision resolution strateg</span></b><b><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-red\">ies</span> </span></b>in detail in the upcoming lessons. <br><span class=\"wysiwyg-color-purple\"><span class=\"wysiwyg-color-black\"><br></span></span>", "feedback_correct": "", "video": null, "animation": null}}