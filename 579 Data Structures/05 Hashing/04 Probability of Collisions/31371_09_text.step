{"id": "122023", "block": {"subtitles": {}, "source": null, "video": null, "feedback_wrong": "", "options": {}, "animation": null, "text": "<p>We have now seen why, based on probabilistic analysis, it is important to use a <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> that has a capacity larger than the amount of keys we expect to insert in order to avoid collisions. However, it is important to note that we assumed that our keys are equally likely to be <b><span class=\"wysiwyg-color-blue\">hashed</span></b> to each of our <i>M</i>\u00a0indices, but is this a fair assumption? Well, in the extreme case, if we were to explicitly make our <b><span class=\"wysiwyg-color-green\">hash function</span></b> <i>H</i>(<i>k</i>) = 1, then this would not be a fair assumption. However, we know that this is a bad <b><span class=\"wysiwyg-color-green\">hash function</span></b>, and as a result, we would never use it. We would of course want to use a  <b><span class=\"wysiwyg-color-green\">hash function</span></b> that creates as close to a fully random uniform distribution of keys as possible. How do we do that?</p><p>In order to create the most uniformly-distributed <b><span class=\"wysiwyg-color-green\">hash function</span></b>, our goal is to have a unique <i>k</i> that satisfies the equation <i>a</i>*<i>k</i> % <i>M</i> = <i>index</i>, where <i>a</i> is an arbitrary integer constant, <i>k</i> is the integer hash value of the inserting key, and <i>M</i> is the size of the <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>. So what is this equation saying? Well ideally, we want every key k to map to its own index; however, we know that that it is inevitable for certain multiples of <i>k</i> since we are dealing with a fixed size <i>M</i>. For example, suppose <i>M = 5, </i>then we know that it is inevitable for both the keys 5 and 10 to map to index 0 since we only have an initial <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> of capacity 5. We also know that it is inevitable for any key to <i>not</i> map to index 0 once it is multiplied by <i>M, </i>because it automatically becomes a multiple of the value we are modding by. For example, suppose <i>M = 5 </i>and we have two  keys that are of values 1 and 4 that initially hash to index 1 and 4 respectively, the moment we multiply both by 5 they hash to index 0 and collide.</p><p>However, beyond those two cases, we do not want to be prone to any more possibilities of collisions! For example, suppose <i>M = 6,</i> keys 1 and 4 themselves would map to indexes 1 and 4, respectively. However, the moment we multiply  keys 1 and  4 by 2, they both end up colliding at index 2. If we were to multiply keys 2 and 4 by 3, they would end up colliding at index 0.</p><p>So whats going on in the last example? The problem is that <i>M</i> is not prime (i.e., <i>M</i> has multiples other than 1 and itself). As a result, we now face a higher probability that originally unique keys can collide once they share a multiple of the size of the Hash Table (e.g. both 2 and 3 were multiples of <i>M</i> = 6 in the example). With the sharing of multiples, we now begin to face clusters in the  Hash Table where more keys want to map to the same location and we thus face a largely un-equal distribution and an increase in collisions.</p><p>As a result, when increasing the size of our Hash Table, we always want to round to the next nearest prime number.</p>", "feedback_correct": "", "tests_archive": null, "subtitle_files": [], "name": "text"}, "time": "2016-09-03T01:11:12.287631"}