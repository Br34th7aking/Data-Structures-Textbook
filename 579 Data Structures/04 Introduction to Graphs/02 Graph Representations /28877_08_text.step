{"block": {"video": null, "tests_archive": null, "feedback_correct": "", "animation": null, "text": "<p>So how would we go about making an adjacency list for a <i>weighted</i> graph? This might be a bit less intuitive than it was for the adjacency matrix since we no longer have a space where we could just write in the weight of each edge. As a result,  one of the ways to represent a weighted graph would be to <i>make</i> space to store the weights of each edge. For example, we could store each entry of our adjacency list as a pair (<b><i>v</i></b>,\u00a0<b><i>c</i></b>), where <b><i>v</i> </b>would be the destination vertex (just as before) and <b><i>c</i></b> would now be the cost of the edge. <br></p><p>Take a look at the example below:</p><img width=\"777\" src=\"https://ucarecdn.com/5196b599-b5f6-4f0e-b528-161d5c30b253/\" alt=\"\" height=\"284\"><br>Now that we have learned about different ways to store different types of graphs, it is time to discover how we can go about using<i> </i>these representations to not just <i>store</i> a graph, but to also be able to <i>efficiently traverse</i> it. <i><br></i><br>", "subtitle_files": [], "subtitles": {}, "feedback_wrong": "", "name": "text", "source": null, "options": {}}, "id": "117885", "time": "2016-09-14T00:11:09.380719"}