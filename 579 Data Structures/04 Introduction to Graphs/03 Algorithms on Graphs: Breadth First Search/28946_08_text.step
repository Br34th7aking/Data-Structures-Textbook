{"id": "111803", "block": {"feedback_correct": "", "name": "text", "feedback_wrong": "", "text": "<p>In terms of the actual implementation of <b><span class=\"wysiwyg-color-green\">Breadth First Search</span></b>, we take advantage of the <b>queue</b> ADT to determine the order in which to explore vertices. The intuition behind choosing a queue for <b><span class=\"wysiwyg-color-green\">BFS</span></b> stems from a queue's <i>first-in first-out</i> property. With this property, we guarantee that we will explore all the vertices enqueued (put on the queue) first, before moving on to the vertices adjacent to the next dequeued vertex. <br></p>\n\n\n\n\n\n\n\n\n\n\n<p></p><pre><code class=\"\"><p><b>BFSShortestPath(u,v):</b><br>\u00a0   q = an empty queue<br>\u00a0   add (0,u) to q // (0,u) -&gt; (length from u, current vertex)<br>\u00a0   while q is not empty:<br>\u00a0 \u00a0     (length,curr) = q.dequeue()<br>\u00a0 \u00a0     if curr == v: // if we have reached the vertex we are searching for<br>\u00a0 \u00a0 \u00a0       return length<br>\u00a0 \u00a0     for all outgoing edges (curr,w) from curr: // otherwise explore all neighbors\n            if w has not yet been visited:\n                add (length+1,w) to q\n    return \"FAIL\" // if I reach this point, then no path exists from u to v</p></code></pre>", "subtitle_files": [], "source": null, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2016-09-02T19:35:52.155149"}