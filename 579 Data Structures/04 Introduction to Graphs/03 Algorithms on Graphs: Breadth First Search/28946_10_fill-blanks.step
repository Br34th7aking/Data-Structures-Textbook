{"block": {"tests_archive": null, "feedback_correct": "", "subtitle_files": [], "text": "<p><b><span class=\"wysiwyg-color-purple\">EXERCISE BREAK:</span>\u00a0</b>We now know that <b><span class=\"wysiwyg-color-green\">Breadth First Search</span></b> can perform well to find the shortest path between vertex <i>u </i>to <i>v</i>. But <i>how</i> well can it perform? Let's look at another pseudocode of <b><span class=\"wysiwyg-color-green\">BFS</span></b> to derive its worst-case Big-O time complexity. <br></p><p>Choose the tightest time complexity (in Big-O notation) for the corresponding line of code. Note that |<i>V</i>|<i></i> corresponds to the\u00a0<i>total number of vertices</i> in the graph and |<i>E</i>|<i></i> corresponds to the <i>total number of edges</i> in the graph. <br></p><p></p><p></p>", "feedback_wrong": "", "options": {}, "subtitles": {}, "name": "fill-blanks", "source": {"is_case_sensitive": true, "components": [{"options": [], "type": "text", "text": "<code>BFS(s):\n    <br>&emsp;&emsp;&emsp;&emsp; initially, give all vertices in the graph a distance of INFINITY</code>"}, {"options": [{"is_correct": false, "text": "O(1)"}, {"is_correct": true, "text": "O(|V|)"}, {"is_correct": false, "text": "O(|E|)"}, {"is_correct": false, "text": "O(|V| + |E|)"}], "type": "select", "text": ""}, {"options": [], "type": "text", "text": "<code><br>   &emsp;&emsp;&emsp;&emsp; start at s; give s distance = 0</code>"}, {"options": [{"is_correct": true, "text": "O(1)"}, {"is_correct": false, "text": "O(|V|)"}, {"is_correct": false, "text": "O(|E|)"}, {"is_correct": false, "text": "O(|V| + |E|)"}], "type": "select", "text": ""}, {"options": [], "type": "text", "text": "<code><br>  &emsp;&emsp;&emsp;&emsp;  enqueue s into a queue</code>"}, {"options": [{"is_correct": true, "text": "O(1)"}, {"is_correct": false, "text": "O(|V|)"}, {"is_correct": false, "text": "O(|E|)"}, {"is_correct": false, "text": "O(|V| + |E|)"}], "type": "select", "text": ""}, {"options": [], "type": "text", "text": "<code><br>    &emsp;&emsp;&emsp;&emsp;    while the queue is not empty:</code>"}, {"options": [{"is_correct": false, "text": "O(1)"}, {"is_correct": false, "text": "O(|V|)"}, {"is_correct": true, "text": "O(|E|)"}, {"is_correct": false, "text": "O(|V| + |E|)"}], "type": "select", "text": ""}, {"options": [], "type": "text", "text": "<code><br>     &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;   dequeue the vertex v from the head of the queue</code>\n         "}, {"options": [{"is_correct": true, "text": "O(1)"}, {"is_correct": false, "text": "O(|V|)"}, {"is_correct": false, "text": "O(|E|)"}, {"is_correct": false, "text": "O(|V| + |E|)"}], "type": "select", "text": ""}, {"options": [], "type": "text", "text": "<code><br>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;      for each of v's adjacent nodes that have not yet been visited:</code>"}, {"options": [{"is_correct": false, "text": "O(1)"}, {"is_correct": false, "text": "O(|V|)"}, {"is_correct": true, "text": "O(|E|)"}, {"is_correct": false, "text": "O(|V| + |E|)"}], "type": "select", "text": ""}, {"options": [], "type": "text", "text": "<code><br>    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;        mark its distance as as 1 + distance to v</code>"}, {"options": [{"is_correct": true, "text": "O(1)"}, {"is_correct": false, "text": "O(|V|)"}, {"is_correct": false, "text": "O(|E|)"}, {"is_correct": false, "text": "O(|V| + |E|)"}], "type": "select", "text": ""}, {"options": [], "type": "text", "text": "<code><br>     &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;       enqueue it in the queue</code>"}, {"options": [{"is_correct": true, "text": "O(1)"}, {"is_correct": false, "text": "O(|V|)"}, {"is_correct": false, "text": "O(|E|)"}, {"is_correct": false, "text": "O(|V| + |E|)"}], "type": "select", "text": ""}]}, "video": null, "animation": null}, "time": "2016-09-11T01:09:16.226871", "id": "111839"}