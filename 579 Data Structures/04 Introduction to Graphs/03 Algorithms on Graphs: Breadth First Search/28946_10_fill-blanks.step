{"id": "111839", "block": {"feedback_correct": "", "name": "fill-blanks", "feedback_wrong": "", "text": "<p><b><span class=\"wysiwyg-color-purple\">EXERCISE BREAK:</span>\u00a0</b>We now know that <b><span class=\"wysiwyg-color-green\">Breadth First Search</span></b> can perform well to find the shortest path between vertex <i>u </i>to <i>v</i>. But <i>how</i> well can it perform? Let's look at another pseudocode of <b><span class=\"wysiwyg-color-green\">BFS</span></b> to derive its worst-case Big-O time complexity. <br></p><p>Choose the tightest time complexity (in Big-O notation) for the corresponding line of code. Note that |<i>V</i>|<i></i> corresponds to the\u00a0<i>total number of vertices</i> in the graph and |<i>E</i>|<i></i> corresponds to the <i>total number of edges</i> in the graph. <br></p><p></p><p></p>", "subtitle_files": [], "source": {"is_case_sensitive": true, "components": [{"text": "<code>BFS(s):\n    <br>&emsp;&emsp;&emsp;&emsp; initially, give all vertices in the graph a distance of INFINITY</code>", "type": "text", "options": []}, {"text": "", "type": "select", "options": [{"text": "O(1)", "is_correct": false}, {"text": "O(|V|)", "is_correct": true}, {"text": "O(|E|)", "is_correct": false}, {"text": "O(|V| + |E|)", "is_correct": false}]}, {"text": "<code><br>   &emsp;&emsp;&emsp;&emsp; start at s; give s distance = 0</code>", "type": "text", "options": []}, {"text": "", "type": "select", "options": [{"text": "O(1)", "is_correct": true}, {"text": "O(|V|)", "is_correct": false}, {"text": "O(|E|)", "is_correct": false}, {"text": "O(|V| + |E|)", "is_correct": false}]}, {"text": "<code><br>  &emsp;&emsp;&emsp;&emsp;  enqueue s into a queue</code>", "type": "text", "options": []}, {"text": "", "type": "select", "options": [{"text": "O(1)", "is_correct": true}, {"text": "O(|V|)", "is_correct": false}, {"text": "O(|E|)", "is_correct": false}, {"text": "O(|V| + |E|)", "is_correct": false}]}, {"text": "<code><br>    &emsp;&emsp;&emsp;&emsp;    while the queue is not empty:</code>", "type": "text", "options": []}, {"text": "", "type": "select", "options": [{"text": "O(1)", "is_correct": false}, {"text": "O(|V|)", "is_correct": false}, {"text": "O(|E|)", "is_correct": true}, {"text": "O(|V| + |E|)", "is_correct": false}]}, {"text": "<code><br>     &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;   dequeue the vertex v from the head of the queue</code>\n         ", "type": "text", "options": []}, {"text": "", "type": "select", "options": [{"text": "O(1)", "is_correct": true}, {"text": "O(|V|)", "is_correct": false}, {"text": "O(|E|)", "is_correct": false}, {"text": "O(|V| + |E|)", "is_correct": false}]}, {"text": "<code><br>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;      for each of v's adjacent nodes that have not yet been visited:</code>", "type": "text", "options": []}, {"text": "", "type": "select", "options": [{"text": "O(1)", "is_correct": false}, {"text": "O(|V|)", "is_correct": false}, {"text": "O(|E|)", "is_correct": true}, {"text": "O(|V| + |E|)", "is_correct": false}]}, {"text": "<code><br>    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;        mark its distance as as 1 + distance to v</code>", "type": "text", "options": []}, {"text": "", "type": "select", "options": [{"text": "O(1)", "is_correct": true}, {"text": "O(|V|)", "is_correct": false}, {"text": "O(|E|)", "is_correct": false}, {"text": "O(|V| + |E|)", "is_correct": false}]}, {"text": "<code><br>     &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;       enqueue it in the queue</code>", "type": "text", "options": []}, {"text": "", "type": "select", "options": [{"text": "O(1)", "is_correct": true}, {"text": "O(|V|)", "is_correct": false}, {"text": "O(|E|)", "is_correct": false}, {"text": "O(|V| + |E|)", "is_correct": false}]}]}, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2016-09-07T23:37:38.296962"}