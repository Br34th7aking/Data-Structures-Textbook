{"id": "111839", "block": {"name": "fill-blanks", "feedback_correct": "", "animation": null, "subtitle_files": [], "video": null, "feedback_wrong": "", "options": {}, "source": {"components": [{"options": [], "text": "<code>BFS(s):\n    <br>&emsp;&emsp;&emsp;&emsp; initially, give all vertices in the graph a distance of INFINITY</code>", "type": "text"}, {"options": [{"is_correct": false, "text": "O(1)"}, {"is_correct": true, "text": "O(|V|)"}, {"is_correct": false, "text": "O(|E|)"}, {"is_correct": false, "text": "O(|V| + |E|)"}], "text": "", "type": "select"}, {"options": [], "text": "<code><br>   &emsp;&emsp;&emsp;&emsp; start at s; give s distance = 0</code>", "type": "text"}, {"options": [{"is_correct": true, "text": "O(1)"}, {"is_correct": false, "text": "O(|V|)"}, {"is_correct": false, "text": "O(|E|)"}, {"is_correct": false, "text": "O(|V| + |E|)"}], "text": "", "type": "select"}, {"options": [], "text": "<code><br>  &emsp;&emsp;&emsp;&emsp;  enqueue s into a queue</code>", "type": "text"}, {"options": [{"is_correct": true, "text": "O(1)"}, {"is_correct": false, "text": "O(|V|)"}, {"is_correct": false, "text": "O(|E|)"}, {"is_correct": false, "text": "O(|V| + |E|)"}], "text": "", "type": "select"}, {"options": [], "text": "<code><br>    &emsp;&emsp;&emsp;&emsp;    while the queue is not empty:</code>", "type": "text"}, {"options": [{"is_correct": false, "text": "O(1)"}, {"is_correct": false, "text": "O(|V|)"}, {"is_correct": true, "text": "O(|E|)"}, {"is_correct": false, "text": "O(|V| + |E|)"}], "text": "", "type": "select"}, {"options": [], "text": "<code><br>     &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;   dequeue the vertex v from the head of the queue</code>\n         ", "type": "text"}, {"options": [{"is_correct": true, "text": "O(1)"}, {"is_correct": false, "text": "O(|V|)"}, {"is_correct": false, "text": "O(|E|)"}, {"is_correct": false, "text": "O(|V| + |E|)"}], "text": "", "type": "select"}, {"options": [], "text": "<code><br>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;      for each of v's adjacent nodes that have not yet been visited:</code>", "type": "text"}, {"options": [{"is_correct": false, "text": "O(1)"}, {"is_correct": false, "text": "O(|V|)"}, {"is_correct": true, "text": "O(|E|)"}, {"is_correct": false, "text": "O(|V| + |E|)"}], "text": "", "type": "select"}, {"options": [], "text": "<code><br>    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;        mark its distance as as 1 + distance to v</code>", "type": "text"}, {"options": [{"is_correct": true, "text": "O(1)"}, {"is_correct": false, "text": "O(|V|)"}, {"is_correct": false, "text": "O(|E|)"}, {"is_correct": false, "text": "O(|V| + |E|)"}], "text": "", "type": "select"}, {"options": [], "text": "<code><br>     &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;       enqueue it in the queue</code>", "type": "text"}, {"options": [{"is_correct": true, "text": "O(1)"}, {"is_correct": false, "text": "O(|V|)"}, {"is_correct": false, "text": "O(|E|)"}, {"is_correct": false, "text": "O(|V| + |E|)"}], "text": "", "type": "select"}], "is_case_sensitive": true}, "text": "<p><b><span class=\"wysiwyg-color-purple\">EXERCISE BREAK:</span>\u00a0</b>We now know that <b><span class=\"wysiwyg-color-green\">Breadth First Search</span></b> can perform well to find the shortest path between vertex <i>u </i>to <i>v</i>. But <i>how</i> well can it perform? Let's look at another pseudocode of <b><span class=\"wysiwyg-color-green\">BFS</span></b> to derive its worst-case Big-O time complexity. <br></p><p>Choose the tightest time complexity (in Big-O notation) for the corresponding line of code. Note that |<i>V</i>|<i></i> corresponds to the\u00a0<i>total number of vertices</i> in the graph and |<i>E</i>|<i></i> corresponds to the <i>total number of edges</i> in the graph. <br></p><p></p><p></p>", "subtitles": {}, "tests_archive": null}, "time": "2016-09-15T15:02:07.657527"}