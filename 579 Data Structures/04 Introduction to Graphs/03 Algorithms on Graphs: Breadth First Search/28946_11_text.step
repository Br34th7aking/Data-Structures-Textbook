{"id": "111804", "time": "2016-09-09T16:59:20.432382", "block": {"subtitle_files": [], "text": "<p>By adding all of the time complexities together from the previous challenge, it may seem at a first glance that we end up with an overall\u00a0<b> O(|</b><i><b>V</b></i><b>|</b><i><b></b></i><b> + |<i>E</i>|<strong>\u00b2</strong>)</b> time complexity. <b>However</b>, this is <i>not </i>actually the case! Take a look at the \"<code>while the queue is not empty</code>\" line; we see that the time complexity is <b>O(|<i>E</i>|)</b>. Now take a look at the the contents of the while loop: more specifically, the \"<code>for each of v's adjacent nodes that have not yet been visited:</code>\" line; we see that the time complexity is also <b>O(|<i>E</i>|)</b>. At first glance, it may seem that having an <b>O(|<i>E</i>|) </b>loop with a <b>O(|<i>E</i>|) </b>body would mean that, for <i>each </i>edge, we would need to iterate through <i>all</i> the edges (which would in fact be <b></b>O(|<i>E</i>|\u00b2)<b></b>.\u00a0<b>However,</b> if you pay attention to the details of the algorithm, you will notice that, in reality, we are merely iterating through only the adjacent edges of one vertex at a time. As a result, we might in practice iterate over some edges more than once in total (if neighbors are shared between vertexes), but we will not need to iterate through <i>all</i> edges <i>each </i>time. <br></p><p>Consequently, when adding the overall run-time complexities, it is common to say that the outer while loop \"takes into account\" the for-loop inside and as a result we can conclude that the tightest time complexity for Breadth First Search is<b> O(|</b><i><b>V</b></i><b>|</b><i><b></b></i><b> + |</b><i><b>E</b></i><b>|</b><i><b></b></i><b>)</b>. This makes it an efficient algorithm to find paths to vertices as we traverse layer-by-layer from our starting point. <br></p><p><span class=\"wysiwyg-color-red\"><b>STOP and Think:</b><span class=\"wysiwyg-color-black\"> Say we have a dense graph (i.e., roughly |<i>V</i>\ufeff|\u00b2 edges) with 1,000,000,000 nodes on which we wish to perform BFS. If each edge in the queue could be represented by even just one byte, roughly how much space would the BFS queue require at its peak?</span></span></p>", "feedback_correct": "", "tests_archive": null, "subtitles": {}, "source": null, "name": "text", "video": null, "feedback_wrong": "", "options": {}, "animation": null}}