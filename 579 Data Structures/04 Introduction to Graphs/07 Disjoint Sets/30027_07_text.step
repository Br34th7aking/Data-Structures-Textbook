{"id": "118011", "block": {"name": "text", "tests_archive": null, "animation": null, "feedback_wrong": "", "subtitle_files": [], "video": null, "options": {}, "text": "<p>\n\n</p><p>Below is the same example as in the previous step:</p><p><img title=\"Image: https://ucarecdn.com/6cee2403-3431-4031-945d-b8489d75d6b0/\" alt=\"\" src=\"https://ucarecdn.com/6cee2403-3431-4031-945d-b8489d75d6b0/\"></p><p>Recall that we arbitrarily chose which sentinel nodes we wanted to use as the parent and child when merging. However, as mentioned before, our overarching goal while building an Up-Tree is to minimize its height because a smaller tree height corresponds to a faster \"find\" operation. Consequently, instead of making the choice arbitrarily, we can perform a \"<span class=\"wysiwyg-color-green\"><b><span class=\"wysiwyg-color-blue\">Union-by-Size</span></b></span>.\" In this insertion tactic, the sentinel node of the <i>smaller </i>set (i.e., the set with less elements) gets attached to the sentinel node of the <i>larger</i>\u00a0set. Thus, the sentinel node of the smaller set becomes the child and the sentinel node of the larger set becomes the parent. Ties can be broken arbitrarily.\n\n</p><p>Below is the result of performing the exact same operation,\u00a0<span class=\"wysiwyg-color-green\"><b>union</b></span>(F, E), by using the\u00a0<b><span class=\"wysiwyg-color-blue\">Union-by-Size</span></b>\u00a0approach. Note that in the original disjoint set above, the sentinel node of F (node F)  has 1 element in its set (node F), and the sentinel node of E (node C) has 3 elements in its set (node C, node D, and node E). As a result,\u00a0 the sentinel node of the <i>larger</i> set (node C) is made the <i>parent</i>, and the sentinel node of the <i>smaller</i> set (F) is made the <i>child</i>.</p><p><img title=\"Image: https://ucarecdn.com/81daf955-5205-4feb-b5d2-5e2a734dd794/\" alt=\"\" src=\"https://ucarecdn.com/81daf955-5205-4feb-b5d2-5e2a734dd794/\"></p><p>Under\u00a0<b><span class=\"wysiwyg-color-blue\">Union-by-Size</span></b>, the only way for the height of a tree resulting from the union of two sets to be\u00a0<i>larger</i> than the heights of both of the two initial sets is if the sets have exactly the same height. As a result, the \"worst case\" for\u00a0<b><span class=\"wysiwyg-color-blue\">Union-by-Size </span></b>is considered to be the situation in which each merge had to merge sets with equal size. For example, say we have a dataset of\u00a0<i>n</i> elements, each in their own set initially. To invoke the worst case, we can perform\u00a0<i>\u207f</i>/\u2082 union operations to form\u00a0<i>\u207f</i>/\u2082 sets, each with exactly 2 elements. Then we can perform\u00a0<i>\u207f</i>/\u2084 union operations to form\u00a0<i>\u207f</i>/\u2084 sets, each with exactly 4 elements. If we keep doing this until we are left with one set with\u00a0<i>n</i> elements, that one set will have the shape of a balanced tree. As a result, the worst-case time complexity of a \"find\" operation in <b><span class=\"wysiwyg-color-blue\">Union-by-Size</span></b> is the same as the worst-case height of a balanced tree: <b>O(log\u00a0</b><i><b>n</b></i><b>)</b>.</p><p></p>", "source": null, "subtitles": {}, "feedback_correct": ""}, "time": "2016-09-12T22:30:37.615862"}