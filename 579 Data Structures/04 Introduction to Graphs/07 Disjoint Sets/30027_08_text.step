{"id": "118011", "time": "2016-09-02T18:28:48.298271", "block": {"animation": null, "text": "<p>\n\n</p><p>Below is the same example as on the previous step:</p><p><img alt=\"\" title=\"Image: https://ucarecdn.com/6cee2403-3431-4031-945d-b8489d75d6b0/\" src=\"https://ucarecdn.com/6cee2403-3431-4031-945d-b8489d75d6b0/\"></p><p>Recall that we arbitrarily chose which sentinel nodes we wanted as the parent and child. However, our overarching goal while building an Up-Tree is to minimize its height because a smaller tree height corresponds to faster \"find\" operations. Instead of making the choice completely arbitrarily,\u00a0 we can perform a \"<span class=\"wysiwyg-color-green\"><b><span class=\"wysiwyg-color-blue\">Union-by-Size</span></b></span>.\" In this insertion tactic, the sentinel node of the <i>smaller </i>set (i.e., the set with less elements) gets attached to the sentinel node of the <i>larger</i>\u00a0set. Thus, the sentinel node of the smaller set becomes the child and the sentinel node of the larger set becomes the parent. Ties can be broken arbitrarily.\n\n</p><p>Below is the result of performing the exact same operation,\u00a0<span class=\"wysiwyg-color-green\"><b>union</b></span>(F, E), but using the\u00a0<b><span class=\"wysiwyg-color-blue\">Union-by-Size</span></b>\u00a0approach. Note that in the original disjoint set above, the sentinel node of F (node F)  has 1 element in its set (F), and the sentinel node of E (node C) has 3 elements in its set (C, D, and E). As a result,\u00a0 the sentinel node of the <i>larger</i> set (C) is made the <i>parent</i>, and the sentinel node of the <i>smaller</i> set (F) is made the <i>child</i>.</p><p><img alt=\"\" title=\"Image: https://ucarecdn.com/81daf955-5205-4feb-b5d2-5e2a734dd794/\" src=\"https://ucarecdn.com/81daf955-5205-4feb-b5d2-5e2a734dd794/\"></p><p>Under\u00a0<b><span class=\"wysiwyg-color-blue\">Union-by-Size</span></b>, the only way for the height of a tree resulting from the union of two sets to be\u00a0<i>larger</i> than the heights of both of the two initial sets is if the sets have exactly the same height. As a result, the worst case for\u00a0<b><span class=\"wysiwyg-color-blue\">Union-by-Size </span></b>is if we constantly merge sets with equal size. Say I have a dataset of\u00a0<i>n</i> elements, each in their own set initially. To invoke the worst case, I can perform\u00a0<i>\u207f</i>/\u2082 union operations to form\u00a0<i>\u207f</i>/\u2082 sets, each with exactly 2 elements. Then, we can perform\u00a0<i>\u207f</i>/\u2084 union operations to form\u00a0<i>\u207f</i>/\u2084 sets, each with exactly 4 elements. If we keep doing this until we are left with one set with\u00a0<i>n</i> elements, that one set will have the shape of a balanced tree. As a result, the worst-case time complexity of a \"find\" operation in <b><span class=\"wysiwyg-color-blue\">Union-by-Size</span></b> is the same as the worst-case height of a balanced tree, which is <b>O(log\u00a0</b><i><b>n</b></i><b>)</b>.</p><p></p>", "options": {}, "feedback_correct": "", "source": null, "subtitle_files": [], "name": "text", "feedback_wrong": "", "subtitles": {}, "tests_archive": null, "video": null}}