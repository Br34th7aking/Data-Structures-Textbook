{"id": "118020", "block": {"subtitles": {}, "source": null, "video": null, "feedback_wrong": "", "options": {}, "animation": null, "text": "<p>We have now introduced the\u00a0<b></b><b>Disjoint Set</b> ADT, which allows us to create sets of elements and to very efficiently perform union and find operations on these sets. Also, we have discussed the\u00a0<b>Up-Tree</b> data structure, which we used to implement the\u00a0<b>Disjoint Set</b> ADT.</p><p>You may have noticed (hopefully triggered by the <b><span class=\"wysiwyg-color-red\">STOP and Think</span></b> question) that\u00a0<b><span class=\"wysiwyg-color-purple\">Union-by-Height</span></b> always produces an Up-Tree that is always either just as good, or many times even better, than the tree produced by\u00a0<b><span class=\"wysiwyg-color-blue\">Union-by-Size</span></b>. However, it turns out that, in practice, people typically choose to use\u00a0<b><span class=\"wysiwyg-color-blue\">Union-by-Size</span></b> when they implement their Up-Trees. The reason why they choose\u00a0<b><span class=\"wysiwyg-color-purple\">Union-by-Size</span></b> over\u00a0<b><span class=\"wysiwyg-color-purple\">Union-by-Height</span></b> is that the\u00a0<i>huge</i> savings come from\u00a0<b><span class=\"wysiwyg-color-red\">path compression</span></b>, but one side effect of\u00a0<b><span class=\"wysiwyg-color-red\">path compression</span></b> (which was the whole point of it) is that the height of a tree (and the subtrees within it) change very frequently. As a result, maintaining accurate information about the <i>heights</i> of sets (which is required for <b><span class=\"wysiwyg-color-purple\">Union-by-Height</span></b>)\u00a0becomes quite difficult because of\u00a0<b><span class=\"wysiwyg-color-red\">path compression</span></b>, whereas maintaining accurate information about the <i>sizes</i> of sets (which is required for <b><span class=\"wysiwyg-color-blue\">Union-by-Size</span></b>)\u00a0is extremely easy (constant-time, actually). As a result, since\u00a0<b><span class=\"wysiwyg-color-red\">path compression</span></b> is our priority, and since the slightly worse results we may potentially get by using \n\n<b><span class=\"wysiwyg-color-blue\">Union-by-Size</span></b> instead of\u00a0<b><span class=\"wysiwyg-color-purple\">Union-by-Height</span></b> is negligible in comparison to the savings we gain from\u00a0<b><span class=\"wysiwyg-color-red\">path compression</span></b>.</p><p>Going back to the example that we had initially introduced in the lesson, by using a\u00a0<b>Disjoint Set</b> implemented using an\u00a0<b>Up-Tree</b>, Sarah can very efficiently solve her problem! In her case, elements of the\u00a0<b>Disjoint Set</b> would be the people she notices, and as she sees individuals\u00a0<i>u</i> and\u00a0<i>v</i> \"connect\", she can simply perform union(<i>u</i>,\u00a0<i>v</i>). When she wants to check if some suspect\u00a0<i>w</i> is connected in some way to Chuck, she can perform find(\"Chuck\") and find(<i>w</i>) and compare the sets they return for equality.</p>", "feedback_correct": "", "tests_archive": null, "subtitle_files": [], "name": "text"}, "time": "2016-09-03T01:10:39.560032"}