{"id": "116968", "block": {"feedback_correct": "", "name": "text", "feedback_wrong": "", "text": "<p>The <b>Disjoint Set</b> is an Abstract Data Type that is optimized to support two particular operations:</p><ul><li><b>Union:</b> Given two elements\u00a0<i>u</i> and\u00a0<i>v</i>, merge the sets to which they belong</li><li><b>Find:</b> Given an element <i>e</i>, return the set to which it belongs</li></ul><p>As a result, a Disjoint Set is also commonly referred to as a \"Union-Find\" data type. Disjoint Sets can be very efficiently implemented using the\u00a0<b></b><b>Up-Tree</b> data structure, which in essence is simply a graph in which all nodes have a single \"parent\" pointer. Nodes that do not have a parent (i.e., the roots of their respective trees) are called\u00a0<b>sentinel nodes</b>, and each sentinel node represents a single set. In the example below, there are 6 sets, each represented by its respective sentinel node (shown in red):\u00a0<i>A</i>,\u00a0<i>C</i>,\u00a0<i>D</i>,\u00a0<i>E</i>,\u00a0<i>F</i>, and\u00a0<i>G</i>.</p><p><img alt=\"\" title=\"Image: https://ucarecdn.com/ab99124a-3230-428a-94f1-0fcb81798209/\" src=\"https://ucarecdn.com/ab99124a-3230-428a-94f1-0fcb81798209/\"></p><p>A disjoint set often starts out as a forest of single-node sets. We begin connecting vertices together by calling the union operation on two vertices at a time, such as what you see in the figure above. By doing so, we slowly begin creating a structure that looks like an upside-down tree<b>\u00a0</b>(i.e., a tree where all pointers point up <i>to the root</i> instead of the usual down <i>from the root</i>), hence the name \"Up-Tree\". We will explore the union operation in more depth later in this lesson.</p><p>The algorithm behind the \"find\" operation of a Disjoint Set implemented as an Up-Tree should hopefully be intuitive. Recall that the sentinel nodes represent (or really name) the sets. As a result, given an element, finding the set to which the element belongs is actually the exact same problem as finding the sentinel node that is the ancestor of the element. As a result, to find an element's set, you can simply start at the element and traverse \"parent\" pointers up the tree until you reach the element's sentinel node (i.e., the ancestor that has no parent). Then, simply return the sentinel node, because the sentinel node \"is\" the element's set.</p><p>Because the \"find\" algorithm traverses up the tree of the given element, it should hopefully be intuitive that the larger the height of the tree an element is in, the slower the \"find\" operation is on that element. As a result, our goal should always be to try to minimize our tree heights as much as possible, as this will translate into faster \"find\" operations.</p>", "subtitle_files": [], "source": null, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2016-09-02T19:36:27.316320"}