{"time": "2016-09-20T20:56:46.891711", "block": {"name": "text", "subtitles": {}, "source": null, "subtitle_files": [], "feedback_wrong": "", "video": null, "animation": null, "feedback_correct": "", "tests_archive": null, "text": "<p>Imagine you are the engineer responsible for setting up the intranet of UC San Diego: given a set of locations\u00a0<b></b><i><b><span class=\"wysiwyg-color-purple\">V</span></b></i> and a set of costs <i><b><span class=\"wysiwyg-color-black\">E</span></b></i><span class=\"wysiwyg-color-black\">\u00a0</span>associated with connecting pairs of locations with cable, your task is to determine the networking layout that minimizes the overall cost of a network where there exists a path\u00a0<i>from</i> each location\u00a0<i>to</i> each location. If your design has even a single pair of locations that cannot reach one another, this can be problematic in the future because individuals at either location will not be able to send each other files. If your design does not minimize the overall cost of such a network, you will have wasted valuable money that could have been spent elsewhere. As such, these two requirements are quite strict.</p><p>Notice that we can trivially transform the Network Design Problem above into a formal computational problem that looks quite similar to other problems we solved previously in this chapter. We can represent UC San Diego as a <b>graph</b>\u00a0in which the locations are represented as\u00a0<b><span class=\"wysiwyg-color-black\">nodes</span></b> (or\u00a0<b><span class=\"wysiwyg-color-black\">vertices</span></b>) and the pairwise location connection possibilities are represented as <b><span class=\"wysiwyg-color-black\">undirected weighted edges</span></b><span class=\"wysiwyg-color-black\">,</span> where the weight associated with an edge is simply the cost of the cables needed to connect the two locations connected by the edge.</p><p>With this graph representation, the Network Design Problem transforms into the formal computational problem: given a graph <b><i>G</i></b><i></i>, defined by a\u00a0set of vertices\u00a0<b><i><span class=\"wysiwyg-color-purple\">V</span></i></b><i></i> and a set of edges\u00a0<b><i><span class=\"wysiwyg-color-black\">E</span></i></b><i></i><span class=\"wysiwyg-color-black\">,</span> return a collection of edges such that the following two constraints are maintained:</p><p></p><ul><li>For each pair of vertices in the graph, there exists a path, constructed only from edges in the returned collection, that connects the two vertices in the pair</li><li>The sum of the weights of the edges in the returned collection is minimized</li></ul><p>Notice that, since it would be redundant to have multiple paths connecting a single pair of <b><span class=\"wysiwyg-color-black\">vertices</span></b><span class=\"wysiwyg-color-black\">\u00a0</span>(if the paths are equal weight, you don't need to keep them all; if not, you would only want to keep the shortest-weight path), our\u00a0<b>subgraph</b> that we return must not contain any cycles. In other words, our subgraph will be a<span class=\"wysiwyg-color-blue\">\u00a0</span><b><span class=\"wysiwyg-color-blue\">tree</span></b>. Specifically, we call a tree that hits all nodes in a graph\u00a0<i>G</i> as a\u00a0<b><span class=\"wysiwyg-color-red\">Spanning Tree</span></b> of\u00a0<i>G</i>. Because we want the Spanning Tree with the smallest overall cost, we want to find a\u00a0<b><span class=\"wysiwyg-color-red\">Minimum Spanning Tree (MST)</span></b>\u00a0of\u00a0<i>G</i>.</p><p>In this section, we will discuss two algorithms for finding\u00a0<b><span class=\"wysiwyg-color-red\">Minimum Spanning Trees</span></b>:\u00a0<b><span class=\"wysiwyg-color-blue\">Prim's Algorithm</span></b> and <b><span class=\"wysiwyg-color-blue\">Kruskal's Algorithm</span></b>.</p>", "options": {}}, "id": "111097"}