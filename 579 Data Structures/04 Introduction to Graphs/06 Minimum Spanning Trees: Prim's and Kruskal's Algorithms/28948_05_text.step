{"id": "116680", "block": {"name": "text", "tests_archive": null, "animation": null, "feedback_wrong": "", "subtitle_files": [], "video": null, "options": {}, "text": " It is important to note that in weighted graphs, we can also run\u00a0<b><span class=\"wysiwyg-color-green\">BFS</span></b> to find an\u00a0<i>arbitrary</i> <b><span class=\"wysiwyg-color-red\">spanning tree</span></b>. However, in weighted graphs, we often care about actually factoring the weights of the edges (cost of the paths). For example, in our original Networking Problem, an <i>arbitrary</i> spanning tree would translate into any network that successfully connects all of the computers at UCSD, but a\u00a0<i>minimum</i> spanning tree will specifically translate into a valid network that has the\u00a0<i>\ufefflowest cost</i>.\u00a0Consequently, it can be useful to find the <b><span class=\"wysiwyg-color-red\">Minimum</span></b> <span class=\"wysiwyg-color-purple\"><b><span class=\"wysiwyg-color-red\">Spanning Tree (MST)</span></b></span> for a graph: \"the least-cost version\" of the graph that is still connected. Formally, an <b><span class=\"wysiwyg-color-red\">MST</span> </b>is a spanning tree that\u00a0 minimizes the total sum of edge weights. <br><br><p>Now that we are factoring in<i> minimum</i> <i> edge weights</i> in our algorithm, we should remember that <b><span class=\"wysiwyg-color-green\">BFS</span></b> didn't always work well in these cases, which is why we originally introduced <span class=\"wysiwyg-color-red\"><b><span class=\"wysiwyg-color-purple\">Dijkstra's Algorithm</span></b></span>. In this case, we will also use a concept from <b><span class=\"wysiwyg-color-purple\">Dijkstra's Algorithm</span></b> to achieve what <b><span class=\"wysiwyg-color-green\">BFS</span></b> couldn't.</p><p>We will introduce two different algorithms that can efficiently produce<b> <span class=\"wysiwyg-color-red\">Minimum Spanning Trees</span></b>: <b><span class=\"wysiwyg-color-blue\">Prim's</span></b> and <span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-blue\">Kruskal's</span>.</b></span></p><p>In general,<br></p><ul><li><b><span class=\"wysiwyg-color-blue\">Prim's Algorithm</span></b> starts with a single vertex from the original graph and builds the <b><span class=\"wysiwyg-color-red\">MST</span></b> by iteratively adding the least costly edges that stem from it (very similar to <b><span class=\"wysiwyg-color-purple\">Dijkstra's Algorithm</span>)</b>.</li><li><b><span class=\"wysiwyg-color-blue\">Kruskal's Algorithm</span></b> starts with a forest of vertices without any edges and builds the <b><span class=\"wysiwyg-color-red\">MST</span></b> by iteratively adding the least costly edges from the entire graph. <br></li></ul><p><br></p>", "source": null, "subtitles": {}, "feedback_correct": ""}, "time": "2016-09-12T22:30:21.842280"}