{"id": "116964", "time": "2016-09-01T21:50:57.379252", "block": {"subtitle_files": [], "feedback_wrong": "", "options": {}, "name": "text", "subtitles": {}, "tests_archive": null, "source": null, "text": "<p>We started this discussion by trying to come up with a good way to design the cabling of UC San Diego's intranet, and we were able to transform the original problem into the task of finding a\u00a0<b><span class=\"wysiwyg-color-red\">Minimum Spanning Tree</span></b> in an <b>undirected weighted graph</b>. Then, throughout this section, we explored two algorithms,\u00a0<b><span class=\"wysiwyg-color-blue\">Kruskal's Algorithm</span></b> and\u00a0<b><span class=\"wysiwyg-color-blue\">Prim's Algorithm</span></b>, both of which solve this computational problem efficiently in <b>O(|</b><i><b>V</b></i><b>| + |</b><i><b>E</b></i><b>|*log(|</b><i><b>E</b></i><b>|))</b> time. We saw that <b><span class=\"wysiwyg-color-blue\">Prim's Algorithm</span></b> was implemented very similarly to <b><span class=\"wysiwyg-color-purple\">Dijkstra's Algorithm</span></b>\ufeff, yet didn't necessarily have all of the same restrictions (e.g. <b><span class=\"wysiwyg-color-blue\">Kruskal's Algorithm</span></b> and <b><span class=\"wysiwyg-color-blue\">Prim's Algorithm</span></b> can easily work with negative edges). <br></p><p><span class=\"wysiwyg-color-red\"><b>STOP and Think:</b></span><b> </b>For a graph with all unique edge weights, both <b><span class=\"wysiwyg-color-purple\"><span class=\"wysiwyg-color-blue\">Kruskal's</span> </span></b>and <b><span class=\"wysiwyg-color-blue\">Prim's Algorithm</span></b> will always return the same exact <b><span class=\"wysiwyg-color-red\">MST</span></b>. Why might this be the case?<br></p>", "feedback_correct": "", "video": null, "animation": null}}