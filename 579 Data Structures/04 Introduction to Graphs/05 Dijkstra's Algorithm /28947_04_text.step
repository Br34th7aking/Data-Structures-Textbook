{"id": "116294", "block": {"subtitles": {}, "source": null, "video": null, "feedback_wrong": "", "options": {}, "animation": null, "text": "<p>Here is a glimpse at how the pseudocode for <b><span class=\"wysiwyg-color-purple\">Dijkstra's Algorithm</span></b> looks:<br></p><p></p><pre><code class=\"cpp\"><b>dijkstra(s):</b><br>    // perform initialization step\n    pq = empty priority queue\n    for each vertex v:\n        v.dist = infinity           // the maximum possible distance from s\n        v.prev = NULL               // we don't know the optimal previous node yet\n        v.done = false              // v has not yet been discovered\n\n    // perform the traversal\n    enqueue {0, s} onto pq          // enqueue the starting vertex\n    while pq is not empty:\n        dequeue {weight, v} from pq\n        if v.done == false:         // if the vertex's min path hasn't been discovered yet\n            v.done = true\n            for each neighbor w of v:\n                c = v.dist + weight // c is the total distance to w through v\n                if c &lt; w.dist:      // if a smaller-weight path has been found\n                                    // (remember, all distances start at infinity!)\n                    w.prev = v      // update the node that comes just before w in the path from s to w\n                    w.dist = c      // update the distance of the path from s to w\n                    enqueue {c, w} onto</code></pre><p></p><p>As you can see above, <b><span class=\"wysiwyg-color-purple\">Dijkstra's Algorithm</span></b> runs as long as the priority queue is not empty. Moreover, the algorithm never goes back to update a vertex's fields once it is dequeued the first time. This implies that <b><span class=\"wysiwyg-color-purple\">Dijkstra's Algorithm </span>guarantees that, for each vertex, the first time an instance of it is removed from the priority queue, a shortest path to it has been found. </b>Why is this true? All other vertices discovered later in the exploration of <b><span class=\"wysiwyg-color-purple\">Dijkstra's Algorithm</span></b> must have at least as great a total path cost to them as the vertex that was just dequeued (if it had a smaller total path cost, then that vertex would have been discovered earlier). Therefore, we couldn't possibly achieve a smaller cost pathway by considering the vertices that appear later in the priority queue. This type of algorithmic approach, where we commit to a decision and never look back, is called a \"greedy\" approach. Note that the \"greedy algorithm\" is able to produce an optimal solution each time! <br></p><p>All this time though we have been making one assumption: <b>no negative weight edges can exist in the graph</b>! Why? Because if negative weights existed, then we couldn't guarantee that vertices further down a pathway would have at least as great a total path cost to them. By only allowing edges with a weight of 0 or larger, we guarantee that \nany future edges we encounter in our search can only either increase our total \npath weight or keep it the same value (if the edge weight is 0).\u00a0 For example, take a look at the graph below:</p><p><img src=\"https://ucarecdn.com/4e0f9a7e-c554-4a78-a90c-05241d13d241/\" alt=\"\" title=\"Image: https://ucarecdn.com/4e0f9a7e-c554-4a78-a90c-05241d13d241/\"></p><p>If <b><span class=\"wysiwyg-color-purple\">Dijkstra's Algorithm</span></b> starts at vertex 1, it would discover vertex 2 first (since it has a total path cost of 1) and then vertex 3 (since it has a total path cost of 1+1 = 2) and lastly vertex 4 (since it has a total path cost of 4). However, the shortest path from vertex 1 to vertex 3 actually has a total path cost of 1! How? If you take the path 1 \n\n\u2192\n4 \n\n\u2192\n3, you would end up with a path cost of 4 + (-3) = 1.\u00a0</p>", "feedback_correct": "", "tests_archive": null, "subtitle_files": [], "name": "text"}, "time": "2016-09-03T01:10:07.059635"}