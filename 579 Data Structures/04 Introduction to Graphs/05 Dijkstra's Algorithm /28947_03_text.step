{"id": "116293", "block": {"name": "text", "feedback_correct": "", "animation": null, "subtitle_files": [], "video": null, "feedback_wrong": "", "options": {}, "source": null, "text": "<p>Up until now, we've been saying at a higher level that <b><span class=\"wysiwyg-color-purple\">Dijkstra's Algorithm</span></b> needs to just\u00a0<br></p><ol><li>Search for the next shortest path that exists in the graph, and</li><li>See which vertex it discovers by taking that shortest path.</li></ol><p>However, how do we get an algorithm to just \"search\" for the next shortest path? Unfortunately, a computer can't just visually scan the graph all at once like we've been doing. To solve this problem, <b><span class=\"wysiwyg-color-purple\">Dijkstra's Algorithm</span></b> takes advantage of the <b>Priority Queue</b>\u00a0ADT to store the possible paths and uses the total weights of the paths to determine priority.</p><p>So how do we go about storing the possible paths? The intuitive approach would be to store the paths themselves in the priority queue (e.g. (<i>A\u00a0</i>\u2192 <i>B\u00a0\u2192 C</i>), (<i>A\u00a0</i>\u2192 <i>B\u00a0<b>\u2192 </b>D</i>), etc.). However, when the priority queue tries to order the paths, it would need to repeatedly recompute the total path weights to perform its priority comparisons. Thus, to save time, it might seem easiest to store all the paths with their respective total path costs (e.g. (1, <i>A</i> <b>\u2192\u00a0</b><i>B\u00a0\u2192 C</i>), (3, <i>A \u2192\u00a0B\u00a0\u2192\u00a0D</i>), etc.). However, as our graphs grow larger, this can lead to wasting a lot of space (for example, notice how the path <i>A \u2192 B</i>\u00a0was repeated twice in the example above). To combat this waste of space, we instead make the realization that, when following a path, it is enough to know only the <i>one</i> immediate vertex that is to be explored at the end of the path at each step. As a result, rather than inserting <i>entire paths</i> with their respective costs in the priority queue, we store tuples consisting of (<i>cost</i>, <i>vertex to explore</i>).<br></p><p>For our purposes, a vertex object needs to contain at least these 3 fields:</p><ul><li><i>Distance</i>: the shortest path that was discovered to get to this vertex</li><li><i>Previous</i>: the vertex right before it, so we can keep track of the path and overall structure of the graph</li><li><i>Done</i>: a Boolean field to determine if a shortest path has already been found to this vertex</li></ul><p></p><p>It is important to note that, since we are storing vertices that are immediately reachable from the current vertex in the priority queue, the same vertex can in fact appear in the \npriority queue more than once if there exists more than one path to reach it.<br></p><p></p>", "subtitles": {}, "tests_archive": null}, "time": "2016-09-15T15:02:24.923066"}