{"id": "112171", "block": {"feedback_correct": "", "name": "text", "feedback_wrong": "", "text": "<p></p><p>Just like BFS took advantage of the queue ADT to explore the vertices in a particular order,<span class=\"wysiwyg-color-green\"> <b><span class=\"wysiwyg-color-blue\">Depth First Search</span></b></span> takes advantage of the <b>stack</b> ADT. The intuition behind choosing a stack for <span class=\"wysiwyg-color-green\"><b><span class=\"wysiwyg-color-blue\">DFS</span></b></span> stems from a stack's<i> first-in last-out </i>property. With this property, we guarantee that we will explore all the\n vertices pushed (put on the stack) most recently first, before moving on to vertices that were adjacent to a vertex from before. <br></p>\n\n\n\n\n\n\n\n\n\n\n<p></p><p></p><pre><code><b>DFSShortestPath(u,v):</b><br>\u00a0   s = an empty stack<br>\u00a0   push (0,u) to s // (0,u) -&gt; (length from u, current vertex)<br>\u00a0   while s is not empty:<br>\u00a0 \u00a0     (length,curr) = s.pop()<br>\u00a0 \u00a0     if curr == v: // if we have reached the vertex we are searching for<br>\u00a0 \u00a0 \u00a0       return length<br>\u00a0 \u00a0     for all outgoing edges (curr,w) from curr: // otherwise explore all neighbors\n            if w has not yet been visited:\n                add (length+1,w) to s\n    return \"FAIL\" // if I reach this point, then no path exists from u to v</code></pre><p></p><p>Notice that the only change in the algorithm from the BFS \nalgorithm we provided earlier is that all mentions of \"queue\" have been \nturned into \"stack.\" (Isn't it crazy how the replacement of one data \nstructure can create an entirely new algorithm?)<br>\n</p><p></p>", "subtitle_files": [], "source": null, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2016-09-07T23:37:48.434875"}