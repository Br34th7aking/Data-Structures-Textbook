{"id": "111038", "time": "2016-09-02T18:25:29.139161", "block": {"animation": null, "text": "<p>\n\nThe \"insert\" algorithm is almost identical to the \"find\" algorithm: you first execute the \"find\" algorithm just like before, but once you find the insertion site, you rearrange pointers to fit the new node in its rightful spot. \n\nBelow is an example of inserting the number 5 to index 1 of the <b><span class=\"wysiwyg-color-blue\">Linked List</span></b> (using 0-based counting):</p><p><img src=\"https://ucarecdn.com/e17d6f85-0435-421d-8f6c-1724ba80ae2e/\" alt=\"\"></p><p>Notice how we do a regular \"find\" operation to the index directly\u00a0<i>before</i> index <i>i</i>, then we point the new node's \"next\" pointer to the node that was previously at index\u00a0<i>i</i> (and the new node's \"prev\" pointer to the node that is directly\u00a0<i>before</i> index\u00a0<i>i</i> in the case of a <b>Doubly-Linked List</b>, as above), and then we point the \"next\" pointer of the node before the insertion site to point to the new node (and the \"prev\" pointer of the node previously at index\u00a0<i>i</i> to point to the new node in the case of a <b>Doubly-Linked List</b>).</p><p>Because the structure of a <b><span class=\"wysiwyg-color-blue\">Linked List</span></b>\u00a0is only based on pointers, the insertion algorithm is complete simply after changing those pointers.</p>", "options": {}, "feedback_correct": "", "source": null, "subtitle_files": [], "name": "text", "feedback_wrong": "", "subtitles": {}, "tests_archive": null, "video": null}}