{"id": "115156", "block": {"subtitles": {}, "source": null, "video": null, "feedback_wrong": "", "options": {}, "animation": null, "text": "<p>Based on what we have learned so far in this text, there are two approaches we could take that are quite good for implementing a <b>Deque</b>: using a <b><span class=\"wysiwyg-color-blue\">Linked List</span></b> or using a <b><span class=\"wysiwyg-color-purple\">Circular Array</span></b>. As you should recall, both data structures have good performance when accessing/modifying elements at their front/back, so how can we make a decision about which of the two we would want to use to implement a <b>Deque</b>?</p><p>If we were to choose a <b><span class=\"wysiwyg-color-blue\">Linked List</span></b>\u00a0(a <b><span class=\"wysiwyg-color-blue\"><i>Doubly</i>-Linked List</span></b>, specifically), because we would have direct access to both the\u00a0<i>head</i> and\u00a0<i>tail</i> nodes and because inserting/removing elements at the front and back of a <b><span class=\"wysiwyg-color-blue\">Doubly-Linked List</span></b> can be reduced to constant-time pointer rearrangements, we would be guaranteed <b>O(1)</b> time\n\nfor all six of the <b>Deque</b> operations described previously, no matter what. However,\u00a0<i>if</i> we were to want access to the middle elements of our\u00a0<b>Deque</b>, a <b><span class=\"wysiwyg-color-blue\">Doubly-Linked List</span></b> would require a <b>O(</b><i><b>n</b></i><b>)</b> \"find\" operation, even if we know exactly which index in our <b>Deque</b> we want to access.</p><p>If we were to choose a\u00a0<b><span class=\"wysiwyg-color-purple\">Circular Array</span></b>, because we have direct access to both the\u00a0<i>head</i> and\u00a0<i>tail</i> indices and because the backing array has constant-time access to any element, the \"find\" and \"remove\" operations of the\u00a0<b>Deque</b> are guaranteed to have <b>O(1)</b> time. However, even though inserting into the <b><span class=\"wysiwyg-color-purple\">Circular Array</span></b>\u00a0<i>usually</i> has O(1) time, recall that, when the backing array is completely full, we need to create a new backing array and copy all of the elements over, which results in a <b>O(</b><i><b>n</b></i><b>)</b> worst-case time complexity. Also,\u00a0<i>if</i> we were to want access to the middle elements of our\u00a0<b>Deque</b>, if we knew exactly which index in our\u00a0<b>Deque</b> we wanted to access, the random access property of an array would allow us <b>O(1)</b> time access.</p>", "feedback_correct": "", "tests_archive": null, "subtitle_files": [], "name": "text"}, "time": "2016-09-03T01:07:19.077760"}