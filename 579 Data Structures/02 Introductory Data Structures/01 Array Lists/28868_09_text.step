{"id": "110717", "block": {"feedback_correct": "", "name": "text", "feedback_wrong": "", "text": "<p>As you may have inferred, the worst-case time complexity to find an element in an arbitrary <b><span class=\"wysiwyg-color-green\">Array List</span></b>\u00a0is <b>O(</b><i><b>n</b></i><b>)</b> because there is no known order to the elements, so we have to individually check each of the\u00a0<i>n</i> elements.</p><p></p><p>However, what if our <b><span class=\"wysiwyg-color-green\">Array List</span></b>\u00a0happened to be sorted? Could we exploit that, along with the feature of random access, to speed things up? We will introduce an algorithm called\u00a0<b>Binary Search</b>, which allows us to exploit random access in order to obtain a worst-case time complexity of <b>O(log\u00a0</b><i><b>n</b></i><b>)</b> for searching in a\u00a0<b>sorted <span class=\"wysiwyg-color-green\">Array List</span></b>. The basic idea is as follows: because we have random access, compare the element we're searching for against the middle element of the array. If our element is less than the middle element, our element must exist on the left half of the array (if at all), so repeat the search on the left half of the array since there is no longer any point to search in the right half of the array. If our element is larger than the middle element, our element must exist on the right half of the array (if at all), so repeat on the right half of the array. If our element is equal to the middle element, we have successfully found our element.\u00a0</p><p></p><pre><code class=\"cpp\"><b>BinarySearch(array, element): // perform binary search to find element in array\n</b>    L = 0 and R = n-1            // initialize \"left\" and \"right\" indices\n\n    loop infinitely:\n        if L &gt; R:                // \"left\" index is larger than \"right\" index, so we failed\n            return False\n        M = the floor of (L+R)/2 // compute middle index\n\n        if element == array[M]:  // if element equals middle element, we found our element\n            return True\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\n        if element &gt; array[M]:   // if element is larger than middle element, \"recurse\" right\n            L = M+1\n        if element &lt; array[M]:   // if element is smaller than middle element, \"recurse\" left\n            R = M - 1\n</code></pre><p></p>", "subtitle_files": [], "source": null, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2016-09-02T19:33:05.334865"}