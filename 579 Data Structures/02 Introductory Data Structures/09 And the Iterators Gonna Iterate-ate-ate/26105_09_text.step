{"time": "2016-09-05T12:26:34.846466", "block": {"tests_archive": null, "animation": null, "feedback_correct": "", "subtitles": {}, "source": null, "text": "<p>Below is an example of implementing an iterator for an <b><span class=\"wysiwyg-color-green\">Array List</span></b>.\u00a0Note that we have omitted the actual <b><span class=\"wysiwyg-color-green\">Array List</span></b> functions (e.g. <span class=\"wysiwyg-font-tt\">find</span>, <span class=\"wysiwyg-font-tt\">insert</span>, <span class=\"wysiwyg-font-tt\">remove</span>, etc.) for the sake of keeping the example clean and focused on iterators.<br></p><p></p><pre><code class=\"cpp\">// Array List class\nclass ArrayList {\n    public:\n        int arr[10]; // backing array\n        int size;    // number of elements that have been inserted\n\n        // Iterator class\n        class iterator : public std::iterator&lt;std::forward_iterator_tag, int&gt; {\n            public:\n                friend class ArrayList;  // declare Array List class as a friend class\n                int* curr;               // the element this iterator is pointing to\n\n                // the following typedefs are needed for the iterator to play nicely with C++ STL\n                typedef int value_type;<br>\u00a0 \u00a0             typedef int&amp; reference;<br>\u00a0             \u00a0 typedef int* pointer;<br>\u00a0             \u00a0 typedef int difference_type;<br>\u00a0             \u00a0 typedef std::forward_iterator_tag iterator_category;\n\n                // iterator constructor\n                iterator(int* x=0):curr(x){}\n                \n                // overload the == operator of the iterator class\n                bool operator==(const iterator&amp; x) const {\n                    return curr == x.curr; // compare curr pointers for equality\n                }\n\n                // overload the != operator of the iterator class\n                bool operator!=(const iterator&amp; x) const {\n                    return curr != x.curr; // compare curr pointers for inequality\n                }\n\n                // overload the * operator of the iterator class\n                reference operator*() const {\n                    return *curr;          // return curr's value\n                }\n\n                // overload the ++ (pre-increment) operator of the iterator class\n                iterator&amp; operator++() {\n                    curr++;                // move to next slot of array\n                    return *this;          // return after the move\n                }\n\n                // overload the ++ (post-increment) operator of the iterator class\n                iterator operator++(int) {\n                    iterator tmp(curr);    // create a temporary iterator to current element\n                    curr++;                // move to next slot of array\n                    return tmp;            // return iterator to previous element\n                }\n        };\n\n        // return iterator to first element\n        iterator begin() {\n            return iterator(&amp;arr[0]);\n        }\n\n        // return iterator to JUST AFTER the last element\n        iterator end() {\n            return iterator(&amp;arr[size]);\n        }\n};</code></pre><p></p><p>Then, if I were to want to iterate over the elements of this <b><span class=\"wysiwyg-color-green\">Array List</span></b>, I could easily do the following:</p><p></p><pre><code class=\"cpp\">for(auto it = l.begin(); it != l.end(); it++) {<br>    cout &lt;&lt; *it &lt;&lt; endl;<br>}<br></code></pre><p></p><p>As can be seen, similar to a\u00a0<b><span class=\"wysiwyg-color-blue\">Linked List</span></b>, we still use pointers to point to our elements when implementing an iterator for an\u00a0<b><span class=\"wysiwyg-color-green\">Array List</span></b>. However, in the\u00a0<b><span class=\"wysiwyg-color-green\">Array List</span></b> iterator, iterators pointed directly to elements in the array (i.e., the actual integers we were storing), whereas in the\u00a0<b><span class=\"wysiwyg-color-blue\">Linked List</span></b> iterator, iterators pointed to nodes, and we had to use the nodes to access the elements we were storing. The reason for this is that, with a\u00a0<b><span class=\"wysiwyg-color-blue\">Linked List</span></b>, because memory is allocated as nodes are created dynamically, the nodes are all over the place in memory, so we need to use the nodes' forward pointers to iterate over them. With an\u00a0<b><span class=\"wysiwyg-color-green\">Array List</span></b>, however, because the slots of the array are all allocated at once and are contiguous in memory, we can simply move across cells of the array.</p>", "options": {}, "subtitle_files": [], "name": "text", "video": null, "feedback_wrong": ""}, "id": "122239"}