{"id": "121924", "block": {"feedback_correct": "", "name": "text", "feedback_wrong": "", "text": "<p>The task of optimizing the distribution of heights in a\u00a0<b><span class=\"wysiwyg-color-red\">Skip List</span></b> falls on the\u00a0<b>insert</b> operation. We first perform the regular \"find\" algorithm to find where we will insert our new element. Then, we determine our new node's height. By definition, the new node must have a height of at least 0 (i.e., the 0-th layer). How many layers higher should we build? To answer this question, we play a simple coin-flip game: starting at our base height of 0, we flip a coin, where the coin's probability of heads is\u00a0<i>p</i>. If we flip heads, we increase our height by 1. If we flip tails, we stop playing the game and keep our current height.</p><p>Say, for example, we wish to insert 5 into the following\u00a0<b><span class=\"wysiwyg-color-red\">Skip List</span></b>:</p><p><img alt=\"\" src=\"https://ucarecdn.com/aaf667b6-8a9b-4d45-9e21-e9a72d56c97d/\"></p><p>First, we perform the regular \"find\" algorithm to find the insertion site for 5. In the figure below, <b><span class=\"wysiwyg-color-red\">red</span></b> arrows denote pointers that we <i>could</i> have traversed, but would have taken us to a node too big (so we instead chose to go down 1 level), and <b><span class=\"wysiwyg-color-green\">green</span></b> arrows denote pointers we actually took. As you hopefully inferred, the\u00a0<b><span class=\"wysiwyg-color-red\">red</span></b> arrows are the only ones that we might have to fix upon insertion.</p><p><img alt=\"\" src=\"https://ucarecdn.com/eece60fd-8987-460f-8356-eec07f4a4ea3/\"></p><p>Now that we have found our insertion site, we must determine the height of our new node. We know that the coin must have a height of at least 0, so we start our height at 0. Then, we flip a coin where the probability of heads is\u00a0<i>p</i>. Let's say we flipped heads (with probability <i>p</i>): we now increase our height from 0 to 1. Then, we flip the coin again. This time, let's say we flipped tails (with probability 1\u2013<i>p</i>): we stop playing the game and keep our height of 1. We perform the insertion with this new node by simply updating two pointers: one on layer 0 and one on layer 1.</p><p><img alt=\"\" src=\"https://ucarecdn.com/1daf3cc0-e821-4435-b18f-1d3f8f10d976/\" title=\"Image: https://ucarecdn.com/1daf3cc0-e821-4435-b18f-1d3f8f10d976/\"></p><p>Below is formal pseudocode to describe the \"remove\" algorithm. In the pseudocode, <span class=\"wysiwyg-font-tt\">head</span> is <i>head</i> and <span class=\"wysiwyg-font-tt\">head.height</span> is highest layer in\u00a0<i>head</i> (which is the highest layer in the\u00a0<b><span class=\"wysiwyg-color-red\">Skip List</span></b>, by definition). Also, for a given node <span class=\"wysiwyg-font-tt\">current</span>, <span class=\"wysiwyg-font-tt\">current.next</span> is a list of forward-pointers, where <span class=\"wysiwyg-font-tt\">current.next[i]</span> is the forward-pointer at layer\u00a0<i>i</i>. Lastly, note that the probability of coin-flip success,\u00a0<i>p</i>, must be a variable defined in the\u00a0<b><span class=\"wysiwyg-color-red\">Skip List</span></b> itself (we refer to it as\u00a0<span class=\"wysiwyg-font-tt\"><i>p</i></span> below).</p><p></p><pre><code class=\"cpp\"><b>insert(element): // inserts element if it doesn't exist in the list\n</b>    current = head\n    layer = head.height\n    toFix = empty list of nodes of length head.height + 1 (one slot for each layer)\n    while layer &gt;= 0:                   // can't go lower than layer 0\n        if current.next[layer] is NULL or current.next[layer] &gt; element:\n            toFix[layer] = current      // we might have to fix a pointer here\n            layer = layer - 1           // drop one layer if we can't go further\n        else:\n            current = current[layer].next\n        if current == element:          // if we found element, return (no duplicates)\n            return\n\n    // if we reached here, we can perform the insertion\n    newNode = new node containing element, starting with height = 0\n    while newNode.height &lt; head.height: // can't go higher than head node's height\n        result = result of coin-flip with probability <i>p</i> of heads\n        if result is heads:\n            height = height + 1\n    for i from 0 to newNode.height:     // fix pointers\n        newNode.next[i] = toFix[i].next[i]\n        toFix[i].next[i] = newNode</code></pre>", "subtitle_files": [], "source": null, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2016-09-07T23:34:10.320866"}