{"id": "96576", "block": {"feedback_correct": "", "name": "text", "feedback_wrong": "", "text": "<p><b>Huffman's Algorithm - <span class=\"wysiwyg-color-purple\">Message Decoding<span class=\"wysiwyg-color-black\">:</span></span></b></p><p>If we have the Huffman Tree, decoding a message is easy:</p><ul><li>Start with the first bit in the coded message, and start with the root of the code tree</li><li>As you read each bit, move to the left or right child of the current node, matching the bit just read with the label on the edge</li><li>When you reach a leaf, output the symbol stored in the leaf, return to the root, and continue</li></ul><p>Note: Multiple Huffman Trees can be constructed from the same message (e.g. we could simply swap 1's and 0's in our tree). To be able to decode a message, we must ensure we're using the <b>same Huffman Tree</b> that was used to encode the message! Therefore, the tree, or enough information to reconstruct the tree exactly, must be included before the beginning of the coded message (the header I mentioned earlier) or in some other way transmitted to the receiver.<br></p><p>Thus, in practice, the first step of the <b><span class=\"wysiwyg-color-blue\">Message Encoding</span></b> stage is to write to the compressed file some header with information about symbol frequencies (so that the recipient can rebuild the Huffman Tree), and the first step of the <b><span class=\"wysiwyg-color-purple\">Message Decoding</span></b> stage is to read in the header of the file and actually rebuild the Huffman Tree.</p>", "subtitle_files": [], "source": null, "animation": null, "video": null, "tests_archive": null, "options": {}, "subtitles": {}}, "time": "2016-09-05T17:15:14.579190"}