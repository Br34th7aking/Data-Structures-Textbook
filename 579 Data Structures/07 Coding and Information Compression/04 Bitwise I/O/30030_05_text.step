{"block": {"video": null, "tests_archive": null, "feedback_correct": "", "animation": null, "text": "<p>Thus far, we have mentioned that we flush the bytewise buffer once it's been filled, which means that we write all of the bytes to disk. What about if we have run out of bytes we want to write, but our bytewise buffer is not full? We mentioned previously that a \"good size\" for a bytewise buffer is 4 KB (i.e., 4,096 bytes), but what if we only have 100 bytes we wish to write to disk? The solution is trivial: we just flush the bytewise buffer by writing whatever bytes we\u00a0<i>do</i> have to disk. In the example above, instead of writing 4 KB, we only write 100 bytes.</p><p>However, with a bitwise buffer, things are a bit more tricky if we run out of bits to write before the bitwise buffer is full. The difficulty is caused by the fact that the smallest unit that can be written to disk is 1\u00a0<i>byte</i>, which is 8\u00a0<i>bits</i>. For example, say we want to write to disk a sequence of bits that is not a multiple of 8 (e.g. 111111111111):</p><p></p><ul><li>We would write the first 8-bit chunk (11111111), and 1111 would be left</li><li>We would then try to write the remaining chunk (1111), but we are unable to do so because it is not a full byte</li></ul><p>The solution is actually still quite simple: we can simply \"pad\" the last chunk of bits with 0s such that it reaches the full 8 bits we need to write to disk. Because bytes and bits are traditionally read from \"left\" to \"right\" (technically the way it is laid out in the computer architecture does not have \"left\" or \"right\" directionality, but instead \"small offset\" to \"large offset\"), we want our padding 0s to be on the right side of our final byte such that the bits remain contiguous. In the same example as above:<br></p><p></p><ul><li>We would write the first 8-bit chunk (11111111), and 1111 would be left</li><li>We would then pad 1111 to become 11110000, and we would write this padded byte</li><li>The result on disk would be: 11111111 \u00a0 11110000 (the space implies that the bits are two separate bytes)</li></ul><p>This way, when we read from disk, we can simply read the bits from left to right. However, note that we have no way of distinguishing the padding 0s from \"true\" bits. For example, what if we were to write the bit sequence 1111111111110000?<br></p><p></p><ul><li>We would write the first 8-bit chunk (11111111), and 11110000 would be left</li><li>We would then write the remaining 8-bit chunk (11110000)</li><li>The result on disk would be: 11111111 \u00a0 11110000 (the same two bytes written to disk as before)</li></ul><p>As can be seen, because we cannot distinguish the padding 0s from \"true\" bits (as they're indistinguishable on disk), we need to implement some clever way of distinguishing between them manually. For example, we could add a \"header\" to the beginning of the file that tells us how many bits we should be reading. For example, we could do the following in the previous example:<br></p><p></p><ul><li>00001100 \u00a0 11111111 \u00a0 11110000</li><li>The first byte (00001100) tells us how many bits we should expect to read (00001100 = 12)</li><li>We would then read the next byte (11111111) and know that we have read 8 bits (so we have 4 bits left to read)</li><li>We would then read the next byte (11110000) and know that we should only read the first 4 bits (1111)</li></ul><p>It is important to note that this exact header implementation (\"How many bits should we expect to read?\") is just <i>one</i> example. Thus, in whatever applications you may develop that require bitwise input and output, you should think of a clever header that would be optimal for your own purposes.<br></p><p></p><p></p><p></p><p></p>", "subtitle_files": [], "subtitles": {}, "feedback_wrong": "", "name": "text", "source": null, "options": {}}, "id": "122894", "time": "2016-09-14T00:14:31.668352"}