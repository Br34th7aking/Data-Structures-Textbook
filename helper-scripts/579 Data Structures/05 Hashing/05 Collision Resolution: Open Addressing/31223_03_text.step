{"id": "121349", "block": {"feedback_wrong": "", "tests_archive": null, "text": "<p>So how do we go about actually implementing this simple <b><span class=\"wysiwyg-color-red\">collision resolution strategy</span></b>? Here is the pseudocode to implement <b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b> when inserting a key <i>k</i> into a <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b> of capacity <i>M</i> with a backing array called <i>arr</i>, using an indexing <b><span class=\"wysiwyg-color-green\">hash function</span></b> <i>H</i>(<i>k</i>):</p><p></p><pre><code class=\"cpp\"><b>insert_LinearProbe(k): // Insert k into the Hash Table using Linear Probing</b>\n    index = H(<b></b>k<b></b>)\n\n    Loop infinitely:\n        if <b></b>arr<b></b>[index] == <b></b>k<b></b>:         // check for duplicate insertions\n            return\n\n        else if <b></b>arr<b></b>[index] == NULL: // insert if slot is empty\n            <b></b>arr<b></b>[index] = k\n            return\n\n        else:                       // there is a collision, so recalculate index\n            index = (index + 1) % <b></b>M<b>\n</b><b>\n        </b>if index == H(<b></b>k<b></b>):           // we went full circle (no empty slots)\n            enlarge arr and rehash all existing elements\n            index = H(k)            // H(k) will index differently now that arr is a different size</code></pre><p></p><p>Notice that the core of the <b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b> algorithm is defined by this equation:</p><pre><code>index = (index + 1) % <b></b>M<b></b></code></pre><p></p><p>By obeying the equation above, we are ensuring that our key is inserted strictly within an index (or more formally, an address) <i>inside</i> our <b><span class=\"wysiwyg-color-purple\">Hash Table</span></b><span class=\"wysiwyg-color-purple\"><span class=\"wysiwyg-color-black\">. Consequently, we call this a\u00a0<b>closed hashing</b> <b><span class=\"wysiwyg-color-red\">collision resolution strategy</span></b> (i.e., we will insert the actual key only in an address bounded by the realms of our </span></span><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-purple\">Hash Table</span></b></span><span class=\"wysiwyg-color-purple\"><span class=\"wysiwyg-color-black\">). Moreover, since we are inserting the keys themselves into the calculated addresses, we like to say that\u00a0<b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b> is an\u00a0<b>open addressing\u00a0<b><span class=\"wysiwyg-color-red\">collision resolution strategy</span></b></b> (i.e.,\u00a0</span></span>the keys are open to move to an address other than the address to which they initially hashed<span class=\"wysiwyg-color-purple\"><span class=\"wysiwyg-color-black\">).</span></span></p><p><span class=\"wysiwyg-color-purple\"><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-red\">Note:</span></b> You will most likely encounter people using the terms <b>closed hashing\u00a0</b>and\u00a0<b>open addressing\u00a0</b>interchangeably since they arguably describe the same method of </span></span><b><span class=\"wysiwyg-color-red\">collision resolution</span></b>.</p><p><b><span class=\"wysiwyg-color-red\">STOP and Think:</span> </b>How would we go about <i>finding<b></b></i> a key using <b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b>?</p>", "subtitle_files": [], "options": {}, "name": "text", "subtitles": {}, "animation": null, "feedback_correct": "", "source": null, "video": null}, "time": "2016-09-04T00:50:00.858024"}