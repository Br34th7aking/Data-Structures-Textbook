{"id": "122232", "block": {"feedback_wrong": "", "tests_archive": null, "text": "<p>Intuitively, you might think that, instead of probing one slot over during each step of our scan, we could just choose a larger \"skip\": why not jump\u00a0<i>two</i> slots over? Or\u00a0<i>three</i> slots over? This way, the the elements would be more spaced out, so we would have solved the issue of clumps, right? Unfortunately, it's not that simple, and the following example will demonstrate why simply changing the skip from 1 to some larger value doesn't actually change anything. Let's start with the following empty\u00a0<b><span class=\"wysiwyg-color-purple\">Hash Table</span></b>, and let's use a skip of 3:</p><p><img alt=\"\" src=\"https://ucarecdn.com/c15e33e3-b546-4f77-a777-78805bd33ef1/\"></p><p>Just like before, if we were to insert a new key, it has a 1/5 chance of landing in any of our 5 slots, so again, let's just say it happened to land in slot 0 by chance:</p><p><img alt=\"\" src=\"https://ucarecdn.com/1a0f102f-777c-4445-bd7a-2e650a8f9a3b/\"></p><p>Now, let's insert another new key. Like before, it has a 1/5 chance of indexing to 0, 1, 2, 3, or 4. If it happens to land in slots 1, 2, 3, or 4 (each with 1/5 probability), we would simply perform the insertion. However, if it were to land in slot 0 (with probability 1/5), we would have a collision. Before, in traditional\u00a0<b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b>, we had a skip of 1, so we shifted over to slot 1. Now, we have a skip of 3, so we would shift over to slot 3 instead. As a result, out of our four open slots (1, 2, 3, and 4), slots 1, 2, and 4 each have a 1/5 chance of being filled, but slot 3 has a\u00a0<b>2/5</b> chance, which is\u00a0<b>twice as large</b> as the others! Because its probability is twice as large as the others, let's say slot 3 is the one that ended up getting filled:</p><p><img alt=\"\" src=\"https://ucarecdn.com/548b142b-87af-4f5b-9b3e-53a9bd19a63a/\"></p><p>Now, what if we were to insert yet another key? Just as before, slots 2 and 4 each have a 1/5 chance of being filled (if we were to index to 3 or 4, respectively). To fill slot 1, we could index to 1 with 1/5 chance, but what would happen if we were to index to 3? Again, because of <b></b><span class=\"wysiwyg-color-black\"><b><span class=\"wysiwyg-color-blue\">Linear Probing</span></b></span><span class=\"wysiwyg-color-blue\"><span class=\"wysiwyg-color-black\"><b></b>, if we index to 3, we would see the slot is filled, and we would shift over 3 times, so we would wrap around to slot 1 and perform the insertion. Likewise, if we index to 0, we would see the slot is filled and shift over to slot 3, see that's filled too, and then shift over and wrap around to slot 1 and perform the insertion. In other words, probability of landing in slot 1 is <b>3/5</b>, which is <b>three times as likely</b> as any of the other slots!</span></span></p><p>Even though it might\u00a0<i>appear</i> as though the clumps have disappeared because there's more space between filled slots, it turns out that the clumps still do in fact exist: they are just harder to see. The reason\u00a0<i>why</i> clumps tend to grow is the exact probabilistic issue we saw above (and \u00a0on the previous step): with the initial indexing, all slots are equally likely to be filled, but upon collision, we deterministically increase the probability of filling certain slots, which are the slots that expand a clump.</p><p>This issue of uneven probabilities across open slots is the exact reason\u00a0<i>why</i> we see clumps probabilistically grow. In this example, the reason why the clump grew is because, if we were to index to either slot 0 or slot 3, there was a 100% chance that the actual insertion would occur at slot 1. As a result, out of the three open slots, slot 1 was the one that was most likely to be filled. What if we had some way of\u00a0<i>randomizing</i> which of the three open slots our new key would fall into? If all three open slots were equally likely to be filled, the issue of clumps would be resolved. In the next section, we will discuss even more clever\u00a0<b>Open Addressing</b>\ufeff techniques that achieve exactly this, but in a deterministic fashion such that we would still be able to find the key if we were to search for it in the future.</p>", "subtitle_files": [], "options": {}, "name": "text", "subtitles": {}, "animation": null, "feedback_correct": "", "source": null, "video": null}, "time": "2016-09-04T00:50:07.102852"}